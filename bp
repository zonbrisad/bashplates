#!/usr/bin/env bash
# shellcheck disable=2034
# shellcheck disable=2317
# shellcheck disable=1090
#---------------------------------------------------------------------
#
#  bp
#
#  [Description]
#    Bashplate management script
#
#  [Author]
#    Peter Malmberg <peter.malmberg@gmail.com>
#
#  [Date]
#    2016-xx-xx
#
#  [License]
#     MIT
#
#---------------------------------------------------------------------
# Generated with bashplates. [https://github.com/zonbrisad/bashplates]
#---------------------------------------------------------------------
#

# Display commands as they are executed
#set -o xtrace
# Display shell input lines as they are read
#set -v

# Exit script when a command fails. Append ||true if error is expected
#set -o errexit # || true
# Exit script when undeclared variable is used
#set -o nounset
# Exit script when pipe fails
set -o pipefail

#---------------------------------------------------------------------
# User defined Settings
#---------------------------------------------------------------------
bpUserSettings() {
  BP_ADDONS="${BP_SELF_DIR}/addons"
  BP_TEMPLATES="${BP_SELF_DIR}/templates"

  BP_PREAMBLE="#!/usr/bin/env bash"
  BP_HEADER="${BP_TEMPLATES}/header"

  if [ -f "${BP_SELF_DIR}/DEV" ]; then
    BP_DEV=1
  fi
}
#---------------------------------------------------------------------
# User defined functions
#---------------------------------------------------------------------

##- Bashplates

#
# $1 source file
# $2 destination file
#
bpAppend() { ##I Append file to file
  if [ ! -f "$1" ]; then
    bpError "Can't append file $(bpColorizeFile "${1}") to $(bpColorizeFile "${2}")."
  fi
  cat "$1" >>"$2"
}

#
# Create a new script
#
# $1 template file
# $2
# $3 type
#
newScript() {
  t=$3
  name=$(bpReadStr "Enter name of new ${t}" "")

  if [ "$3" == "addon" ]; then
    script="${name}.bpaddon"
  else
    script="${name}"
  fi

  if [ -e "${script}" ]; then
    bpError "File ${E_BR_CYAN}${script}${E_END} already exists"
    return
  fi

  desc=$(bpReadStr "Enter description")
  author=$(bpReadStr "Enter author" "${BP_NAME} <${BP_EMAIL}>")

  echo "${BP_PREAMBLE}" >|"${script}"
  bpImport "$BP_HEADER" >>"${script}"
  cat "${BP_TEMPLATES}/$1" >>"${script}"
  chmod +x "${script}"

  if [ "$3" == "addon" ]; then
    bpInsert "${script}" "#__MODULES__" "$(bpaddon getaddontemp)"
  else
    bpReplaceLine "${script}" "#__MODULES__" ""
  fi

  bpReplace "${script}" "__NAME__" "${name}"
  bpReplace "${script}" "__DATE__" "${BP_DATE}"
  bpReplace "${script}" "__LICENSE__" "${BP_LICENSE}"
  bpReplace "${script}" "__AUTHOR__" "${author}"
  bpReplace "${script}" "__DESC__" "${desc}"

  bpOk "Created file $script"
}

new() { ##D Create a new standard bashplate project
  newScript "bashplate" "" "script"
}

newd() { ##C BP_DEV Create a new standard bashplate project (develop)
  newScript "bashplate-dev" "" "script"
}

news() { ##D Create a new simple bashplate project
  newScript "bashplate-simple" "" "script"
}

newi() { ##C BP_DEV Create new init script
  name=$(bpReadStr "Enter name of init script" "")
  desc=$(bpReadStr "Enter description")
  script="${name}"
  cat "${BP_TEMPLATES}/bashplate-init" >>"${script}"
  bpReplace "${script}" "__DESC__" "${desc}"
  bpReplace "${script}" "__NAME__" "${name}"
  chmod +x "${script}"
  bpOk "Created file $script"
}

##- Documentation

cs() { ##D Cheat sheet for common BASH features
  BP_LINE_CHAR=""

  if [ "$BP_COLUMNS" -ge 200 ]; then
    BP_COLUMNS=$(("$BP_COLUMNS" / 4 - 1))
    cs-cheat-sheet | "${BP_SELF_DIR}"/dev/columnize.py --columns 4
    return
  fi

  if [ "$BP_COLUMNS" -ge 150 ]; then
    BP_COLUMNS=$(("$BP_COLUMNS" / 3 - 1))
    cs-cheat-sheet | "${BP_SELF_DIR}"/dev/columnize.py --columns 3
    return
  fi

  if [ "$BP_COLUMNS" -ge 100 ]; then
    BP_COLUMNS=$(("$BP_COLUMNS" / 2 - 1))
    cs-cheat-sheet | "${BP_SELF_DIR}"/dev/columnize.py --columns 2
    return

  fi
  cs-cheat-sheet
}

# shellcheck disable=2016
cs-cheat-sheet() {
  # https://devhints.io/bash

  bpPrintLine "Arithmetic operators"
  bpPrintDesc '(( N1 + N2 ))' "Addition"
  bpPrintDesc '(( N1 - N2 ))' "Subtraction"
  bpPrintDesc '(( N1 * N2 ))' "Multiplication"
  bpPrintDesc '(( N1 / N2 ))' "Division"
  bpPrintDesc '(( N1 % N2 ))' "Modulo"
  bpPrintDesc '(( N1 ** N2 ))' "Exponentiation"
  bpPrintDesc '(( N1++ ))' "Variable increment"
  bpPrintDesc '(( N1-- ))' "Variable decrement"

  bpPrintLine "Bitwise operators"
  bpPrintDesc '(( N1 << N2 ))' "Bitwise shift left"
  bpPrintDesc '(( N1 >> N2 ))' "Bitwise shift right"
  bpPrintDesc '(( N1 & N2 ))' "Bitwise and"
  bpPrintDesc '(( N1 | N2 ))' "Bitwise or"
  bpPrintDesc '(( N1 ^ N2 ))' "Bitwise xor"
  bpPrintDesc '(( N1 ~ N2 ))' "Bitwise negation"

  bpPrintLine "Logical operators"
  bpPrintDesc '(( N1 && N2 ))' "Logical and"
  bpPrintDesc '(( N1 || N2 ))' "Logical or"

  bpPrintLine "Arithmetic tests"
  bpPrintDesc '(( N1 == N2 ))' "Equal"
  bpPrintDesc '(( N1 != N2 ))' "Not equal"
  bpPrintDesc '(( N1 < N2 ))' "Less than"
  bpPrintDesc '(( N1 <= N2 ))' "Less than or equal"
  bpPrintDesc '(( N1 > N2 ))' "Greater than"
  bpPrintDesc '(( N1 >= N2 ))' "Greater than or equal"

  bpPrintLine "String tests"
  bpPrintDesc '[ "$STR1" == "$STR2" ]' "Strings equal"
  bpPrintDesc '[ "$STR1" != "$STR2" ]' "Strings not equal"
  bpPrintDesc '[ -z STRING ]' "Empty string"
  bpPrintDesc '[ -n STRING ]' "Not empty string (string exists)"
  bpPrintDesc '[[ STRING =~ STRING ]]' "Regexp"

  bpPrintLine "Logical tests"
  bpPrintDesc "[ ! EXPR ]" "Not"
  bpPrintDesc "[ X ] && [ Y ]" "And"
  bpPrintDesc "[ X ] || [ Y ]" "Or"

  bpPrintLine "Other tests"
  bpPrintDesc "[ -o noclobber ]" "If OPTIONNAME is enabled"

  bpPrintLine "File conditions"
  bpPrintDesc "[ -e FILE ]" "File exists"
  bpPrintDesc "[ -f FILE ]" "Is regular file"
  bpPrintDesc "[ -d FILE ]" "Is directory"
  bpPrintDesc "[ -h FILE ]" "Is symlink"
  bpPrintDesc "[ -r FILE ]" "Is readble"
  bpPrintDesc "[ -w FILE ]" "Is writable"
  bpPrintDesc "[ -x FILE ]" "Is executable"
  bpPrintDesc "[ -s FILE ]" "Size>0"
  bpPrintDesc "[ -S FILE ]" "Is socket"
  bpPrintDesc "[ -g FILE ]" "sgid bit set"
  bpPrintDesc "[ -u FILE ]" "suid bit set"
  bpPrintDesc "[ FILE1 -nt FILE2 ]" "1 is more recent than 2"
  bpPrintDesc "[ FILE1 -ot FILE2 ]" "2 is more recent than 1"
  bpPrintDesc "[ FILE1 -ef FILE2 ]" "Same files"

  bpPrintLine "Redirect/pipe"
  bpPrintDesc '> FILE' "stdout to FILE"
  bpPrintDesc '2> FILE' "stderr to FILE"
  bpPrintDesc '&> FILE' "stdout and stderr to FILE"
  bpPrintDesc '1> FILE1 2> FILE2' "stdout/stderr to separate files"
  bpPrintDesc '2>&1' "stderr to stdout"
  bpPrintDesc '>> FILE' "append to FILE"
  bpPrintDesc '>| FILE' "overwrite FILE"
  bpPrintDesc '&> /dev/null' "stdout and stderr to /dev/null"

  bpPrintDesc 'cmd1 | cmd2' "Pipe output from cmd1 to cmd2"
  bpPrintDesc '< FILE' "Pipe file to command"
  bpPrintDesc '<<< VAR' "Pipe variable to command"

  bpPrintLine "Parameter basics"
  bpPrintDesc 'STR="ABCD"    # "ABCD"' "Assign value"
  bpPrintDesc 'STR="${STR}E" # "ABCDE"' "Append char(s)"
  bpPrintDesc '${#STR}       # 5' "Determin length"
  bpPrintDesc 'POINTER="STR"' ""
  bpPrintDesc '${!POINTER}   # "ABCDE"' "Pointer to parameter"
  bpPrintDesc 'local STR' "Make variable access restricted to curly bracket area"
  bpPrintDesc 'export STR' "Make variable available to shell and sub-processes"

  bpPrintLine 'Parameter default values'
  bpPrintDesc '${STR:-val}' '$STR, or val if STR is unset'
  bpPrintDesc '${STR:=val}' 'set $STR to val if unset'
  bpPrintDesc '${STR:?message}' 'Show error message and exit if $STR is unset (or null)'

  bpPrintLine 'Parameter slicing'
  bpPrintDesc '${STR:index:length}' ""
  bpPrintLine
  bpPrintDesc '${STR:1}      # "BCDE"' ""
  bpPrintDesc '${STR:2}      # "CDE"' ""
  bpPrintDesc '${STR::-1}    # "ABCD"' ""
  bpPrintDesc '${STR::-2}    # "ABC"' ""
  bpPrintDesc '${STR:1:-1}   # "BCD"' ""

  bpPrintDesc '${STR::1}     # "A"' "First char"
  bpPrintDesc '${STR::2}     # "AB"' "First chars"
  bpPrintDesc '${STR: -1}    # "E"' "Last char"
  bpPrintDesc '${STR: -2}    # "DE"' "Last chars"

  bpPrintDesc '${STR:,,}     # "abcde"' "To lowercase"
  bpPrintDesc '${STR:^^}     # "ABCDE"' "To uppercase"

  bpPrintLine 'Parameter substitution'
  bpPrintDesc '${STR%suffix}' "Remove suffix"
  bpPrintDesc '${STR#prefix}' "Remove prefix"
  bpPrintDesc '${STR%%suffix}' "Remove long suffix"
  bpPrintDesc '${STR##prefix}' "Remove long prefix"
  bpPrintDesc '${STR/from/to}' "Replace first match"
  bpPrintDesc '${STR//from/to}' "Replace all"
  bpPrintDesc '${STR/%from/to}' "Replace suffix"
  bpPrintDesc '${STR/#from/to}' "Replace prefix"

  #bpPrintLine "\e]8;;https://tiswww.case.edu/php/chet/bash/bashref.html#Special-Parameters\aSpecial parameters\e]8;;\a"
  bpPrintLine "Special parameters"
  bpPrintDesc '$#' "Number of arguments"
  bpPrintDesc '$*' "All arguments"
  bpPrintDesc '$@' "All arguments, starting from first"
  bpPrintDesc '$1' "First argument"
  bpPrintDesc '$?' "Exit status of last task"
  bpPrintDesc '$-' "Current option flags"
  bpPrintDesc '$!' "PID of last background task"
  bpPrintDesc '$$' "PID of shell"
  bpPrintDesc '$_' "Last argument of the previous command"

  bpPrintLine "Array assigning"
  bpPrintDesc "Array=('A' 'B' 'C')" "Assign direct"
  bpPrintLine
  bpPrintDesc 'LS="A B C"' "Assign via read"
  bpPrintDesc 'read -r -a Array <<< $LS' ""
  bpPrintLine
  bpPrintDesc 'Array+=("D")' "Append element"

  bpPrintLine "Array operations"
  bpPrintDesc '${Array[n]}' "Element n"
  bpPrintDesc '${Array[-1]}' "Last element"
  bpPrintDesc '${Array[-2]}' "Second to last element"
  bpPrintDesc '${Array[@]}    # A B C D' "All elements"
  bpPrintDesc '${Array[@]:1}  # B C D' "All but first element"
  bpPrintDesc '${Array[@]:2}  # C D' "All but two first elements"
  bpPrintDesc '${Array[@]::1} # A' "First element"
  bpPrintDesc '${Array[@]::2} # A B' "Two first elements"
  bpPrintDesc '${#Array[@]}' "Nr of elements"
  bpPrintDesc '${#Array[n]}' "String lenght of nth element"
  bpPrintDesc '${Array[@]:3:2}' "Range (from pos 3, length 2)"
  bpPrintDesc '${!Array[@]}   # 0 1 2 3' "Keys of all elements"

  bpPrintLine
}

cse() { ##D List BASH exit codes
  BP_LINE_CHAR=""
  BP_KEY_LENGTH="4"

  if [ "$BP_COLUMNS" -ge 200 ]; then
    BP_COLUMNS=$(("$BP_COLUMNS" / 4 - 1))
    cs-exit-codes | "${BP_SELF_DIR}"/dev/columnize.py --columns 4
    return
  fi

  if [ "$BP_COLUMNS" -ge 150 ]; then
    BP_COLUMNS=$(("$BP_COLUMNS" / 3 - 1))
    cs-exit-codes | "${BP_SELF_DIR}"/dev/columnize.py --columns 3
    return
  fi

  if [ "$BP_COLUMNS" -ge 100 ]; then
    BP_COLUMNS=$(("$BP_COLUMNS" / 2 - 1))
    cs-exit-codes | "${BP_SELF_DIR}"/dev/columnize.py --columns 2
    return

  fi
  cs-exit-codes
}

cs-exit-codes() {
  # https://tiswww.case.edu/php/chet/bash/bashref.html#Exit-Status
  # <https://www.redhat.com/sysadmin/exit-codes-demystified>
  # <https://www.tldp.org/LDP/abs/html/exitcodes.html>

  #bpPrintLine "Bash exit codes"
  bpPrintDesc "0" "Success"
  bpPrintDesc "1" "Operation not permitted"
  bpPrintDesc "2" "No such file or directory"
  bpPrintDesc "3" "No such process"
  bpPrintDesc "4" "Interrupted system call"
  bpPrintDesc "5" "Input/output error"
  bpPrintDesc "6" "No such device or address"
  bpPrintDesc "7" "Argument list too long"
  bpPrintDesc "8" "Exec format error"
  bpPrintDesc "9" "Bad file descriptor"
  bpPrintDesc "10" "No child processes"
  bpPrintDesc "11" "Resource temporarily unavailable"
  bpPrintDesc "12" "Cannot allocate memory"
  bpPrintDesc "13" "Permission denied"
  bpPrintDesc "14" "Bad address"
  bpPrintDesc "15" "Block device required"
  bpPrintDesc "16" "Device or resource busy"
  bpPrintDesc "17" "File exists"
  bpPrintDesc "18" "Invalid cross-device link"
  bpPrintDesc "19" "No such device"
  bpPrintDesc "20" "Not a directory"
  bpPrintDesc "21" "Is a directory"
  bpPrintDesc "22" "Invalid argument"
  bpPrintDesc "23" "Too many open files in system"
  bpPrintDesc "24" "Too many open files"
  bpPrintDesc "25" "Inappropriate ioctl for device"
  bpPrintDesc "26" "Text file busy"
  bpPrintDesc "27" "File too large"
  bpPrintDesc "28" "No space left on device"
  bpPrintDesc "29" "Illegal seek"
  bpPrintDesc "30" "Read-only file system"
  bpPrintDesc "31" "Too many links"
  bpPrintDesc "32" "Broken pipe"
  bpPrintDesc "33" "Numerical argument out of domain"
  bpPrintDesc "34" "Numerical result out of range"
  bpPrintDesc "35" "Resource deadlock avoided"
  bpPrintDesc "36" "File name too long"
  bpPrintDesc "37" "No locks available"
  bpPrintDesc "38" "Function not implemented"
  bpPrintDesc "39" "Directory not empty"
  bpPrintDesc "40" "Too many levels of symbolic links"
  bpPrintDesc "42" "No message of desired type"
  bpPrintDesc "43" "Identifier removed"
  bpPrintDesc "44" "Channel number out of range"
  bpPrintDesc "45" "Level 2 not synchronized"
  bpPrintDesc "46" "Level 3 halted"
  bpPrintDesc "47" "Level 3 reset"
  bpPrintDesc "48" "Link number out of range"
  bpPrintDesc "49" "Protocol driver not attached"
  bpPrintDesc "50" "No CSI structure available"
  bpPrintDesc "51" "Level 2 halted"
  bpPrintDesc "52" "Invalid exchange"
  bpPrintDesc "53" "Invalid request descriptor"
  bpPrintDesc "54" "Exchange full"
  bpPrintDesc "55" "No anode"
  bpPrintDesc "56" "Invalid request code"
  bpPrintDesc "57" "Invalid slot"
  bpPrintDesc "59" "Bad font file format"
  bpPrintDesc "60" "Device not a stream"
  bpPrintDesc "61" "No data available"
  bpPrintDesc "62" "Timer expired"
  bpPrintDesc "63" "Out of streams resources"
  bpPrintDesc "64" "Machine is not on the network"
  bpPrintDesc "65" "Package not installed"
  bpPrintDesc "66" "Object is remote"
  bpPrintDesc "67" "Link has been severed"
  bpPrintDesc "68" "Advertise error"
  bpPrintDesc "69" "Srmount error"
  bpPrintDesc "70" "Communication error on send"
  bpPrintDesc "71" "Protocol error"
  bpPrintDesc "72" "Multihop attempted"
  bpPrintDesc "73" "RFS specific error"
  bpPrintDesc "74" "Bad message"
  bpPrintDesc "75" "Value too large for defined data type"
  bpPrintDesc "76" "Name not unique on network"
  bpPrintDesc "77" "File descriptor in bad state"
  bpPrintDesc "78" "Remote address changed"
  bpPrintDesc "79" "Can not access a needed shared library"
  bpPrintDesc "80" "Accessing a corrupted shared library"
  bpPrintDesc "81" ".lib section in a.out corrupted"
  bpPrintDesc "82" "Attempting to link in too many shared libraries"
  bpPrintDesc "83" "Cannot exec a shared library directly"
  bpPrintDesc "84" "Invalid or incomplete multibyte or wide character"
  bpPrintDesc "85" "Interrupted system call should be restarted"
  bpPrintDesc "86" "Streams pipe error"
  bpPrintDesc "87" "Too many users"
  bpPrintDesc "88" "Socket operation on non-socket"
  bpPrintDesc "89" "Destination address required"
  bpPrintDesc "90" "Message too long"
  bpPrintDesc "91" "Protocol wrong type for socket"
  bpPrintDesc "92" "Protocol not available"
  bpPrintDesc "93" "Protocol not supported"
  bpPrintDesc "94" "Socket type not supported"
  bpPrintDesc "95" "Operation not supported"
  bpPrintDesc "96" "Protocol family not supported"
  bpPrintDesc "97" "Address family not supported by protocol"
  bpPrintDesc "98" "Address already in use"
  bpPrintDesc "99" "Cannot assign requested address"
  bpPrintDesc "100" "Network is down"
  bpPrintDesc "101" "Network is unreachable"
  bpPrintDesc "102" "Network dropped connection on reset"
  bpPrintDesc "103" "Software caused connection abort"
  bpPrintDesc "104" "Connection reset by peer"
  bpPrintDesc "105" "No buffer space available"
  bpPrintDesc "106" "Transport endpoint is already connected"
  bpPrintDesc "107" "Transport endpoint is not connected"
  bpPrintDesc "108" "Cannot send after transport endpoint shutdown"
  bpPrintDesc "109" "Too many references"
  bpPrintDesc "110" "Connection timed out"
  bpPrintDesc "111" "Connection refused"
  bpPrintDesc "112" "Host is down"
  bpPrintDesc "113" "No route to host"
  bpPrintDesc "114" "Operation already in progress"
  bpPrintDesc "115" "Operation now in progress"
  bpPrintDesc "116" "Stale file handle"
  bpPrintDesc "117" "Structure needs cleaning"
  bpPrintDesc "118" "Not a XENIX named type file"
  bpPrintDesc "119" "No XENIX semaphores available"
  bpPrintDesc "120" "Is a named type file"
  bpPrintDesc "121" "Remote I/O error"
  bpPrintDesc "122" "Disk quota exceeded"
  bpPrintDesc "123" "No medium found"
  bpPrintDesc "125" "Operation canceled"
  bpPrintDesc "126" "Required key not available"
  bpPrintDesc "127" "Key has expired"
  bpPrintDesc "128" "Key has been revoked"
  bpPrintDesc "129" "Key was rejected by service"
  bpPrintDesc "130" "Owner died"
  bpPrintDesc "131" "State not recoverable"
  bpPrintDesc "132" "Operation not possible due to RF-kill"
  bpPrintDesc "133" "Memory page has hardware error"
  #bpPrintLine
}

csv() { ##C BP_DEV List BASH internal variables
  # https://www.gnu.org/software/bash/manual/html_node/Bash-Variables.html
  # https://tldp.org/LDP/abs/html/internalvariables.html

  BP_LINE_CHAR=""
  BP_KEY_LENGTH="10"

  if [ "$BP_COLUMNS" -ge 200 ]; then
    BP_COLUMNS=$(("$BP_COLUMNS" / 3 - 1))
    cs-variables | "${BP_SELF_DIR}"/dev/columnize.py --columns 3
    return
  fi

  if ((BP_COLUMNS > 150)); then
    BP_COLUMNS=$(("$BP_COLUMNS" / 2 - 1))
    cs-variables | "${BP_SELF_DIR}"/dev/columnize.py --columns 2
    return
  fi
  cs-variables
}
#shellcheck disable=2016
bash_variables=(
  "" "BASH" "Full pathname to current instance of Bash"
  "" "BASHOPTS" "A colon-separated list of enabled shell options"
  "" "BASHPID" "Process ID of the current instance of Bash"
  "" "BASH_ALIASES[]" "Array variable storing aliases"
  "" "BASH_ARGC" "Number of arguments passed to a function"
  "" "BASH_ARGV[]" "Array of function arguments"
  "" "BASH_ARGV0" "Name of the shell or shell script"
  "" "BASH_CMDS[]" "Array of internal commands"
  "" "BASH_COMMAND" "Command currently executing"
  "" "BASH_COMPAT" "Compatibility level"
  "" "BASH_ENV" "Filename of startup file"
  "" "BASH_EXECUTION_STRING" "The command argument to the -c invocation option"
  "" "BASH_LINENO[]" "Array variable storing the line number in the source file at which each element of FUNCNAME was invoked"
  "" "BASH_LOADABLES_PATH" "Colon-separated list of directories in which the shell looks for loadable builtins"
  "" "BASH_REMATCH" "Array variable created by the [[ ... ]] binary operator"
  "" "BASH_SOURCE[]" "Filename of the source of the current function"
  "" "BASH_SUBSHELL" "Incremented by one each time a subshell or subshell environment is spawned"
  "" "BASH_VERSINFO[]" "Array variable storing version information"
  "" "BASH_VERSION" "Version of Bash"
  "" "BASH_XTRACEFD" "File descriptor for xtrace output"
  "" "CHILD_MAX" "Maximum number of child processes"
  "" "COLUMNS" "Number of columns in the terminal"
  "" "COMP_CWORD" "Index of the current word"
  "" "COMP_LINE" "Current command line"
  "" "COMP_POINT" "Index of the current cursor position"
  "" "COMP_TYPE" "Type of completion attempted"
  "" "COMP_KEY" "The key (or final key of a key sequence) used to invoke the current completion function"
  "" "COMP_WORDBREAKS" "Characters that the readline library treats as word separators"
  "" "COMP_WORDS[]" "Array variable storing individual words in the current command line"
  "" "COMREPLY[]" "Array variable to be used for possible completions"
  "" "COPROC[]" "Array variable created to hold the file descriptors for coprocesses"
  "" "DIRSTACK[]" "Array variable containing the current contents of the directory stack"
  "" "EMACS" "Non-empty if Bash is running in an Emacs shell buffer"
  "" "ENV" "Filename of startup file"
  "" "EPOCHREALTIME" ""
  "" "EPOCHSECONDS" ""
  "" "EUID" "Effective user ID of the current user"
  "" "EXECIGNORE" "Pattern for commands to ignore"
  "" "FCEDIT" "Editor used by fc"
  "" "FIGNORE" "Pattern for file names to ignore"
  "" "FUNCNAME[]" "Array of functionnames on call stack"
  "" "FUNCNEST" "Function nesting level"
  "" "GLOBIGNORE" "Pattern describing files to ignore during pathname expansion"
  "" "GROUPS[]" "Array of groups to which the current user belongs"
  "" "HOME" "Home directory of the current user"
  "" "histchars" "Characters used to control history expansion"
  "" "HISTCMD" "History number of current command"
  "" "HISTCONTROL" "Controls how commands are saved on the history list"
  "" "HISTFILE" "File name in which command history is saved"
  "" "HISTFILESIZE" "Maximum number of lines contained in the history file"
  "" "HISTIGNORE" "Pattern specifying commands to ignore"
  "" "HISTSIZE" "Maximum number of commands to remember"
  "" "HISTTIMEFORMAT" "Format of timestamps in history file"
  "" "HOSTFILE" "File containing names of hosts for which to remember the directory stack"
  "" "HOSTNAME" "The name of the current host"
  "" "HOSTTYPE" "A string describing the machine Bash is running on"
  "" "IFS" "Internal field separator"
  "" "IGNOREEOF" "Number of EOF characters to ignore before logging out"
  "" "INPUTRC" "Readline initialization file"
  "" "INSIDE_EMACS" "Non-empty if Bash is running in an Emacs shell buffer"
  "" "LANG" "Default locale setting for all categories not specifically set"
  "" "LC_ALL" "Overrides individual LC_* settings"
  "" "LC_COLLATE" "Collation order"
  "" "LC_CTYPE" "Character classification and case conversion"
  "" "LC_MESSAGES" "Language for messages"
  "" "LC_NUMERIC" "Formatting of non-monetary numeric values"
  "" "LC_TIME" "Formatting of date and time values"
  "" "LINENO" "Line number currently executing"
  "" "LINES" "Number of lines on the terminal"
  "" "MACHTYPE" "A string describing the system type Bash is running on"
  "" "MAILCHECK" "How often to check for mail"
  "" "MAPFILE[]" "An array variable created to hold the text read by the mapfile builtin"
  "" "OLDPWD" "The previous working directory as set by the cd builtin"
  "" "OPTERR" "If set to the value 1, Bash displays error messages generated by the getopts builtin command"
  "" "OSTYPE" "A string describing the operating system Bash is running on"
  "" "PIPETYPE" "The file descriptor used for the coprocess"
  "" "POSIXLY_CORRECT" "If this variable is in the environment when Bash starts, the shell enters POSIX mode"
  "" "PPID" "The process ID of the shell’s parent process"
  "" "PROMPT_COMMAND" "Command to execute before displaying the primary prompt"
  "" "PROMPT_DIRTRIM" "Number of trailing directory components to retain when expanding the \w and \W prompt string escapes"
  "" "PS0" "The value of this parameter is expanded like PS1 and displayed by interactive shells after reading a command and before the command is executed"
  "" "PS1" "Primary prompt string"
  "" "PS2" "Secondary prompt string"
  "" "PS3" "Prompt string for select command"
  "" "PWD" "The current working directory as set by the cd builtin"
  "" "RANDOM" "Random number between 0 and 32767"
  "" "READLINE_ARGUMENT" ""
  "" "READLINE_LINE" "The current Readline line buffer"
  "" "READLINE_MARK" "The position of the mark in the Readline line buffer"
  "" "READLINE_POINT" "The current position of the cursor in the Readline line buffer"
  "" "REPLY" "The default variable for the read builtin"
  "" "SECONDS" "Number of seconds since the shell was started"
  "" "SHELL" "The full pathname to the shell"
  "" "SHELLOPTS" "A colon-separated list of enabled shell options"
  "" "SHLVL" "Incremented by one each time a new instance of Bash is started"
  "" "SRANDOM" "Seed for the RANDOM variable"
  "" "TIMEFORMAT" "Format string for the time command"
  "" "TMOUT" "The default timeout for the read builtin"
  "" "TMPDIR" "Directory for temporary files"
  "" "UID" "The user ID of the current user"
  "H" "Positional parameters" ""
  "" '$0, $1, $2, etc' ""
  "" '$#' "Number of positional parameters"
  "" '$*' "All positional parameters"
  "" '$@' "All positional parameters, starting from one"
  "H" "Other special parameters" ""
  "" '$-' "Flags passed to the shell"
  "" '$!' "PID of the last background command"
  "" '$_' "Last argument of the previous command"
  "" '$?' "Exit status of the last command"
  "" '$$' "PID of the current shell"
)

cs-variables() {
  # https://devhints.io/bash
  # https://www.gnu.org/software/bash/manual/html_node/Bash-Variables.html
  BP_KEY_LENGTH="22"
  bpPrintLine "BASH variables"
  i=0
  LEN=$((${#bash_variables[@]}))
  while [ "$i" -lt "$LEN" ]; do
    flags=${bash_variables[$i]}
    ((i++))
    var=${bash_variables[$i]}
    ((i++))
    desc=${bash_variables[$i]}
    ((i++))
    if [ "$flags" == "H" ]; then
      bpPrintLine "$var"
    else
      bpPrintDesc "${var}" "${desc}"
    fi
  done
}

csk() { ##C BP_DEV List BASH builtin keywords
  # https://www.gnu.org/software/bash/manual/html_node/Bash-Builtins.html
  # compgen -b
  # compgen -k

  BP_LINE_CHAR=""
  BP_KEY_LENGTH="10"

  if [ "$BP_COLUMNS" -ge 200 ]; then
    BP_COLUMNS=$(("$BP_COLUMNS" / 4 - 1))
    print-keywords | "${BP_SELF_DIR}"/dev/columnize.py --columns 4
    return
  fi

  if ((BP_COLUMNS > 150)); then
    BP_COLUMNS=$(("$BP_COLUMNS" / 3 - 1))
    print-keywords | "${BP_SELF_DIR}"/dev/columnize.py --columns 3
    return
  fi

  if ((BP_COLUMNS > 100)); then
    BP_COLUMNS=$(("$BP_COLUMNS" / 2 - 1))
    print-keywords | "${BP_SELF_DIR}"/dev/columnize.py --columns 2
    return
  fi
  print-keywords
}

print-keywords() {
  # compgen -b
  bpPrintDesc "if"
  bpPrintDesc "then"
  bpPrintDesc "else"
  bpPrintDesc "elif"
  bpPrintDesc "fi"
  bpPrintDesc "case"
  bpPrintDesc "esac"
  bpPrintDesc "for"
  bpPrintDesc "select" "Select words from a list and execute commands"
  bpPrintDesc "while"
  bpPrintDesc "until" "Execute commands as long as a test does not succeed"
  bpPrintDesc "do"
  bpPrintDesc "done"
  bpPrintDesc "in"
  bpPrintDesc "function" "Define shell function"
  bpPrintDesc "time" "Report time consumed by pipeline's execution"
  bpPrintDesc "{"
  bpPrintDesc "}"
  bpPrintDesc "!"
  bpPrintDesc "[["
  bpPrintDesc "]]"
  bpPrintDesc "coproc" "Create a coprocess"

  # compgen -k
  bpPrintDesc "." "Execute commands from a file in the current shell"
  bpPrintDesc ":"
  bpPrintDesc "["
  bpPrintDesc "alias" "Define or display aliases"
  bpPrintDesc "bg" "Move jobs to the background"
  bpPrintDesc "bind" "Set Readline key bindings and variables"
  bpPrintDesc "break" "Exit for, while, or until loops"
  bpPrintDesc "builtin" "Execute shell builtins"
  bpPrintDesc "caller" "Return the context of the current subroutine call"
  bpPrintDesc "cd" "Change the shell working directory"
  bpPrintDesc "command" "Execute a simple command or display information about commands"
  bpPrintDesc "compgen" "Display possible completions depending on the options"
  bpPrintDesc "complete" "Specify how arguments are to be completed by Readline"
  bpPrintDesc "compopt" "Modify or display completion options"
  bpPrintDesc "continue" "Resume for, while, or until loops"
  bpPrintDesc "declare" "Set variable values and attributes"
  bpPrintDesc "dirs" "Display directory stack"
  bpPrintDesc "disown" "Remove jobs from current shell"
  bpPrintDesc "echo" "Write arguments to the standard output"
  bpPrintDesc "enable" "Enable and disable shell builtins"
  bpPrintDesc "eval" "Evaluate arithmetic expressions"
  bpPrintDesc "exec" "Replace the shell with the given command"
  bpPrintDesc "exit" "Exit the shell"
  bpPrintDesc "export" "Set export attribute for shell variables"
  bpPrintDesc "false" "Return an unsuccessful result"
  bpPrintDesc "fc" "Display or execute commands from the history list"
  bpPrintDesc "fg" "Move job to the foreground"
  bpPrintDesc "getopts" "Parse option arguments"
  bpPrintDesc "hash" "Remember or display program locations"
  bpPrintDesc "help" "Display information about builtin commands"
  bpPrintDesc "history" "Display or manipulate the history list"
  bpPrintDesc "jobs" "Display status of jobs"
  bpPrintDesc "kill" "Send a signal to a job"
  bpPrintDesc "let" "Evaluate arithmetic expressions"
  bpPrintDesc "local" "Define local variable"
  bpPrintDesc "logout" "Exit a login shell"
  bpPrintDesc "mapfile" "Read lines from the standard input into an indexed array variable"
  bpPrintDesc "popd" "Remove directories from stack"
  bpPrintDesc "printf" "Formatted text output(C-style)"
  bpPrintDesc "pushd" "Add directories to stack"
  bpPrintDesc "pwd" "Print the name of the current working directory"
  bpPrintDesc "read" "Read a line from the standard input and split it into fields"
  bpPrintDesc "readarray" "Read lines from a file into an array variable"
  bpPrintDesc "readonly" "Mark shell variable as unchangable"
  bpPrintDesc "return" "Return from a shell function"
  bpPrintDesc "set" "Set or unset values of shell options and positional parameters"
  bpPrintDesc "shift" "Shift positional parameters"
  bpPrintDesc "shopt" "Set and unset shell options"
  bpPrintDesc "source" "Execute commands from a file in the current shell"
  bpPrintDesc "suspend" "Suspend shell execution"
  bpPrintDesc "test" "Evaluate conditional expression"
  bpPrintDesc "times" "Display process times"
  bpPrintDesc "trap" "Trap signals and other events"
  bpPrintDesc "true" "Return a successful result"
  bpPrintDesc "type" "Display information about command type"
  bpPrintDesc "typeset" "Set variable values and attributes"
  bpPrintDesc "ulimit" "Modify shell resource limits"
  bpPrintDesc "umask" "Display or set file mode mask"
  bpPrintDesc "unalias" "Remove each NAME from the list of defined aliases"
  bpPrintDesc "unset" "Unset values and attributes of shell variables and functions"
  bpPrintDesc "wait" "Wait for job completion and return exit status"
}

printChar() {
  printf " ${BP_C_FILENAME}%3s  ${E_GREEN}%3s  ${E_MAGENTA}%-8s  ${E_RED}%-4s ${E_YELLOW}%-3s  ${BP_C_DESCRIPTION}%s${E_RESET}\n" "$1" "$2" "$3" "$4" "$5" "$6"
}

ascii() { ##D Print Ascii table
  BP_LINE_CHAR=""
  #BP_KEY_LENGTH="6"

  # if ((BP_COLUMNS > 232)); then
  #   BP_COLUMNS=$(("$BP_COLUMNS" / 4 - 1))
  #   print-ascii | "${BP_SELF_DIR}"/dev/columnize.py --columns 4
  #   return
  # fi

  if ((BP_COLUMNS > 174)); then
    BP_COLUMNS=$(("$BP_COLUMNS" / 3 - 1))
    print-ascii | "${BP_SELF_DIR}"/dev/columnize.py --columns 3
    return
  fi

  if ((BP_COLUMNS > 116)); then
    BP_COLUMNS=$(("$BP_COLUMNS" / 2 - 1))
    print-ascii | "${BP_SELF_DIR}"/dev/columnize.py --columns 2
    return
  fi

  print-ascii
}

asciie() { ##D Print extended Ascii table
  BP_LINE_CHAR=""

  if ((BP_COLUMNS > 174)); then
    BP_COLUMNS=$(("$BP_COLUMNS" / 3 - 1))
    print-asciie | "${BP_SELF_DIR}"/dev/columnize.py --columns 3
    return
  fi

  if ((BP_COLUMNS > 116)); then
    BP_COLUMNS=$(("$BP_COLUMNS" / 2 - 1))
    print-asciie | "${BP_SELF_DIR}"/dev/columnize.py --columns 2
    return
  fi

  print-asciie
}

print_ascii_header() {
  printChar "Dec" "Hex" "Bin" "Sym" "Esc" "Description"
}

print-ascii() {
  print_ascii_header
  print-table 0 127 "${asciiTable[@]}"
}

print-asciie() {
  print_ascii_header
  print-table 128 255 "${asciiTable[@]}"
}

print-table() {
  table=("${@:3}")
  LEN=$((($2 + 1) * (6)))
  i=$(($1 * 6))

  while [ "$i" -lt "$LEN" ]; do
    dec=${table[$i]}
    ((i++))
    hex=${table[$i]}
    ((i++))
    bin=${table[$i]}
    ((i++))
    symbol=${table[$i]}
    ((i++))
    escape=${table[$i]}
    ((i++))
    desc=${table[$i]}
    ((i++))
    printChar "$dec" "$hex" "$bin" "$symbol" "$escape" "$desc"
  done
}

asciiTable=(
  "0" "00" "00000000" "NUL" "\0" "Null character"
  "1" "01" "00000001" "SOH" "" "Start of Heading"
  "2" "02" "00000010" "STX" "" "Start of Text"
  "3" "03" "00000011" "ETX" "" "End of Text"
  "4" "04" "00000100" "EOT" "" "End of Transmission"
  "5" "05" "00000101" "ENQ" "" "Enquiry"
  "6" "06" "00000110" "ACK" "" "Acknowledge"
  "7" "07" "00000111" "BEL" "\a" "Bell, Alert"
  "8" "08" "00001000" "BS" "\b" "Backspace"
  "9" "09" "00001001" "HT" "\t" "Horizontal Tab"
  "10" "0A" "00001010" "LF" "\n" "Line Feed"
  "11" "0B" "00001011" "VT" "\v" "Vertical Tabulation"
  "12" "0C" "00001100" "FF" "\f" "Form Feed"
  "13" "0D" "00001101" "CR" "\r" "Carriage Return"
  "14" "0E" "00001110" "SO" "" "Shift Out"
  "15" "0F" "00001111" "SI" "" "Shift In"
  "16" "10" "00010000" "DLE" "" "Data Link Escape"
  "17" "11" "00010001" "DC1" "" "Device Control One (XON)"
  "18" "12" "00010010" "DC2" "" "Device Control Two"
  "19" "13" "00010011" "DC3" "" "Device Control Three (XOFF)"
  "20" "14" "00010100" "DC4" "" "Device Control Four"
  "21" "15" "00010101" "NAK" "" "Negative Acknowledge"
  "22" "16" "00010110" "SYN" "" "Synchronous Idle"
  "23" "17" "00010111" "ETB" "" "End of Transmission Block"
  "24" "18" "00011000" "CAN" "" "Cancel"
  "25" "19" "00011001" "EM" "" "End of medium"
  "26" "1A" "00011010" "SUB" "" "Substitute"
  "27" "1B" "00011011" "ESC" "\e" "Escape"
  "28" "1C" "00011100" "FS" "" "File Separator"
  "29" "1D" "00011101" "GS" "" "Group Separator"
  "30" "1E" "00011110" "RS" "" "Record Separator"
  "31" "1F" "00011111" "US" "" "Unit Separator"
  "32" "20" "00100000" "SP" "" "Space"
  "33" "21" "00100001" "!" "" "Exclamation mark"
  "34" "22" "00100010" '"' "" "Double quotes"
  "35" "23" "00100011" "#" "" "Number sign"
  "36" "24" "00100100" "$" "" "Dollar"
  "37" "25" "00100101" "%" "" "Per cent sign"
  "38" "26" "00100110" "&" "" "Ampersand"
  "39" "27" "00100111" "'" "" "Single quote"
  "40" "28" "00101000" "(" "" "Open parenthesis"
  "41" "29" "00101001" ")" "" "Close parenthesis"
  "42" "2A" "00101010" "*" "" "Asterisk"
  "43" "2B" "00101011" "+" "" "Plus"
  "44" "2C" "00101100" "," "" "Comma"
  "45" "2D" "00101101" "-" "" "Hyphen-minus"
  "46" "2E" "00101110" "." "" "Period, dot or full stop"
  "47" "2F" "00101111" "/" "" "Slash or divide"
  "48" "30" "00110000" "0" "" "Zero"
  "49" "31" "00110001" "1" "" "One"
  "50" "32" "00110010" "2" "" "Two"
  "51" "33" "00110011" "3" "" "Three"
  "52" "34" "00110100" "4" "" "Four"
  "53" "35" "00110101" "5" "" "Five"
  "54" "36" "00110110" "6" "" "Six"
  "55" "37" "00110111" "7" "" "Seven"
  "56" "38" "00111000" "8" "" "Eight"
  "57" "39" "00111001" "9" "" "Nine"
  "58" "3A" "00111010" ":" "" "Colon"
  "59" "3B" "00111011" ";" "" "Semicolon"
  "60" "3C" "00111100" "<" "" "Less than"
  "61" "3D" "00111101" "=" "" "Equals"
  "62" "3E" "00111110" ">" "" "Greater than"
  "63" "3F" "00111111" "?" "" "Question mark"
  "64" "40" "01000000" "@" "" "At sign"
  "65" "41" "01000001" "A" "" "Uppercase A"
  "66" "42" "01000010" "B" "" "Uppercase B"
  "67" "43" "01000011" "C" "" "Uppercase C"
  "68" "44" "01000100" "D" "" "Uppercase D"
  "69" "45" "01000101" "E" "" "Uppercase E"
  "70" "46" "01000110" "F" "" "Uppercase F"
  "71" "47" "01000111" "G" "" "Uppercase G"
  "72" "48" "01001000" "H" "" "Uppercase H"
  "73" "49" "01001001" "I" "" "Uppercase I"
  "74" "4A" "01001010" "J" "" "Uppercase J"
  "75" "4B" "01001011" "K" "" "Uppercase K"
  "76" "4C" "01001100" "L" "" "Uppercase L"
  "77" "4D" "01001101" "M" "" "Uppercase M"
  "78" "4E" "01001110" "N" "" "Uppercase N"
  "79" "4F" "01001111" "O" "" "Uppercase O"
  "80" "50" "01010000" "P" "" "Uppercase P"
  "81" "51" "01010001" "Q" "" "Uppercase Q"
  "82" "52" "01010010" "R" "" "Uppercase R"
  "83" "53" "01010011" "S" "" "Uppercase S"
  "84" "54" "01010100" "T" "" "Uppercase T"
  "85" "55" "01010101" "U" "" "Uppercase U"
  "86" "56" "01010110" "V" "" "Uppercase V"
  "87" "57" "01010111" "W" "" "Uppercase W"
  "88" "58" "01011000" "X" "" "Uppercase X"
  "89" "59" "01011001" "Y" "" "Uppercase Y"
  "90" "5A" "01011010" "Z" "" "Uppercase Z"
  "91" "5B" "01011011" "[" "" "Opening bracket"
  "92" "5C" "01011100" "\\" "" "Backslash"
  "93" "5D" "01011101" "]" "" "Closing bracket"
  "94" "5E" "01011110" "^" "" "Caret - circumflex"
  "95" "5F" "01011111" "_" "" "Underscore"
  "96" "60" "01100000" '´' "" " Grave accent"
  "97" "61" "01100001" "a" "" "Lowercase a"
  "98" "62" "01100010" "b" "" "Lowercase b"
  "99" "63" "01100011" "c" "" "Lowercase c"
  "100" "64" "01100100" "d" "" "Lowercase d"
  "101" "65" "01100101" "e" "" "Lowercase e"
  "102" "66" "01100110" "f" "" "Lowercase f"
  "103" "67" "01100111" "g" "" "Lowercase g"
  "104" "68" "01101000" "h" "" "Lowercase h"
  "105" "69" "01101001" "i" "" "Lowercase i"
  "106" "6A" "01101010" "j" "" "Lowercase j"
  "107" "6B" "01101011" "k" "" "Lowercase k"
  "108" "6C" "01101100" "l" "" "Lowercase l"
  "109" "6D" "01101101" "m" "" "Lowercase m"
  "110" "6E" "01101110" "n" "" "Lowercase n"
  "111" "6F" "01101111" "o" "" "Lowercase o"
  "112" "70" "01110000" "p" "" "Lowercase p"
  "113" "71" "01110001" "q" "" "Lowercase q"
  "114" "72" "01110010" "r" "" "Lowercase r"
  "115" "73" "01110011" "s" "" "Lowercase s"
  "116" "74" "01110100" "t" "" "Lowercase t"
  "117" "75" "01110101" "u" "" "Lowercase u"
  "118" "76" "01110110" "v" "" "Lowercase v"
  "119" "77" "01110111" "w" "" "Lowercase w"
  "120" "78" "01111000" "x" "" "Lowercase x"
  "121" "79" "01111001" "y" "" "Lowercase y"
  "122" "7A" "01111010" "z" "" "Lowercase z"
  "123" "7B" "01111011" '{' "" "Opening brace"
  "124" "7C" "01111100" '|' "" "Vertical bar"
  "125" "7D" "01111101" '}' "" "Closing brace"
  "126" "7E" "01111110" '~' "" "Equivalency sign - tilde"
  "127" "7F" "01111111" "DEL" "" "Delete"
  "128" "80" "10000000" "Ç" "" "Latin Capital Letter C With Cedilla"
  "129" "81" "10000001" "ü" "" "Latin Small Letter U With Diaeresis"
  "130" "82" "10000010" "é" "" "Latin Small Letter E With Acute"
  "131" "83" "10000011" "â" "" "Latin Small Letter A With Circumflex"
  "132" "84" "10000100" "ä" "" "Latin Small Letter A With Diaeresis"
  "133" "85" "10000101" "à" "" "Latin Small Letter A With Grave"
  "134" "86" "10000110" "å" "" "Latin Small Letter A With Ring Above"
  "135" "87" "10000111" "ç" "" "Latin Small Letter C With Cedilla"
  "136" "88" "10001000" "ê" "" "Latin Small Letter E With Circumflex"
  "137" "89" "10001001" "ë" "" "Latin Small Letter E With Diaeresis"
  "138" "8A" "10001010" "è" "" "Latin Small Letter E With Grave"
  "139" "8B" "10001011" "ï" "" "Latin Small Letter I With Diaeresis"
  "140" "8C" "10001100" "î" "" "Latin Small Letter I With Circumflex"
  "141" "8D" "10001101" "ì" "" "Latin Small Letter I With Grave"
  "142" "8E" "10001110" "Ä" "" "Latin Capital Letter A With Diaeresis"
  "143" "8F" "10001111" "Å" "" "Latin Capital Letter A With Ring Above"
  "144" "90" "10010000" "É" "" "Latin Capital Letter E With Acute"
  "145" "91" "10010001" "§" "" "Latin Small Letter Ae"
  "146" "92" "10010010" "Æ" "" "Latin Capital Letter Ae"
  "147" "93" "10010011" "ô" "" "Latin Small Letter O With Circumflex"
  "148" "94" "10010100" "ö" "" "Latin Small Letter O With Diaeresis"
  "149" "95" "10010101" "ò" "" "Latin Small Letter O With Grave"
  "150" "96" "10010110" "û" "" "Latin Small Letter U With Circumflex"
  "151" "97" "10010111" "ù" "" "Latin Small Letter U With Grave"
  "152" "98" "10011000" "ÿ" "" "Latin Small Letter Y With Diaeresis"
  "153" "99" "10011001" "Ö" "" "Latin Capital Letter O With Diaeresis"
  "154" "9A" "10011010" "Ü" "" "Latin Capital Letter U With Diaeresis"
  "155" "9B" "10011011" "¢" "" "Cent Sign"
  "156" "9C" "10011100" "£" "" "Pound Sign, Pound Sterling, Irish Punt, Lira Sign"
  "157" "9D" "10011101" "¥" "" "Yen Sign, Yuan Sign"
  "158" "9E" "10011110" "₧" "" "Peseta Sign"
  "159" "9F" "10011111" "ƒ" "" "Latin Small Letter F With Hook"
  "160" "A0" "10100000" "á" "" "Latin Small Letter A With Acute"
  "161" "A1" "10100001" "í" "" "Latin Small Letter I With Acute"
  "162" "A2" "10100010" "ó" "" "Latin Small Letter O With Acute"
  "163" "A3" "10100011" "ú" "" "Latin Small Letter U With Acute"
  "164" "A4" "10100100" "ñ" "" "Latin Small Letter N With Tilde"
  "165" "A5" "10100101" "Ñ" "" "Latin Capital Letter N With Tilde"
  "166" "A6" "10100110" "ª" "" "Feminine Ordinal Indicator"
  "167" "A7" "10100111" "º" "" "Masculine Ordinal Indicator"
  "168" "A8" "10101000" "¿" "" "Inverted Question Mark, Turned Question Mark"
  "169" "A9" "10101001" "⌐" "" "Reversed Not Sign, Beginning Of Line"
  "170" "AA" "10101010" "¬" "" "Not Sign, Angled Dash"
  "171" "AB" "10101011" "½" "" "Vulgar Fraction One Half"
  "172" "AC" "10101100" "¼" "" "Vulgar Fraction One Quarter"
  "173" "AD" "10101101" "¡" "" "Inverted Exclamation Mark"
  "174" "AE" "10101110" "«" "" "Left-Pointing Double Angle Quotation Mark"
  "175" "AF" "10101111" "»" "" "Right-Pointing Double Angle Quotation Mark"
  "176" "B0" "10110000" "░" "" "Light Shade"
  "177" "B1" "10110001" "▒" "" "Medium Shade, Speckles Fill, Dotted Fill"
  "178" "B2" "10110010" "▓" "" "Dark Shade"
  "179" "B3" "10110011" "│" "" "Box Drawings Light Vertical"
  "180" "B4" "10110100" "┤" "" "Box Drawings Light Vertical And Left"
  "181" "B5" "10110101" "╡" "" "Box Drawings Vertical Single And Left Double"
  "182" "B6" "10110110" "╢" "" "Box Drawings Vertical Double And Left Single"
  "183" "B7" "10110111" "╖" "" "Box Drawings Down Double And Left Single"
  "184" "B8" "10111000" "╕" "" "Box Drawings Down Single And Left Double"
  "185" "B9" "10111001" "╣" "" "Box Drawings Double Vertical And Left"
  "186" "BA" "10111010" "║" "" "Box Drawings Double Vertical"
  "187" "BB" "10111011" "╗" "" "Box Drawings Double Down And Left"
  "188" "BC" "10111100" "╝" "" "Box Drawings Double Up And Left"
  "189" "BD" "10111101" "╜" "" "Box Drawings Up Double And Left Single"
  "190" "BE" "10111110" "╛" "" "Box Drawings Up Single And Left Double"
  "191" "BF" "10111111" "┐" "" "Box Drawings Light Down And Left"
  "192" "C0" "11000000" "└" "" "Box Drawings Light Up And Right"
  "193" "C1" "11000001" "┴" "" "Box Drawings Light Up And Horizontal"
  "194" "C2" "11000010" "├" "" "Box Drawings Light Down And Horizontal"
  "195" "C3" "11000011" "├" "" "Box Drawings Light Vertical And Right"
  "196" "C4" "11000100" "─" "" "Box Drawings Light Horizontal"
  "197" "C5" "11000101" "┼" "" "Box Drawings Light Vertical And Horizontal"
  "198" "C6" "11000110" "╞" "" "Box Drawings Vertical Single And Right Double"
  "199" "C7" "11000111" "╟" "" "Box Drawings Vertical Double And Right Single"
  "200" "C8" "11001000" "╚" "" "Box Drawings Double Up And Right"
  "201" "C9" "11001001" "╔" "" "Box Drawings Double Down And Right"
  "202" "CA" "11001010" "╩" "" "Box Drawings Double Up And Horizontal"
  "203" "CB" "11001011" "╦" "" "Box Drawings Double Down And Horizontal"
  "204" "CC" "11001100" "╠" "" "Box Drawings Double Vertical And Right"
  "205" "CD" "11001101" "═" "" "Box Drawings Double Horizontal"
  "206" "CE" "11001110" "╬" "" "Box Drawings Double Vertical And Horizontal"
  "207" "CF" "11001111" "╧" "" "Box Drawings Up Single And Horizontal Double"
  "208" "D0" "11010000" "╨" "" "Box Drawings Up Double And Horizontal Single"
  "209" "D1" "11010001" "╤" "" "Box Drawings Down Single And Horizontal Double"
  "210" "D2" "11010010" "╥" "" "Box Drawings Down Double And Horizontal Single"
  "211" "D3" "11010011" "╙" "" "Box Drawings Up Double And Right Single"
  "212" "D4" "11010100" "╘" "" "Box Drawings Up Single And Right Double"
  "213" "D5" "11010101" "╒" "" "Box Drawings Down Single And Right Double"
  "214" "D6" "11010110" "╓" "" "Box Drawings Down Double And Right Single"
  "215" "D7" "11010111" "╫" "" "Box Drawings Vertical Double And Horizontal Single"
  "216" "D8" "11011000" "╪" "" "Box Drawings Vertical Single And Horizontal Double"
  "217" "D9" "11011001" "┘" "" "Box Drawings Light Up And Left"
  "218" "DA" "11011010" "┌" "" "Box Drawings Light Down And Right"
  "219" "DB" "11011011" "█" "" "Full Block, Solid Block"
  "220" "DC" "11011100" "▄" "" "Lower Half Block"
  "221" "DD" "11011101" "▌" "" "Left Half Block"
  "222" "DE" "11011110" "▐" "" "Right Half Block"
  "223" "DF" "11011111" "▀" "" "Upper Half Block"
  "224" "E0" "11100000" "α" "" "Greek Small Letter Alpha"
  "225" "E1" "11100001" "ß" "" "Latin Small Letter Sharp S, Eszett"
  "226" "E2" "11100010" "Γ" "" "Greek Capital Letter Gamma"
  "227" "E3" "11100011" "π" "" "Greek Small Letter Pi"
  "228" "E4" "11100100" "Σ" "" "Greek Capital Letter Sigma"
  "229" "E5" "11100101" "σ" "" "Greek Small Letter Sigma"
  "230" "E6" "11100110" "µ" "" "Micro Sign"
  "231" "E7" "11100111" "τ" "" "Greek Capital Letter Tau"
  "232" "E8" "11101000" "Φ" "" "Greek Capital Letter Phi"
  "233" "E9" "11101001" "Θ" "" "Greek Capital Letter Theta"
  "234" "EA" "11101010" "Ω" "" "Greek Capital Letter Omega"
  "235" "EB" "11101011" "δ" "" "Greek Small Letter Delta"
  "236" "EC" "11101100" "∞" "" "Infinity"
  "237" "ED" "11101101" "φ" "" "Greek Small Letter Phi"
  "238" "EE" "11101110" "ε" "" "Greek Small Letter Epsilon"
  "239" "EF" "11101111" "∩" "" "Intersection"
  "240" "F0" "11110000" "≡" "" "Identical To"
  "241" "F1" "11110001" "±" "" "Plus-Minus Sign"
  "242" "F2" "11110010" "≥" "" "Greater-Than Or Equal To"
  "243" "F3" "11110011" "≤" "" "Less-Than Or Equal To"
  "244" "F4" "11110100" "⌠" "" "Top Half Integral"
  "245" "F5" "11110101" "⌡" "" "Bottom Half Integral"
  "246" "F6" "11110110" "÷" "" "Division Sign, Obelus"
  "247" "F7" "11110111" "≈" "" "Almost Equal To, Asymptotic To"
  "248" "F8" "11111000" "°" "" "Degree Sign"
  "249" "F9" "11111001" "∙" "" "Bullet Operator"
  "250" "FA" "11111010" "·" "" "Middle Dot, Interpunct"
  "251" "FB" "11111011" "√" "" "Square Root, Radical Sign"
  "252" "FC" "11111100" "ⁿ" "" "Superscript Latin Small Letter N"
  "253" "FD" "11111101" "²" "" "Superscript Two, Squared"
  "254" "FE" "11111110" "■" "" "Black Square"
  "255" "FF" "11111111" " " "" "Non-Breaking Space, NBSP"
)

bp_phh() {
  if [ -z "${BP_INIT_RUN}" ]; then
    bpInfo "Make sure to do load bp_init ( source $(realpath bp_init) )"
    echo
  fi
}

##- Setup

bp_install() { ##D Install bashplates init
  bpAddModule "${BP_SELF_DIR}/bp_init"
}

#---------------------------------------------------------------------
# Bashplate settings
#---------------------------------------------------------------------
bpInitSettings() {

  ##V Script version info
  BP_VERSION="1.10"

  ##V Usage info
  BP_USAGE="Usage: ${BP_SELF_NAME} command [option]"

  ##V Description text
  BP_DESC="Generate bash scripts from templates"

  ##V logfile (uncomment to use logfile)
  BP_LOGFILE=${BP_SELF_DIR}/${BP_SELF_NAME}.log

  ##V Lock file (uncomment to use lock file feature )
  BP_LOCK_FILE=/tmp/${BP_SELF_NAME}.lock

  ##V Logging options (uncomment to activate logging parameters)
  BP_LOG_OK=1
  BP_LOG_INFO=1
  BP_LOG_WARNING=1
  BP_LOG_ERROR=1
  BP_LOG_CRITICAL=1

  ##V Activate settings function (will create settings file when run)
  BP_CONF=1

}
#---------------------------------------------------------------------
# Bashplate Hooks
#---------------------------------------------------------------------

##V Default command (uncomment to use a default command )
DEFAULT_CMD_HOOK=help

##V Pre script hook, execute this function before every command
#PRE_SCRIPT_HOOK=

##V Post script hook, execute this function after every command
#POST_SCRIPT_HOOK=

##V Function to be executed before every other cmd except DEFAULT function
#PRE_CMD_HOOK=

##V Function to be executed after every other function except DEFAULT function
#POST_CMD_HOOK=

##V Function to be executed after information command
#POST_INFO_HOOK=

##V Function run before help command is executed
PRE_HELP_HOOK=bp_phh

##V Function run after help command is executed
#POST_HELP_HOOK=

#---------------------------------------------------------------------
# Signal traps
#---------------------------------------------------------------------

signalInt() {
  bpCleanUp
  exit "$BP_OK"
}

signalHup() {
  bpCleanUp
  exit "$BP_OK"
}

signalQuit() {
  echo "Quit"
  bpCleanUp
}

signalTerm() {
  echo "Term"
  bpCleanUp
}

signalErr() {
  echo
  echo
  bpError "Trace error Row: $2  Function: $1"
  echo
  bpCallStack "$*"
  bpExit 1
}

signalDbg() {
  echo "Debug Row: $2  Function: $1"
}

##C- IHELP Exit and cleanup

bpCallStack() { ##I Print out BASH call stack
  bpPrintLine "Call stack"
  echo
  local frame=0
  while caller "$frame" | sed -r -e "s/[0-9]*/${BP_C_VALUE}&${E_RESET}/"; do
    ((frame++))
  done
  echo "$*"
  bpPrintLine
}

bpCleanUp() {             ##I Cleanup function
  rm -f "${BP_LOCK_FILE}" # remove Lock file
  #  echo -e "${E_SHOW}"     # Turn on cursor if turned of
}

#
# $1 exit code, if not given exit code is 0=SUCCESS
#
bpExit() { ##I Function for safely exiting script
  bpCleanUp

  # execute postscript hook if existing
  if [ -n "$POST_SCRIPT_HOOK" ]; then
    ${POST_SCRIPT_HOOK}
  fi

  # Check if argument is given
  if [ -z "$1" ]; then
    exit "$BP_OK"
  else
    exit "$1"
  fi
}

bpErrorExit() { ##I Safely exit script with a error
  bpError "${1}"
  bpCleanUp
  exit 1
}

#---------------------------------------------------------------------
# ANSI escape codes
#---------------------------------------------------------------------

# Check if terminal is 16 color only
if [[ "linux rxvt-16color" = *${TERM}* ]]; then

  # ANSI foreground colors codes
  #
  E_BLACK=$'\e[30m'        # Black
  E_RED=$'\e[31m'          # Red
  E_GREEN=$'\e[32m'        # Green
  E_YELLOW=$'\e[33m'       # Yellow
  E_BLUE=$'\e[34m'         # Blue
  E_MAGENTA=$'\e[35m'      # Magenta
  E_CYAN=$'\e[36m'         # Cyan
  E_WHITE=$'\e[37m'        # White
  E_GRAY=$'\e[1;30m'       # Gray
  E_BR_RED=$'\e[1;31m'     # Bright Red
  E_BR_GREEN=$'\e[1;32m'   # Bright Green
  E_BR_YELLOW=$'\e[1;33m'  # Bright Yellow
  E_BR_BLUE=$'\e[1;34m'    # Bright Blue
  E_BR_MAGENTA=$'\e[1;35m' # Bright Magenta
  E_BR_CYAN=$'\e[1;36m'    # Bright Cyan
  E_BR_WHITE=$'\e[1;37m'   # Bright White

  # ANSI background color codes
  #
  E_BG_BLACK=$'\e[40m'      # Black
  E_BG_RED=$'\e[41m'        # Red
  E_BG_GREEN=$'\e[42m'      # Green
  E_BG_YELLOW=$'\e[43m'     # Yellow
  E_BG_BLUE=$'\e[44m'       # Blue
  E_BG_MAGENTA=$'\e[45m'    # Magenta
  E_BG_CYAN=$'\e[46m'       # Cyan
  E_BG_WHITE=$'\e[47m'      # White
  E_BG_GRAY=$'\e[40m'       # Gray
  E_BG_BR_RED=$'\e[41m'     # Bright Red
  E_BG_BR_GREEN=$'\e[42m'   # Bright Green
  E_BG_BR_YELLOW=$'\e[43m'  # Bright Yellow
  E_BG_BR_BLUE=$'\e[44m'    # Bright Blue
  E_BG_BR_MAGENTA=$'\e[45m' # Bright Magenta
  E_BG_BR_CYAN=$'\e[46m'    # Bright Cyan
  E_BG_BR_WHITE=$'\e[47m'   # Bright White

else

  # ANSI foreground colors codes
  #
  E_BLACK=$'\e[38:5:0m'       # Black
  E_RED=$'\e[38:5:1m'         # Red
  E_GREEN=$'\e[38:5:2m'       # Green
  E_YELLOW=$'\e[38:5:3m'      # Yellow
  E_BLUE=$'\e[38:5:4m'        # Blue
  E_MAGENTA=$'\e[38:5:5m'     # Magenta
  E_CYAN=$'\e[38:5:6m'        # Cyan
  E_WHITE=$'\e[38:5:7m'       # White
  E_GRAY=$'\e[38:5:8m'        # Gray
  E_BR_RED=$'\e[38:5:9m'      # Bright Red
  E_BR_GREEN=$'\e[38:5:10m'   # Bright Green
  E_BR_YELLOW=$'\e[38:5:11m'  # Bright Yellow
  E_BR_BLUE=$'\e[38:5:12m'    # Bright Blue
  E_BR_MAGENTA=$'\e[38:5:13m' # Bright Magenta
  E_BR_CYAN=$'\e[38:5:14m'    # Bright Cyan
  E_BR_WHITE=$'\e[38:5:15m'   # Bright White

  # ANSI background color codes
  #
  E_BG_BLACK=$'\e[48;5;0m'       # Black
  E_BG_RED=$'\e[48;5;1m'         # Red
  E_BG_GREEN=$'\e[48;5;2m'       # Green
  E_BG_YELLOW=$'\e[48;5;3m'      # Yellow
  E_BG_BLUE=$'\e[48;5;4m'        # Blue
  E_BG_MAGENTA=$'\e[48;5;5m'     # Magenta
  E_BG_CYAN=$'\e[48;5;6m'        # Cyan
  E_BG_WHITE=$'\e[48;5;7m'       # White
  E_BG_GRAY=$'\e[48;5;8m'        # Gray
  E_BG_BR_RED=$'\e[48;5;9m'      # Bright Red
  E_BG_BR_GREEN=$'\e[48;5;10m'   # Bright Green
  E_BG_BR_YELLOW=$'\e[48;5;11m'  # Bright Yellow
  E_BG_BR_BLUE=$'\e[48;5;12m'    # Bright Blue
  E_BG_BR_MAGENTA=$'\e[48;5;13m' # Bright Magenta
  E_BG_BR_CYAN=$'\e[48;5;14m'    # Bright Cyan
  E_BG_BR_WHITE=$'\e[48;5;15m'   # Bright White
fi

E_DARKGRAY="$E_GRAY" ##V Debprecated colorname

# ANSI underline color codes
#
# Not in standard. implemented in Kitty, VTE, mintty, etc.
#
E_UL_BLACK=$'\e[58;5;0m'       # Black
E_UL_RED=$'\e[58;5;1m'         # Red
E_UL_GREEN=$'\e[58;5;2m'       # Green
E_UL_YELLOW=$'\e[58;5;3m'      # Yellow
E_UL_BLUE=$'\e[58;5;4m'        # Blue
E_UL_MAGENTA=$'\e[58;5;5m'     # Magenta
E_UL_CYAN=$'\e[58;5;6m'        # Cyan
E_UL_WHITE=$'\e[58;5;7m'       # White
E_UL_GRAY=$'\e[58;5;8m'        # Gray
E_UL_BR_RED=$'\e[58;5;9m'      # Bright Red
E_UL_BR_GREEN=$'\e[58;5;10m'   # Bright Green
E_UL_BR_YELLOW=$'\e[58;5;11m'  # Bright Yellow
E_UL_BR_BLUE=$'\e[58;5;12m'    # Bright Blue
E_UL_BR_MAGENTA=$'\e[58;5;13m' # Bright Magenta
E_UL_BR_CYAN=$'\e[58;5;14m'    # Bright Cyan
E_UL_BR_WHITE=$'\e[58;5;15m'   # White

# ANSI Text attributes
E_RESET=$'\e[0m'              # Clear all attributes
E_BOLD=$'\e[1m'               # Bold text
E_DIM=$'\e[2m'                # Dim(low intensity) text
E_ITALIC=$'\e[3m'             # Italic text
E_UNDERLINE=$'\e[4m'          # Underlined text
E_UNDERLINE_DOUBLE=$'\e[4:2m' # Double underline (limited support)
E_UNDERLINE_CURLY=$'\e[4:3m'  # Curly underline (limited support)
E_UNDERLINE_DOT=$'\e[4:4m'    # Dotted underline (limited support)
E_UNDERLINE_DASH=$'\e[4:5m'   # Dashed underline (limited support)
E_BLINK=$'\e[5m'              # Blinking text
E_RAPID_BLINK=$'\e[6m'        # Rapid blink (Limited support)
E_REVERSE=$'\e[7m'            # Reverse color
E_CROSSED=$'\e[9m'            # Crossed over text
E_FRAKTUR=$'\e[20m'           # Gothic (limited support)
E_FRAMED=$'\e[51m'            # Framed (limited support)
E_OVERLINED=$'\e[53m'         # Overlined text
E_SUPERSCRIPT=$'\e[73m'       # Superscript text (limited support)
E_SUBSCRIPT=$'\e[74m'         # Subscript text (limited support)

# ANSI cursor operations
#
E_RETURN=$'\e[F'  # Move cursor to begining of line
E_UP=$'\e[A'      # Move cursor one line up
E_DOWN=$'\e[B'    # Move cursor one line down
E_FORWARD=$'\e[C' # Move cursor forward
E_BACK=$'\e[D'    # Move cursor backward
E_HIDE=$'\e[?25l' # Hide cursor
E_SHOW=$'\e[?25h' # Show cursor

# Default Bashplate colortheme
BP_C_OK="${E_BR_GREEN}"
BP_C_INFO="${E_BR_CYAN}"
BP_C_DEBUG="${E_BG_GREEN}${E_WHITE}"
BP_C_WARNING="${E_BR_YELLOW}"
BP_C_ERROR="${E_BR_RED}"
BP_C_CRITICAL="${E_BG_RED}${E_WHITE}"
BP_C_LINE="${E_GRAY}"
BP_C_LINETEXT="${E_YELLOW}"
BP_C_DESCRIPTION="${E_CYAN}"
BP_C_KEY="${E_BR_MAGENTA}"

BP_C_FILENAME="${E_BR_CYAN}"
BP_C_PATH="${E_CYAN}"
BP_C_URL_SCHEME="${E_GRAY}"
# BP_C_URL_USER=""
# BP_C_URL_HOST=""
BP_C_TIME="${E_BR_MAGENTA}"
BP_C_DATE="${E_MAGENTA}"

BP_C_QUERY=$'\e[38;5;194m'
BP_C_QUERY_DEF=$'\e[38;5;240m'
BP_C_EMPHASIS=$'\e[38;5;255m'
BP_C_DEEMPHASIS=$'\e[38;5;250m'

# Shellscript colorize colors
BP_C_RESERVED="${E_RED}"
BP_C_COMMENT="${E_CYAN}"
BP_C_STRING="${E_GREEN}"
BP_C_VAR="${E_BR_YELLOW}"

# Separator line character
BP_LINE_CHAR="-"

# Exit codes
#
BP_OK=0 # successful termination

# Formating
#
BP_KEY_LENGTH=24
BP_LEFT_MARGIN=3
BP_RIGHT_MARGIN=3

#---------------------------------------------------------------------
# Bashplate internal functions
#---------------------------------------------------------------------

##C- IHELP Printing functions

#
# $1 text to be printed
# $2 text color
# $3 line color
# $4 middle character
#
bpPrintLineGeneric() { ##I Print text with adjusted line after with selectable colors
  len1="${#1}"
  len4="${#4}"

  echo -en "${2}${1}${4}${3}"
  if [ "${BP_LINE_CHAR}" != "" ]; then
    l=$((BP_COLUMNS - len1 - len4))
    seq -s"${BP_LINE_CHAR}" "${l}" | tr -d '[:digit:]'
    echo -en "${E_RESET}"
  else
    echo -e "${E_RESET}"
  fi
}

#
# $1 text to be printed
# $2 text color
# $3 line color
#
bpTextLineC() { ##I Print text with adjusted line after with selectable colors
  bpPrintLineGeneric "$1" "$2" "$3" " "
}

bpPrintLine() { ##I Print text with line
  if [ "${#1}" -eq 0 ]; then
    bpPrintLineGeneric "" "" "${BP_C_LINE}" ""
  else
    bpPrintLineGeneric "$1" "${BP_C_LINETEXT}" "${BP_C_LINE}" " "
  fi
}

#
# $1 key color
# $2 description color
# $3 key
# $4 description
# $5 key length override (optional)
#
bpPrintDescGeneric() { # Generic key/description printout function
  KEY_COLOR="$1"
  DESC_COLOR="$2"
  KEY="$3"
  DESC="$4"
  if [ -n "$5" ]; then
    KL="$5"
  else
    KL=${BP_KEY_LENGTH}
  fi

  if ((${#4} == 0)); then
    printf "${1}  %-${KL}.${KL}s${E_RESET} ${2}%s${E_RESET}\n" "$3" ""
  fi

  len=${#}
  a=$(("${BP_COLUMNS}" - "$KL" - "$BP_RIGHT_MARGIN"))
  #LINES=$(fmt -s -w"${a}" <<<"$4")
  LINES=$(fold -w"${a}" <<<"$DESC")

  IFS=$'\n'
  L1=0
  for line in ${LINES}; do
    if [ "${L1}" -eq 0 ]; then                # First line
      if ((${#KEY} > "$BP_KEY_LENGTH")); then # Oversized key
        printf "${KEY_COLOR}  %-${KL}s${E_RESET}\n" "$KEY"
        printf "${KEY_COLOR}  %-${KL}.${KL}s${E_RESET} ${DESC_COLOR}%s${E_RESET}\n" "" "$line"
      else # Normal key
        printf "${KEY_COLOR}  %-${KL}.${KL}s${E_RESET} ${DESC_COLOR}%s${E_RESET}\n" "$KEY" "$line"
      fi
      L1=1
    else # Rest of the lines
      printf "${KEY_COLOR}  %-${KL}.${KL}s${E_RESET} ${DESC_COLOR}%s${E_RESET}\n" "" "$line"
    fi
  done
}

#
# $1 key
# $2 description
# $3 (optional) left alignment
#
bpPrintDesc() { ##I Print key description
  bpPrintDescGeneric "${BP_C_KEY}" "${BP_C_DESCRIPTION}" "$1" "$2" "$3"
}

bpPrintDescAlt() {
  bpPrintDescGeneric "${E_GRAY}" "${BP_C_DESCRIPTION}" "$1" "$2"
}

#
# $1 variablename
# $2 alternative key text (optional)
# $3 alternative value text (optional)
#
bpPrintVar() { ##I Print variable value and description
  VAR="$1"

  if [ -n "$2" ]; then
    KEY=${2}
  else
    KEY="${VAR}"
  fi

  if [ "${!VAR}" ]; then
    if [ -n "$3" ]; then
      VAL=${3}
    else
      VAL="${!VAR}"
    fi

    bpPrintDesc "${KEY}" "${VAL}"
  else
    bpPrintDesc "${KEY}" "${BP_C_ERROR}N/A"
  fi
}

#
# Colorize string containing filename
#
# $1 string with filename to colorize
# ret colorized string
#
bpColorizeFile() { ##I Colorize string containing filename
  echo "${BP_C_PATH}$(dirname "$1")/${BP_C_FILENAME}$(basename "$1")${E_RESET}"
}

#
# $1 string with url to colorize
# ret colorized string
#
# todo: give username and port own color
#
bpColorizeUrl() { ##I Colorize string containing URL
  URL=$(sed -r -e "s/^.*\/\///" <<<"$1")
  SCHEME=$(sed -r -e "s/:\/.*//" <<<"$1")
  # USERNAME=$(sed -r -e "s/@.*//" <<<"$URL")
  # PORT=$(sed -r -e "s/^:[0-9]*/XXX/" <<<"$URL")
  # echo -e "Username: $USERNAME"
  # echo -e "Port: $PORT"

  #URL=$(echo -n "$1" | sed -r -e "s/^.*\/\///")
  #SCHEME=$(echo -n "$1" | sed -r -e "s/:\/.*//")

  echo -e -n "${BP_C_URL_SCHEME}${SCHEME}${E_RESET}://$(bpColorizeFile "${URL}")"
}

#
# $1 string to be filtered
#
bpFilterEscape() { ##I Filter escape characters from string
  echo "$1" | sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g"
}

##C- IHELP File operations

#
# $1 directory to change to
#
bpCd() { ##I Safe cd function (exits on fail)
  cd "$1" || bpExit "Failed to cd to [$1]"
}

#
# $1 Directory to be created
#
bpMkDir() { ##I Create a directory if it does not exist
  if [ ! -d "$1" ]; then
    if mkdir -p "$1"; then
      bpOk "Creating directory $(bpColorizeFile "${1}")."
      return 0
    else
      bpError "Failed to create directory $(bpColorizeFile "${1}")."
      return 1
    fi
  fi
}

#
# $1 target file/dir
# $2 link
#
bpLn() { ##I Create symbolic link
  if [ ! -L "$1" ]; then
    if ln -sf "${1}" "${2}"; then
      bpOk "Creating link $(bpColorizeFile "${2}")."
      return 0
    else
      bpError "Failed to create link $(bpColorizeFile "${2}")."
      return 1
    fi
  fi
}

#
# $1 file(s) to be copied
# $2 destination
#
bpCp() { ##I Copy file(s)
  if cp -rf "$@"; then
    bpOk "Copying $(bpColorizeFile "${1}") to $(bpColorizeFile "${2}")"
    return 0
  else
    bpError "Failed copying $(bpColorizeFile "${1}") to $(bpColorizeFile "${2}")"
    return 1
  fi
}

#
# $1 file(s) to be moved
# $2 destination
#
bpMv() { ##I Move file(s)
  if mv "$1" "$2"; then
    bpOk "Moving file $(bpColorizeFile "${1}") to $(bpColorizeFile "${2}")."
    return 0
  else
    bpError "Failed moving file $(bpColorizeFile "${1}") to $(bpColorizeFile "${2}")."
    return 1
  fi
}

#
# $1 file(s) to be removed
#
bpRm() { ##I Remove file(s)
  if rm -rf "${1}"; then
    bpOk "Removing file $(bpColorizeFile "${1}")."
    return 0
  else
    bpError "Failed removing file $(bpColorizeFile "${1}")."
    return 1
  fi
}

#
# $1 file to be backed up
#
bpBackup() { ##I Make backup of file
  BF="${1}_$(date +"%Y%m%d")-$(date +"%H%M%S").bak"

  if cp -rf "$1" "${BF}"; then
    bpOk "Backing up file $(bpColorizeFile "$1") to $(bpColorizeFile "${BF}")."
    return 0
  else
    bpError "Failed backing up file $(bpColorizeFile "$1") to $(bpColorizeFile "${BF}")."
    return 1
  fi
}

##C- IHELP File editing

#
# $1 file
# $2 text to replace
# $3 new text
#
bpReplace() { ##I Replace all ocurances of text in file
  sed -i -e "s/${2}/${3}/g" "$1"
}

#
# $1 file
# $2 pattern matching line
# $3 new text
#
bpReplaceLine() { ##I Replace entire line matching pattern
  sed -i -e "0,/${2}/s/${2}.*/${3}/" "${1}"
}

#
# $1 file
# $2 line to append
#
bpAppendIfNoSuchLine() { ##I Append a line if it does not exist in file
  grep -q -F "$2" "$1" || echo "$2" >>"$1"
}

#
# $1 file
# $2 string
#
bpRemoveLineContaining() { ##I Remove line in file if it contains given string
  grep -v "$2" "$1" >"${1}_tmp"
  mv -f "${1}_tmp" "${1}"
}

#
# $1 file
# $2 string
# return true if existing
#
bpStrExist() { ##I Check if string exist in file
  if [ ! -f "$1" ]; then
    return 1
  fi

  if grep -q -F "$2" "$1"; then
    return 0
  else
    return 1
  fi
}

#
# $1 file to open in editor
# $2 override editor (optional)
#
bpEdit() { ##I Open file in editor set by BP_EDIT variable

  if [ -n "$2" ]; then
    bpRun "$2" "$1"
    return 0
  fi

  if [ -n "$BP_EDITOR" ]; then
    bpRun "${BP_EDITOR}" "${1}"
  else
    bpError "BP_EDITOR variable not set, can't open file ${1}"
  fi
}

#
# $1 file
# $2 start marker
# $3 end marker
#
bpGetSection() { ##I Get text from file between two markers
  grep -A 10000 -m 1 "$2" <"$1" | grep -B 10000 -m 1 "$3" | grep -v "$2" | grep -v "$3"
}

#
# $1 File to import
#
bpImport() { ## Import file into variable
  if [ -f "$1" ]; then
    cat "$1"
  fi
}

#
# $1 file
# $2 match
# $3 text to insert
#
bpInsert() { ##I Insert text into file
  a=$(grep -A 10000 "$2" <"$1" | grep -v "$2")
  b=$(grep -B 10000 "$2" <"$1" | grep -v "$2")

  echo "$b" "$3" "$a" >|"$1"
}

##C- IHELP Input

#
# $1  Question string
# $2  Default value
# return string read from cmdline/default if enter pressed
#
bpReadGeneric() { ##I Read from commandline
  QUERY="$1"
  DEFAULT="$2"

  read -er -i "$DEFAULT" -p "${BP_C_QUERY}${1}${E_RESET} > " RESULT
  if [ "${RESULT}" == "" ]; then
    RESULT="${2}"
  fi
  echo "${RESULT}"
}

#
# $1  Question string
# $2  Default value
# return string read from cmdline/default if enter pressed
#
bpReadStr() { ##I Read string from commandline
  QUERY="$1"
  DEFAULT="$2"

  RESULT=$(bpReadGeneric "$QUERY" "$DEFAULT")
  bpLogInfo "User entered: $RESULT  ($QUERY)"
  echo "${RESULT}"
}

#
# $1  Question string
# $2  Default value
# $3  min value
# $4  max value
# return integer read from cmdline/default if enter pressed
#
bpReadInt() { ##I Read integer from commandline
  QUERY="$1"
  DEFAULT="$2"
  MIN="$3"
  MAX="$4"

  RANGE=""
  if [ -n "$MIN" ] || [ -n "$MAX" ]; then
    RANGE=" ${BP_C_QUERY_DEF}[${E_RESET}$3-$4${BP_C_QUERY_DEF}]${E_RESET}"
  fi

  while true; do
    read -er -i "$DEFAULT" -p "${BP_C_QUERY}${1}${E_RESET}${RANGE} > " RESULT

    if [ "$RESULT" -eq "$RESULT" ] 2>/dev/null; then

      if [ -n "${RANGE}" ]; then
        #if [ -n "$MIN" ] && [ -n "$MAX" ]; then
        if [ $((RESULT)) -ge "$MIN" ] && [ $((RESULT)) -le "$MAX" ]; then
          break
        fi
      else
        break
      fi
    fi
  done
  bpLogInfo "User entered: $RESULT  ($QUERY)"
  echo "${RESULT}"
}

#
# $1 question text
# $2 default answer 0 = yes, 1 = no
# return 0 = Yes, 1=No
#
bpReadBool() { ##I Ask yes/no question generic
  QUERY="$1"
  DEFAULT="$2"
  while true; do

    if [ "$2" -eq 1 ]; then
      yn=$(bpReadGeneric "${BP_C_QUERY}${1}${E_RESET} ${BP_C_QUERY_DEF}[${BP_C_DEEMPHASIS}y${BP_C_QUERY_DEF}/${BP_C_EMPHASIS}N${BP_C_QUERY_DEF}]${E_RESET}")
    else
      yn=$(bpReadGeneric "${BP_C_QUERY}${1}${E_RESET} ${BP_C_QUERY_DEF}[${E_RESET}${BP_C_EMPHASIS}Y${BP_C_QUERY_DEF}/${BP_C_DEEMPHASIS}n${BP_C_QUERY_DEF}]${E_RESET}")
    fi

    case "$yn" in
    [Yy]*)
      bpLogInfo "User entered: Yes  ($QUERY)"
      return 0
      break
      ;;
    [Nn]*)
      bpLogInfo "User entered: No  ($QUERY)"
      return 1
      break
      ;;
    "")
      if [ "$2" -eq 0 ]; then
        bpLogInfo "User entered: Yes  ($QUERY)"
      else
        bpLogInfo "User entered: No  ($QUERY)"
      fi
      return "$2"
      break
      ;;
    *) echo "Please answer yes or no." ;;
    esac
  done
}

#
# $1 Question text
# return 0 = Yes, 1=No
#
bpReadBoolDY() { ##I Ask yes/no question default yes
  bpReadBool "$1" 0
  return $?
}

#
# $1 Question text
# return 0 = Yes, 1=No
#
bpReadBoolDN() { ##I Ask yes/no question default no
  bpReadBool "$1" 1
  return $?
}

bpPrintChoiceList() { # Print items in selection list
  echo
  arr=("${@:2}")
  len=${#arr[@]}
  i=1
  while [ "$i" -lt "$len" ]; do
    key=${arr[$i]}
    ((i++))
    val=${arr[$i]}
    ((i++))
    desc=${arr[$i]}
    ((i++))

    if [ "$key" == "$1" ]; then
      default=">"
    else
      default=" "
    fi

    if [ "${desc}" == ":" ]; then
      printf "%1s ${BP_C_KEY}%-7s  ${BP_C_DESCRIPTION}%s${E_RESET}\n" "$default" "$key" "$val"
    else
      printf "%1s ${BP_C_KEY}%-7s  ${BP_C_DESCRIPTION}%s${E_RESET}\n" "$default" "$key" "$desc"
    fi
  done
}

#
# Select from list of choices
#
# $1 Default value
# $2 Question
# $* Array of choices
#
# Return: bpReturn
#
# Example choice list.
# list=(
#  "a" ":" "Choice A"
#  "b" ":" "Choice B"
#  "c" ":" "Choice C"
# )
bpSelectFromList() { ##I Select from list
  QUERY="$2"
  while true; do
    bpPrintChoiceList "$1" "${@:2}"
    echo
    x=$(bpReadGeneric "$2" "$1")

    arr=("${@}")
    len=${#arr[@]}
    i=2
    while [ "$i" -lt "$len" ]; do
      key=${arr[$i]}
      ((i++))
      val=${arr[$i]}
      ((i++))
      ((i++))
      if [ "$key" == "$x" ]; then
        if [ "$val" == ":" ]; then
          bpReturn="${key}"
        else
          bpReturn="${val}"
        fi
        bpLogInfo "User entered: $bpReturn  ($QUERY)"
        return 0
      fi
    done
  done
}

# Settings file ------------------------------------------------------

##C- BP_CONF Bashplate config file
##C- IHELP Bashplate config file

#
# $1 config file
# $2 key
# $3 value
# $4 description
#
bpAddSetting() { ##I Add setting to config file
  if ! bpStrExist "${1}" "${2}"; then
    {
      echo "# ${4}"
      echo "${2}=\"${3}\""
      echo
    } >>"${1}"

    bpOk "Added setting \"$2=$3\""
  fi
}

# Change setting in config file (key value pair)
#
# $1 config file
# $2 key
# $3 value
# $4 description
#
bpChangeSetting() { ##I Change setting in config file
  FILE="$1"
  KEY="$2"
  VAL="$3"
  DESC="$4"
  if ! bpStrExist "${1}" "${KEY}"; then
    bpAddSetting "$FILE" "$KEY" "$VAL" "$DESC"
  fi
  sed -i "s/^\(${KEY}\s*=\s*\).*\$/\1${VAL}/" "${FILE}"
  bpOk "Changing ${KEY} to ${VAL}"
}

#
# $1 key
# $2 config array
#
bpConfGetDesc() { ##I Get config desription
  arr=("${@:1}")
  len=${#arr[@]}
  bpReturn=""
  i=1
  while [ "$i" -lt "$len" ]; do
    key=${arr[$i]}
    ((i++))
    def=${arr[$i]}
    ((i++))
    desc=${arr[$i]}
    ((i++))
    #echo "$key"
    if [ "$key" == "$1" ]; then
      echo "$desc"
      return 0
    fi
  done
  return 1
}

#
# $1 key
# $2 value
# $3 config array
#
bpConfChangeSetting() {
  KEY="$1"
  VAL="$2"
  CONF=("${@:2}")
  FILE=${CONF[1]}
  DESC=$(bpConfGetDesc "$KEY" "${CONF[@]}")

  if ! bpConfInList "$KEY" "${CONF[@]}"; then
    bpError "\"$KEY\" is not a valid setting"
    return
  fi

  if ! bpStrExist "${FILE}" "${KEY}"; then
    bpAddSetting "${FILE}" "$KEY" "$VAL" "${DESC}"
    return "$BP_OK"
  fi

  bpChangeSetting "$FILE" "$KEY" "$VAL" "$DESC"
}

#
# $1 File
# $2 Headertext
# $3 config array
#
bpConfCreate() { ##I Create configuration file
  FILE="$1"
  bpMkDir "${BP_CONFIG_DIR}"
  bpMkDir "${BP_CONFIG_PATHS}"
  bpMkDir "${BP_CONFIG_MODULES}"
  {
    echo "# "
    echo "# $2"
    echo "# "
    echo
  } >>"${FILE}"

  arr=("${@:2}")
  len=${#arr[@]}
  i=1
  while [ "$i" -lt "$len" ]; do
    key=${arr[$i]}
    ((i++))
    default=${arr[$i]}
    ((i++))
    desc=${arr[$i]}
    ((i++))
    bpAddSetting "$FILE" "$key" "$default" "$desc"
  done
}

#
# $1 Config file
#
bpConfLoad() { ##I Load config file
  if [ -n "${1}" ]; then
    if [ ! -e "${1}" ]; then
      bpConfCreate "${@}"
    fi
    source "${1}"
  fi
}

#
# $1 key
# $2 config array
#
bpConfInList() { ##I Check if key exist in config file list
  arr=("${@:1}")
  len=${#arr[@]}
  bpReturn=""
  i=3
  while [ "$i" -lt "$len" ]; do
    key=${arr[$i]}
    ((i++))
    def=${arr[$i]}
    ((i++))
    desc=${arr[$i]}
    ((i++))
    #echo "Key = $key  Default = $def  Desc = $desc"
    if [ "$key" == "$1" ]; then
      bpReturn="$key"
      return 0
    fi
  done
  return 1
}

bpConfPrint() { ##I Print settings in config list
  echo
  bpPrintDesc "Config file" "$(bpColorizeFile "$3")"
  echo
  arr=("${@:4}")
  i=1
  while [ "$i" -lt ${#arr[@]} ]; do
    KEY=${arr[$i]}
    ((i++))
    DEF=${arr[$i]}
    ((i++))
    DESC=${arr[$i]}
    ((i++))
    printf "%s%s\n" "${E_GRAY}" "${DESC}"
    bpPrintVar "$KEY"
  done
}

bpset() { ##C BP_CONF Change setting in bp config file
  if [ -z "$2" ]; then
    bpConfPrint "" "" "${BP_CONFIG_LIST[@]}"
    return
  fi
  if bpConfInList "$2" "${BP_CONFIG_LIST[@]}"; then
    bpChangeSetting "${BP_CONFIG_FILE}" "${bpReturn}" "\"${3}\""
    return
  fi
  bpError "\"$2\" is not a valid setting"
}

##C- IHELP Bashrc path/module handling

bpLsPaths() { ##I List paths
  shopt -s nullglob dotglob
  for p in "${BP_CONFIG_PATHS}"/*; do
    echo "A: $(readlink "${p}")"
  done
}

#
# $1 directory to add to path
#
bpAddPath() { ##I Add dir to PATH variable
  ll=$(echo "${1}" | sed -e 's/\//_/g')

  bpInfo "Adding PATH \"${2}\""
  if [ ! -L "$1" ]; then
    bpLn "${1}" "${BP_CONFIG_PATHS}/${ll}"
  fi
}

bpRmPath() { ##I Remove path
  bpRm "${BP_CONFIG_PATHS}/${1}"
}

bpLsModules() { ##I List modules
  shopt -s nullglob dotglob
  for p in "${BP_CONFIG_MODULES}"/*; do
    readlink "${p}"
  done
}

bpAddModule() { ##I Add init script to
  m=$(realpath "${1}")
  if [ ! -L "$m" ]; then
    rm -f "${BP_CONFIG_MODULES}/$(basename "${m}")"
    bpLn "$m" "${BP_CONFIG_MODULES}/."
  fi
}

bpRmModule() { ##I Remove module
  bpRm "${BP_CONFIG_MODULES}/${1}"
}

##-

# Logging ---------------------------------------------------------

##C- IHELP Log functions

#
# Function logging to file
#
# $1 String to log to file
#
bpLog() { ##I Log to file command
  # check for BP_LOGFILE variable
  if [ -n "$BP_LOGFILE" ]; then
    ts=$(date +"%Y-%m-%d %H:%M:%S")
    bpFilterEscape "$ts $1" >>"${BP_LOGFILE}"
  fi
}

bpLogOk() { ##I Log Ok message to file
  bpLog "[ Ok ] $1"
}

bpLogInfo() { ##I Log Info message to file
  bpLog "[Info] $1"
}

bpLogDebug() { ##I Log Info message to file
  bpLog "[Debg] $1"
}

bpLogWarning() { ##I Log Warning message to file
  bpLog "[Warn] $1"
}

bpLogError() { ##I Log Error message to file
  bpLog "[Erro] $1"
}

bpLogCritical() { ##I Log Critical message to file
  bpLog "[Crit] $1"
}

log() { ##C BP_LOGFILE View logfile
  if [ -n "$BP_LOGFILE" ]; then
    if [ -f "${BP_LOGFILE}" ]; then # Check that logfile exists
      D=$(sed -r -e "s|\[Info\]|\[\\${BP_C_INFO}Info\\${E_RESET}\]|" \
        -e "s|\[Warn\]|\[\\${BP_C_WARNING}Warn\\${E_RESET}\]|" \
        -e "s|\[Erro\]|\[\\${BP_C_ERROR}Erro\\${E_RESET}\]|" \
        -e "s|\[ Ok \]|\[\\${BP_C_OK} Ok \\${E_RESET}\]|" \
        -e "s/[-0-9]+/\\${BP_C_DATE}&\\${E_RESET}/1" \
        -e "s/[:0-9]+/\\${BP_C_TIME}&\\${E_RESET}/6" \
        -e "s|\[Crit\]|\[\\${E_BG_RED}\\${E_WHITE}Crit\\${E_RESET}\]|" <"${BP_LOGFILE}")
      echo -e "$D"
    fi
  else
    bpInfo "Logging is not activated"
    bpExit
  fi
}

mlog() { ##C BP_LOGFILE Monitor logfile
  if [ -n "$BP_LOGFILE" ]; then
    if [ -f "${BP_LOGFILE}" ]; then # Check that logfile exists
      tail -f "${BP_LOGFILE}" | sed -r -e "s|\[Info\]|\[\\${BP_C_INFO}Info\\${E_RESET}\]|" \
        -e "s|\[Warn\]|\[\\${BP_C_WARNING}Warn\\${E_RESET}\]|" \
        -e "s|\[Erro\]|\[\\${BP_C_ERROR}Erro\\${E_RESET}\]|" \
        -e "s|\[ Ok \]|\[\\${BP_C_OK} Ok \\${E_RESET}\]|" \
        -e "s/[-0-9]+/\\${E_GREEN}&\\${E_RESET}/1" \
        -e "s/[:0-9]+/\\${E_BR_GREEN}&\\${E_RESET}/6" \
        -e "s|\[Crit\]|\[\\${E_BG_RED}\\${E_WHITE}Crit\\${E_RESET}\]|"
    fi
  else
    bpInfo "Logging is not activated"
    bpExit
  fi
}

##C- IHELP Message

bpOk() { ##I Success message
  if [ -n "$BP_LOG_OK" ]; then
    bpLogOk "$1"
  fi
  echo -e "[${BP_C_OK}Ok${E_RESET}] $1"
}

bpInfo() { ##I Info message
  if [ -n "$BP_LOG_INFO" ]; then
    bpLogInfo "$1"
  fi
  echo -e "[${BP_C_INFO}Info${E_RESET}] $1"
}

bpDebug() { ##I Debug message
  if [ -z "$BP_DEBUG" ]; then
    return
  fi
  if [ -n "$BP_LOG_INFO" ]; then
    bpLogDebug "$1"
  fi

  echo -e "[${BP_C_DEBUG}Dbg${E_RESET}] $1"
}

bpWarning() { ##I Warning message
  if [ -n "$BP_LOG_WARNING" ]; then
    bpLogWarning "$1"
  fi
  echo -e "[${BP_C_WARNING}Warning${E_RESET}] $1"
}

bpError() { ##I Error message
  if [ -n "$BP_LOG_ERROR" ]; then
    bpLogError "$1"
  fi
  echo -e "[${BP_C_ERROR}Error${E_RESET}] $1"
}

bpCritical() { ##I Critical error message
  if [ -n "$BP_LOG_CRITICAL" ]; then
    bpLogCritical "$1"
  fi
  echo -e "[${BP_C_CRITICAL}Critical${E_RESET}] $1"
  bpExit
}

# Various  ---------------------------------------------------------

##C- IHELP Assert

bpAssertRoot() { ##I Assert that user is root
  if [ "$(whoami)" != root ]; then
    bpError "Must be root to use this command."
    bpExit "1"
  fi
}

bpAssertNoLockFile() { ##I Assert that lockfile is not present
  if [ -n "$BP_LOCK_FILE" ]; then
    if [ -f "$BP_LOCK_FILE" ]; then
      bpError "Script is already running. (${BP_LOCK_FILE})"
      exit "1" # do not use bpExit because lock file belongs to prexsisting process
    fi
    touch "$BP_LOCK_FILE"
  fi
}

#
# $1 string list of programs that are required
#
bpAssertProgs() { ##I Assert that required programs are available on the system
  things=("$@")
  e=0
  for thing in "${things[@]}"; do
    hash "$thing" 2>&- ||
      {
        bpError "Required program \"$thing\" not found."
        e=1
      }
  done
  if [ "$e" -eq 1 ]; then
    bpExit 1
  fi
}

##C- IHELP Misc

#
# $1 command to check
#
bpHasCmd() { ##I Check whether a command exists in path and is executable
  if [ -x "$(command -v "${1}")" ]; then
    return 0
  else
    return 1
  fi
}

bpIsFunction() { ##I Check if and identifier is declared as a function
  if [ "$(type -t "$1")" == "function" ]; then
    return 0
  fi
  return 1
}

#
# Filter out function from script file
#
# $1 file
# $2 function
#
bpGetFunction() {
  grep --no-filename -A 60 "$1" -e "${2}()" | grep -B 60 -m 1 -x "}"
}

#
# $1 command to execute
#
bpRun() { ##I Execute command
  if ! bpHasCmd "${1}"; then
    bpError "Could not execute $1, command does not exist!"
    return 1
  fi

  "$@"
  return $?
}

##C- IHELP Debug/Controll

icheck() { ##I Run shellcheck on script
  bpAssertProgs "shellcheck"
  shellcheck "$0"
}

irt() { ##I Remove tabs from script
  sed -i -e 's/\t/  /g' "${BP_SELF_DIR}/${BP_SELF}"
}

##C- IHELP Help & info

printCommand() {
  IFS=$' '
  read -r -a LINE <<<"$1"
  DESC="${LINE[*]:3}"
  bpPrintDesc "${LINE[0]}" "${DESC}"
}

printCondCommand() {
  IFS=$' '
  read -r -a LINE <<<"$1"
  DESC="${LINE[*]:4}"
  COND=${LINE[3]}

  if [ -n "$IHELP" ] && [ "$COND" != "IHELP" ]; then
    return
  fi

  if [ -n "${!COND}" ]; then
    bpPrintDesc "${LINE[0]}" "${DESC}"
    return
  fi

  if [ "$2" -eq 1 ]; then
    bpPrintDescAlt "${LINE[0]}" "${DESC}"
  fi

}

printNamedLine() {
  IFS=$' '
  read -r -a LINE <<<"$1"
  bpPrintLine "${LINE[*]:1}"
}

printCondNamedLine() {
  IFS=$' '
  read -r -a LINE <<<"$1"
  DESC=${LINE[*]:2}
  COND=${LINE[1]}

  if [ -n "$IHELP" ] && [ "$COND" != "IHELP" ]; then
    return
  fi

  if [ -n "${!COND}" ]; then
    bpPrintLine "$DESC"
  fi
}

help() { ##D Print help information
  echo "$BP_USAGE"
  echo -e "$BP_DESC"
  echo

  BP_HELP=1

  if [ ! -e "${BP_CONFIG_DIR}" ] && [ -n "${BP_CONFIG}" ]; then
    BPINIT=1
  fi

  # bpExecHook "PRE_HELP_HOOK"
  if [ -n "$PRE_HELP_HOOK" ]; then
    "${PRE_HELP_HOOK}"
  fi

  IFS=$'\n'
  SC="$1"
  LINES=$(grep -h '##' "$0" | grep -v -e 'grep' -e '##I' -e '##V' -e '\*##C' -e '\*##C-' -e '\"##' -e '##-//' -e 'LINE' -e 'printLine')
  LINES="${LINES//()/}"

  for LINE in ${LINES}; do
    case "$LINE" in
    *"##-"*) printNamedLine "$LINE" ;;
    *"##C-"*) printCondNamedLine "$LINE" ;;
    *"##CV"*) printCondCommand "$LINE" 1 ;;
    *"##C"*) printCondCommand "$LINE" 0 ;;
    *"##D"*) printCommand "$LINE" '##D' ;;
    *) ;;

    esac
  done

  if [ -n "$POST_HELP_HOOK" ]; then
    "${POST_HELP_HOOK}"
  fi
}

#
# $1 command
#
ihelp() { ##I Print internal help information

  # Singe command documentation
  if [ "$2" != "" ]; then
    echo
    bpPrintLine "$2"
    echo
    echo "#"
    echo -n "# "
    grep --no-filename "$0" -e "${2}()" | sed -n -e 's/^.*##I //p'
    grep --no-filename -B 8 "$0" -e "${2}()" | grep "#" | grep -v "##"
    bpPrintLine
    bpExit
  fi

  IFS=$'\n'
  SC="$1"

  IHELP=1      # Force ihelp documentations
  BP_LOGFILE=1 # Force log documentation

  LINES=$(grep -h '##[C|I]' "$0" | grep -v -e 'grep' -e '\*"##[ A-Z]"\*' -e 'LINE' -e 'printNamedLine' -e 'awk' -e 'bpPrintDesc' -e 'name')
  LINES=$(echo -e "$LINES" | sed -s 's/()//g')

  for LINE in ${LINES}; do
    case "$LINE" in
    *"##C-"*) printCondNamedLine "$LINE" ;;
    *"##I"*) printCommand "$LINE" '##I' ;;
    *"##C"*) printCondCommand "$LINE" 0 ;;
    *) ;;

    esac
  done

  bpPrintLine "Bashplates comments"
  bpPrintDesc "##D Description" "Subcommand information comment (shown with help)"
  bpPrintDesc "##C COND Description" "Conditional subcommand comment (shown with help)"
  bpPrintDesc "##I Description" "Internal function comment (shown with ihelp)"
  bpPrintDesc "##- [Text]" "Separator line (shown with help)"
  bpPrintDesc "##C- COND [Text]" "Conditional separator line (shown with help)"
  bpPrintLine
}

iinfo() { ##I Show information about script
  bpPrintLine "Script information"
  bpPrintVar BP_SELF "Script" "$(bpColorizeFile "${BP_SELF_DIR}/${BP_SELF}")"
  bpPrintVar BP_VERSION "Script version"
  bpPrintVar BP_TEMPLATE_VERSION "Template version"
  bpPrintVar BP_CONFIG "Bashplate settings file" "$(bpColorizeFile "${BP_CONFIG}")"
  bpPrintVar BP_LOGFILE "Log file" "$(bpColorizeFile "${BP_LOGFILE}")"
  bpPrintVar BP_LOCK_FILE "Lock file" "$(bpColorizeFile "${BP_LOCK_FILE}")"
  bpPrintVar DEFAULT_CMD_HOOK "Default function"
  bpPrintDesc "PID" $$
  bpPrintVar BP_DATE "Date"
  bpPrintVar BP_TIME "Time"
  bpPrintVar TERM "Terminal"
  bpPrintVar BP_COLUMNS "Terminal columns"
  bpPrintVar BP_LINES "Terminal lines"

  if [ -n "${POST_INFO_HOOK}" ]; then
    bpPrintLine "App. information"
    ${POST_INFO_HOOK}
  fi

  if [ -z "$BP_CONF" ]; then
    bpPrintLine
    return
  fi
  bpPrintLine "Bashplate config"
  i=2
  while [ "$i" -lt ${#BP_CONFIG_LIST[@]} ]; do
    KEY=${BP_CONFIG_LIST[$i]}
    ((i++))
    ((i++))
    ((i++))
    bpPrintVar "$KEY"
  done

  bpPrintLine
}

iview() { ##I View example
  # Singe command documentation
  if [ "$2" == "" ]; then
    bpExit
  fi

  echo
  if bpHasCmd batcat; then # Use batcat, if available, to view function
    bpGetFunction "$0" "${2}" | batcat --language bash --decorations never
  else
    bpGetFunction "$0" "${2}" |
      sed -e "s/#.*/\\${BP_C_COMMENT}&\\${E_RESET}/" \
        -e "s/\<echo\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<if\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<then\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<else\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<fi\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<do\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<done\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<elif\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<case\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<esac\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<for\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<in\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<select\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<time\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<until\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<select\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<eval\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<break\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<while\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\".*\"/\\${BP_C_STRING}&\\${E_RESET}/" \
        -e "s/\([^=]*\)=/${BP_C_VAR}\1\\${E_RESET}=/"
  fi
  bpPrintLine
  bpExit
}

ivars() { ##I Print internal variables
  bpPrintLine "Script variables"
  echo
  IFS=$'\n'
  LINES=$(grep -v -e 'LINES' -e 'LINE' "$0" | grep -A 1 '##V') # | sed "s/--//" )
  for line in ${LINES}; do
    if [ "$line" == "--" ]; then
      echo
    else
      LINE=$(echo "${line}" | sed -u -e "s/##V[ ]/${BP_C_DESCRIPTION}/i" -e "s/^.*=/${BP_C_KEY}&${E_RESET}/i" -e "s/=/${E_RESET}=/")
      echo -e "$LINE"
      echo -en "$E_RESET"
    fi
  done
  echo
}

ied() { ##I Open this file with default editor
  bpEdit "$0" "$2"
}

#
# $1 File to diff with, if not given diff with bashplate template
#
idiff() { ##I Run diff with file or bashplate template

  if [ -z "$BP_DIFF" ]; then
    bpError "Diff program not declared (BP_DIFF)"
    return
  fi

  if [ -z "$2" ]; then
    if [ -n "${BP_PATH}" ]; then
      bpRun "${BP_DIFF}" "${BP_SELF_DIR}/${BP_SELF}" "${BP_PATH}/templates/bashplate"
      return
    fi
  fi
  bpRun "${BP_DIFF}" "${BP_SELF_DIR}/${BP_SELF}" "$2"
}

version() { ##D Print version information
  echo "$BP_VERSION"
}

# Runs a function in this file as a command
bpRunCommand() {
  if [ "$BP_ARGUMENTS" -eq 0 ]; then

    # check for a default command
    if [ -n "$DEFAULT_CMD_HOOK" ]; then
      "$DEFAULT_CMD_HOOK" "$1" "$2" "$3" "$4" "$5" "$6" "$7" "$8" "$9" "${10}"
      bpExit
    fi
    bpErrorExit "No command given"
  fi

  if [ "$(type -t "$1")" != "function" ]; then # Check if subcommand is declared as function
    bpErrorExit "Command \"$1\" not found"
  fi

  command=$1
  # execute pre command hook  if existing
  if [ -n "$PRE_CMD_HOOK" ]; then
    "${PRE_CMD_HOOK}" "$command"
  fi

  # Check if command is conditional
  CL=$(grep -E "${command}().*##C" "$0")
  if [[ "$CL" = *"##C"* ]]; then

    # Check if condition is true and then execute else printout error message
    read -r -a ARR <<<"$CL"
    CV="${ARR[3]}"
    if [ -n "$CV" ]; then
      if [ -n "${!CV}" ]; then
        # execute command
        "${command}" "$@"
      else
        bpError "Command \"$command\" not available right now."
      fi
    else
      bpError "Command \"$command\" is conditional, but is missing conditional variable"
    fi
  else
    # command is not conditional, execute
    "${command}" "$@"
  fi

  # execute post command hook  if existing
  if [ -n "$POST_CMD_HOOK" ]; then
    "${POST_CMD_HOOK}" "$command"
  fi
  bpExit
}

#---------------------------------------------------------------------
# Initiate internal variables
#---------------------------------------------------------------------

##V Bashplate version
BP_TEMPLATE_VERSION="1.40beta2"

##V Directory where script is located
BP_SELF_DIR="${0%/*}"

##V Name of script
BP_SELF_NAME=$(basename "$0")

##V Name of script (to be repurposed)
BP_SELF=$(basename "$0")

##V Number of arguments given to script
BP_ARGUMENTS=$#

##V Current date
BP_DATE=$(date +"%Y-%m-%d")

##V Current time
BP_TIME=$(date +"%H:%M:%S")

##V Number of columns in terminal
BP_COLUMNS=$(tput cols)

##V Number of lines in terminal
BP_LINES=$(tput lines)

##V Settings directory
BP_CONFIG_DIR=~/.config/bashplates

##V Settings file
BP_CONFIG_FILE=${BP_CONFIG_DIR}/bashplates.conf

##V System Path's
BP_CONFIG_PATHS="${BP_CONFIG_DIR}/path"

##V Links to modules
BP_CONFIG_MODULES="${BP_CONFIG_DIR}/modules"

# Initiate bashplate settings
bpInitSettings

# Initiate user settings
bpUserSettings

#---------------------------------------------------------------------
# Setup signal traps
#---------------------------------------------------------------------

trap signalQuit SIGQUIT
trap signalInt SIGINT
trap signalHup SIGHUP
trap signalTerm SIGTERM
trap 'signalErr ${FUNCNAME} ${LINENO}' ERR

#trap  'signalDbg ${FUNCNAME} ${LINENO}' DEBUG

#---------------------------------------------------------------------
# Load settings and execute script handler
#---------------------------------------------------------------------

BP_CONFIG_LIST=(
  "${BP_CONFIG_FILE}"
  "Bashplates common settings"
  "BP_NAME" "John Doe" "Users name"
  "BP_EMAIL" "john.doe@foo.bar" "Users email"
  "BP_ORG" "ACME" "Organisation"
  "BP_HOME" "www.foo.bar" "Home"
  "BP_LICENSE" "MIT" "Default license"
  "BP_EDITOR" "vi" "Default editor"
  "BP_DIFF" "meld" "Default diff program"
  "BP_GITSERVER" "github.com" "Default git server"
  "BP_GITUSER" "" "Default git user"
  "BP_GITPROTO" "http" "Default git protocol"
)

# Load configuration file settings
bpConfLoad "${BP_CONFIG_LIST[@]}"

# execute prescript hook if existing
if [ -n "$PRE_SCRIPT_HOOK" ]; then
  ${PRE_SCRIPT_HOOK} "$@"
fi

# Run command parser
bpRunCommand "$@"

# Exit cleanly
bpExit

##C- BP_HELP
