#!/usr/bin/env bash
# shellcheck disable=2034
# shellcheck disable=2317
# shellcheck disable=1090
#---------------------------------------------------------------------
#
#  bp
#
#  [Description]
#    Bashplate management script
#
#  [Author]
#    Peter Malmberg <peter.malmberg@gmail.com>
#
#  [Date]
#    2016-xx-xx
#
#  [License]
#     MIT
#
#---------------------------------------------------------------------
# Generated with bashplates. [https://github.com/zonbrisad/bashplates]
#---------------------------------------------------------------------
#

# Display commands as they are executed
#set -o xtrace
# Display shell input lines as they are read
#set -v

# Exit script when a command fails. Append ||true if error is expected
#set -o errexit # || true
# Exit script when undeclared variable is used
#set -o nounset
# Exit script when pipe fails
set -o pipefail

#---------------------------------------------------------------------
# User defined Settings
#---------------------------------------------------------------------
bpUserSettings() {
  BP_ADDONS="${BP_SELF_DIR}/addons"
  BP_TEMPLATES="${BP_SELF_DIR}/templates"

  BP_PREAMBLE="#!/usr/bin/env bash"
  BP_HEADER="${BP_TEMPLATES}/header"

  if [ -f "${BP_SELF_DIR}/DEV" ]; then
    BP_DEV=1
  fi
}
#---------------------------------------------------------------------
# User defined functions
#---------------------------------------------------------------------

##- Bashplates

#
# $1 source file
# $2 destination file
#
bpAppend() { ##I Append file to file
  if [ ! -f "$1" ]; then
    bpError "Can't append file $(bpColorizeFile "${1}") to $(bpColorizeFile "${2}")."
  fi
  cat "$1" >>"$2"
}

#
# Create a new script
#
# $1 template file
# $2
# $3 type
#
newScript() {
  t=$3
  name=$(bpReadStr "Enter name of new ${t}" "")

  if [ "$3" == "addon" ]; then
    script="${name}.bpaddon"
  else
    script="${name}"
  fi

  if [ -e "${script}" ]; then
    bpError "File ${E_BR_CYAN}${script}${E_END} already exists"
    return
  fi

  desc=$(bpReadStr "Enter description")
  author=$(bpReadStr "Enter author" "${BP_NAME} <${BP_EMAIL}>")

  echo "${BP_PREAMBLE}" >|"${script}"
  bpImport "$BP_HEADER" >>"${script}"
  cat "${BP_TEMPLATES}/$1" >>"${script}"
  chmod +x "${script}"

  if [ "$3" == "addon" ]; then
    bpInsert "${script}" "#__MODULES__" "$(bpaddon getaddontemp)"
  else
    bpReplaceLine "${script}" "#__MODULES__" ""
  fi

  bpReplace "${script}" "__NAME__" "${name}"
  bpReplace "${script}" "__DATE__" "${BP_DATE}"
  bpReplace "${script}" "__LICENSE__" "${BP_LICENSE}"
  bpReplace "${script}" "__AUTHOR__" "${author}"
  bpReplace "${script}" "__DESC__" "${desc}"

  bpOk "Created file $script"
}

new() { ##D Create a new standard bashplate project
  newScript "bashplate" "" "script"
}

newd() { ##C BP_DEV Create a new standard bashplate project
  newScript "bashplate-dev" "" "script"
}

news() { ##D Create a new simple bashplate project
  newScript "bashplate-simple" "" "script"
}

newi() { ##C BP_DEV Create new init script
  name=$(bpReadStr "Enter name of init script" "")
  desc=$(bpReadStr "Enter description")
  script="${name}"
  cat "${BP_TEMPLATES}/bashplate-init" >>"${script}"
  bpReplace "${script}" "__DESC__" "${desc}"
  bpReplace "${script}" "__NAME__" "${name}"
  chmod +x "${script}"
  bpOk "Created file $script"
}

##- Setup

bp_install() { ##D Install bashplates init
  bpAddModule "${BP_SELF_DIR}/bp_init"
}

##- Documentation

cs() { ##D Cheat sheet for common BASH features
  BP_LINE_CHAR=""

  if [ "$BP_COLUMNS" -ge 200 ]; then
    BP_COLUMNS=$(("$BP_COLUMNS" / 4 - 1))
    cs-cheat-sheet | "${BP_SELF_DIR}"/dev/columnize.py --columns 4
    return
  fi

  if [ "$BP_COLUMNS" -ge 150 ]; then
    BP_COLUMNS=$(("$BP_COLUMNS" / 3 - 1))
    cs-cheat-sheet | "${BP_SELF_DIR}"/dev/columnize.py --columns 3
    return
  fi

  if [ "$BP_COLUMNS" -ge 100 ]; then
    BP_COLUMNS=$(("$BP_COLUMNS" / 2 - 1))
    cs-cheat-sheet | "${BP_SELF_DIR}"/dev/columnize.py --columns 2
    return

  fi
  cs-cheat-sheet
}

# shellcheck disable=2016
cs-cheat-sheet() {
  # https://devhints.io/bash

  bpPrintLine "Arithmetic operators"
  bpPrintDesc '(( N1 + N2 ))' "Addition"
  bpPrintDesc '(( N1 - N2 ))' "Subtraction"
  bpPrintDesc '(( N1 * N2 ))' "Multiplication"
  bpPrintDesc '(( N1 / N2 ))' "Division"
  bpPrintDesc '(( N1 % N2 ))' "Modulo"
  bpPrintDesc '(( N1 ** N2 ))' "Exponentiation"
  bpPrintDesc '(( N1++ ))' "Variable increment"
  bpPrintDesc '(( N1-- ))' "Variable decrement"

  bpPrintLine "Bitwise operators"
  bpPrintDesc '(( N1 << N2 ))' "Bitwise shift left"
  bpPrintDesc '(( N1 >> N2 ))' "Bitwise shift right"
  bpPrintDesc '(( N1 & N2 ))' "Bitwise and"
  bpPrintDesc '(( N1 | N2 ))' "Bitwise or"
  bpPrintDesc '(( N1 ^ N2 ))' "Bitwise xor"
  bpPrintDesc '(( N1 ~ N2 ))' "Bitwise negation"

  bpPrintLine "Logical operators"
  bpPrintDesc '(( N1 && N2 ))' "Logical and"
  bpPrintDesc '(( N1 || N2 ))' "Logical or"

  bpPrintLine "Arithmetic tests"
  bpPrintDesc '(( N1 == N2 ))' "Equal"
  bpPrintDesc '(( N1 != N2 ))' "Not equal"
  bpPrintDesc '(( N1 < N2 ))' "Less than"
  bpPrintDesc '(( N1 <= N2 ))' "Less than or equal"
  bpPrintDesc '(( N1 > N2 ))' "Greater than"
  bpPrintDesc '(( N1 >= N2 ))' "Greater than or equal"

  bpPrintLine "String tests"
  bpPrintDesc '[ "$STR1" == "$STR2" ]' "Strings equal"
  bpPrintDesc '[ "$STR1" != "$STR2" ]' "Strings not equal"
  bpPrintDesc '[ -z STRING ]' "Empty string"
  bpPrintDesc '[ -n STRING ]' "Not empty string (string exists)"
  bpPrintDesc '[[ STRING =~ STRING ]]' "Regexp"

  bpPrintLine "Logical tests"
  bpPrintDesc "[ ! EXPR ]" "Not"
  bpPrintDesc "[ X ] && [ Y ]" "And"
  bpPrintDesc "[ X ] || [ Y ]" "Or"

  bpPrintLine "Other tests"
  bpPrintDesc "[ -o noclobber ]" "If OPTIONNAME is enabled"

  bpPrintLine "File conditions"
  bpPrintDesc "[ -e FILE ]" "File exists"
  bpPrintDesc "[ -f FILE ]" "Is regular file"
  bpPrintDesc "[ -d FILE ]" "Is directory"
  bpPrintDesc "[ -h FILE ]" "Is symlink"
  bpPrintDesc "[ -r FILE ]" "Is readble"
  bpPrintDesc "[ -w FILE ]" "Is writable"
  bpPrintDesc "[ -x FILE ]" "Is executable"
  bpPrintDesc "[ -s FILE ]" "Size>0"
  bpPrintDesc "[ -S FILE ]" "Is socket"
  bpPrintDesc "[ -g FILE ]" "sgid bit set"
  bpPrintDesc "[ -u FILE ]" "suid bit set"
  bpPrintDesc "[ FILE1 -nt FILE2 ]" "1 is more recent than 2"
  bpPrintDesc "[ FILE1 -ot FILE2 ]" "2 is more recent than 1"
  bpPrintDesc "[ FILE1 -ef FILE2 ]" "Same files"

  #bpPrintLine "\e]8;;https://tiswww.case.edu/php/chet/bash/bashref.html#Special-Parameters\aSpecial parameters\e]8;;\a"
  bpPrintLine "Special parameters"
  bpPrintDesc '$#' "Number of arguments"
  bpPrintDesc '$*' "All arguments"
  bpPrintDesc '$@' "All arguments, starting from first"
  bpPrintDesc '$1' "First argument"
  bpPrintDesc '$?' "Exit status of last task"
  bpPrintDesc '$-' "Current option flags"
  bpPrintDesc '$!' "PID of last background task"
  bpPrintDesc '$$' "PID of shell"
  bpPrintDesc '$_' "Last argument of the previous command"

  bpPrintLine "Redirect/pipe"
  bpPrintDesc '> FILE' "stdout to FILE"
  bpPrintDesc '2> FILE' "stderr to FILE"
  bpPrintDesc '&> FILE' "stdout and stderr to FILE"
  bpPrintDesc '1> FILE1 2> FILE2' "stdout/stderr to separate files"
  bpPrintDesc '2>&1' "stderr to stdout"
  bpPrintDesc '>> FILE' "append to FILE"
  bpPrintDesc '>| FILE' "overwrite FILE"
  bpPrintDesc '&> /dev/null' "stdout and stderr to /dev/null"
  bpPrintDesc '< FILE' "Pipe file to command"
  bpPrintDesc '<<< VAR' "Pipe variable to command"

  bpPrintLine "Array assigning"
  bpPrintDesc "Array=('A' 'B' 'C')" "Assign direct"
  bpPrintLine
  bpPrintDesc 'LS="A B C"' "Assign via read"
  bpPrintDesc 'read -r -a Array <<< $LS' ""
  bpPrintLine
  bpPrintDesc 'Array+=("D")' "Append element"

  bpPrintLine "Array operations"
  bpPrintDesc '${Array[n]}' "Element n"
  bpPrintDesc '${Array[-1]}' "Last element"
  bpPrintDesc '${Array[-2]}' "Second to last element"
  bpPrintDesc '${Array[@]}    # A B C D' "All elements"
  bpPrintDesc '${Array[@]:1}  # B C D' "All but first element"
  bpPrintDesc '${Array[@]:2}  # C D' "All but two first elements"
  bpPrintDesc '${Array[@]::1} # A' "First element"
  bpPrintDesc '${Array[@]::2} # A B' "Two first elements"

  bpPrintDesc '${#Array[@]}' "Nr of elements"
  bpPrintDesc '${#Array[n]}' "String lenght of nth element"
  bpPrintDesc '${Array[@]:3:2}' "Range (from pos 3, length 2)"
  bpPrintDesc '${!Array[@]}   # 0 1 2 3' "Keys of all elements"

  bpPrintLine "Parameter basics"
  bpPrintDesc 'STR="ABCD"    # "ABCD"' "Assign"
  bpPrintDesc 'STR="${STR}E" # "ABCDE"' "Append"
  bpPrintDesc '${#STR}       # 5' "Length"
  bpPrintDesc 'POINTER=STR' ""
  bpPrintDesc '${!POINTER}   # "ABCDE"' "Pointer to parameter"

  bpPrintLine 'Parameter slicing'
  bpPrintDesc '${STR:index:length}' ""
  bpPrintLine
  bpPrintDesc '${STR:1}      # "BCDE"' ""
  bpPrintDesc '${STR:2}      # "CDE"' ""
  bpPrintDesc '${STR::-1}    # "ABCD"' ""
  bpPrintDesc '${STR::-2}    # "ABC"' ""
  bpPrintDesc '${STR:1:-1}   # "BCD"' ""

  bpPrintDesc '${STR::1}     # "A"' "First char"
  bpPrintDesc '${STR::2}     # "AB"' "First chars"
  bpPrintDesc '${STR: -1}    # "E"' "Last char"
  bpPrintDesc '${STR: -2}    # "DE"' "Last chars"

  bpPrintDesc '${STR:,,}     # "abcde"' "To lowercase"
  bpPrintDesc '${STR:^^}     # "ABCDE"' "To uppercase"

  bpPrintLine 'Parameter substitution'
  bpPrintDesc '${STR%suffix}' "Remove suffix"
  bpPrintDesc '${STR#prefix}' "Remove prefix"
  bpPrintDesc '${STR%%suffix}' "Remove long suffix"
  bpPrintDesc '${STR##prefix}' "Remove long prefix"
  bpPrintDesc '${STR/from/to}' "Replace first match"
  bpPrintDesc '${STR//from/to}' "Replace all"
  bpPrintDesc '${STR/%from/to}' "Replace suffix"
  bpPrintDesc '${STR/#from/to}' "Replace prefix"

  bpPrintLine 'Parameter default values'
  bpPrintDesc '${STR:-val}' '$STR, or val if STR is unset'
  bpPrintDesc '${STR:=val}' 'set $STR to val if unset'
  bpPrintDesc '${STR:?message}' 'Show error message and exit if $STR is unset (or null)'
  bpPrintLine
}

cse() { ##D List BASH exit codes
  BP_LINE_CHAR=""
  BP_KEY_LENGTH="6"

  if [ "$BP_COLUMNS" -ge 200 ]; then
    BP_COLUMNS=$(("$BP_COLUMNS" / 4 - 1))
    cs-exit-codes | "${BP_SELF_DIR}"/dev/columnize.py --columns 4
    return
  fi

  if [ "$BP_COLUMNS" -ge 150 ]; then
    BP_COLUMNS=$(("$BP_COLUMNS" / 3 - 1))
    cs-exit-codes | "${BP_SELF_DIR}"/dev/columnize.py --columns 3
    return
  fi

  if [ "$BP_COLUMNS" -ge 100 ]; then
    BP_COLUMNS=$(("$BP_COLUMNS" / 2 - 1))
    cs-exit-codes | "${BP_SELF_DIR}"/dev/columnize.py --columns 2
    return

  fi
  cs-exit-codes
}

cs-exit-codes() {
  bpPrintLine "Bash exit codes"
  bpPrintDesc "0" "Success"
  bpPrintDesc "1" "Operation not permitted"
  bpPrintDesc "2" "No such file or directory"
  bpPrintDesc "3" "No such process"
  bpPrintDesc "4" "Interrupted system call"
  bpPrintDesc "5" "Input/output error"
  bpPrintDesc "6" "No such device or address"
  bpPrintDesc "7" "Argument list too long"
  bpPrintDesc "8" "Exec format error"
  bpPrintDesc "9" "Bad file descriptor"
  bpPrintDesc "10" "No child processes"
  bpPrintDesc "11" "Resource temporarily unavailable"
  bpPrintDesc "12" "Cannot allocate memory"
  bpPrintDesc "13" "Permission denied"
  bpPrintDesc "14" "Bad address"
  bpPrintDesc "15" "Block device required"
  bpPrintDesc "16" "Device or resource busy"
  bpPrintDesc "17" "File exists"
  bpPrintDesc "18" "Invalid cross-device link"
  bpPrintDesc "19" "No such device"
  bpPrintDesc "20" "Not a directory"
  bpPrintDesc "21" "Is a directory"
  bpPrintDesc "22" "Invalid argument"
  bpPrintDesc "23" "Too many open files in system"
  bpPrintDesc "24" "Too many open files"
  bpPrintDesc "25" "Inappropriate ioctl for device"
  bpPrintDesc "26" "Text file busy"
  bpPrintDesc "27" "File too large"
  bpPrintDesc "28" "No space left on device"
  bpPrintDesc "29" "Illegal seek"
  bpPrintDesc "30" "Read-only file system"
  bpPrintDesc "31" "Too many links"
  bpPrintDesc "32" "Broken pipe"
  bpPrintDesc "33" "Numerical argument out of domain"
  bpPrintDesc "34" "Numerical result out of range"
  bpPrintDesc "35" "Resource deadlock avoided"
  bpPrintDesc "36" "File name too long"
  bpPrintDesc "37" "No locks available"
  bpPrintDesc "38" "Function not implemented"
  bpPrintDesc "39" "Directory not empty"
  bpPrintDesc "40" "Too many levels of symbolic links"
  bpPrintDesc "42" "No message of desired type"
  bpPrintDesc "43" "Identifier removed"
  bpPrintDesc "44" "Channel number out of range"
  bpPrintDesc "45" "Level 2 not synchronized"
  bpPrintDesc "46" "Level 3 halted"
  bpPrintDesc "47" "Level 3 reset"
  bpPrintDesc "48" "Link number out of range"
  bpPrintDesc "49" "Protocol driver not attached"
  bpPrintDesc "50" "No CSI structure available"
  bpPrintDesc "51" "Level 2 halted"
  bpPrintDesc "52" "Invalid exchange"
  bpPrintDesc "53" "Invalid request descriptor"
  bpPrintDesc "54" "Exchange full"
  bpPrintDesc "55" "No anode"
  bpPrintDesc "56" "Invalid request code"
  bpPrintDesc "57" "Invalid slot"
  bpPrintDesc "59" "Bad font file format"
  bpPrintDesc "60" "Device not a stream"
  bpPrintDesc "61" "No data available"
  bpPrintDesc "62" "Timer expired"
  bpPrintDesc "63" "Out of streams resources"
  bpPrintDesc "64" "Machine is not on the network"
  bpPrintDesc "65" "Package not installed"
  bpPrintDesc "66" "Object is remote"
  bpPrintDesc "67" "Link has been severed"
  bpPrintDesc "68" "Advertise error"
  bpPrintDesc "69" "Srmount error"
  bpPrintDesc "70" "Communication error on send"
  bpPrintDesc "71" "Protocol error"
  bpPrintDesc "72" "Multihop attempted"
  bpPrintDesc "73" "RFS specific error"
  bpPrintDesc "74" "Bad message"
  bpPrintDesc "75" "Value too large for defined data type"
  bpPrintDesc "76" "Name not unique on network"
  bpPrintDesc "77" "File descriptor in bad state"
  bpPrintDesc "78" "Remote address changed"
  bpPrintDesc "79" "Can not access a needed shared library"
  bpPrintDesc "80" "Accessing a corrupted shared library"
  bpPrintDesc "81" ".lib section in a.out corrupted"
  bpPrintDesc "82" "Attempting to link in too many shared libraries"
  bpPrintDesc "83" "Cannot exec a shared library directly"
  bpPrintDesc "84" "Invalid or incomplete multibyte or wide character"
  bpPrintDesc "85" "Interrupted system call should be restarted"
  bpPrintDesc "86" "Streams pipe error"
  bpPrintDesc "87" "Too many users"
  bpPrintDesc "88" "Socket operation on non-socket"
  bpPrintDesc "89" "Destination address required"
  bpPrintDesc "90" "Message too long"
  bpPrintDesc "91" "Protocol wrong type for socket"
  bpPrintDesc "92" "Protocol not available"
  bpPrintDesc "93" "Protocol not supported"
  bpPrintDesc "94" "Socket type not supported"
  bpPrintDesc "95" "Operation not supported"
  bpPrintDesc "96" "Protocol family not supported"
  bpPrintDesc "97" "Address family not supported by protocol"
  bpPrintDesc "98" "Address already in use"
  bpPrintDesc "99" "Cannot assign requested address"
  bpPrintDesc "100" "Network is down"
  bpPrintDesc "101" "Network is unreachable"
  bpPrintDesc "102" "Network dropped connection on reset"
  bpPrintDesc "103" "Software caused connection abort"
  bpPrintDesc "104" "Connection reset by peer"
  bpPrintDesc "105" "No buffer space available"
  bpPrintDesc "106" "Transport endpoint is already connected"
  bpPrintDesc "107" "Transport endpoint is not connected"
  bpPrintDesc "108" "Cannot send after transport endpoint shutdown"
  bpPrintDesc "109" "Too many references"
  bpPrintDesc "110" "Connection timed out"
  bpPrintDesc "111" "Connection refused"
  bpPrintDesc "112" "Host is down"
  bpPrintDesc "113" "No route to host"
  bpPrintDesc "114" "Operation already in progress"
  bpPrintDesc "115" "Operation now in progress"
  bpPrintDesc "116" "Stale file handle"
  bpPrintDesc "117" "Structure needs cleaning"
  bpPrintDesc "118" "Not a XENIX named type file"
  bpPrintDesc "119" "No XENIX semaphores available"
  bpPrintDesc "120" "Is a named type file"
  bpPrintDesc "121" "Remote I/O error"
  bpPrintDesc "122" "Disk quota exceeded"
  bpPrintDesc "123" "No medium found"
  bpPrintDesc "125" "Operation canceled"
  bpPrintDesc "126" "Required key not available"
  bpPrintDesc "127" "Key has expired"
  bpPrintDesc "128" "Key has been revoked"
  bpPrintDesc "129" "Key was rejected by service"
  bpPrintDesc "130" "Owner died"
  bpPrintDesc "131" "State not recoverable"
  bpPrintDesc "132" "Operation not possible due to RF-kill"
  bpPrintDesc "133" "Memory page has hardware error"
  bpPrintLine
}

csv() { ##D List BASH internal variables
  # https://www.gnu.org/software/bash/manual/html_node/Bash-Variables.html
  # https://tldp.org/LDP/abs/html/internalvariables.html

  BP_LINE_CHAR=""
  #BP_KEY_LENGTH="6"

  # if [ "$BP_COLUMNS" -ge 200 ]; then
  #   BP_COLUMNS=$(("$BP_COLUMNS" / 4 - 1))
  #   cs-variables | "${BP_SELF_DIR}"/dev/columnize.py --columns 4
  #   return
  # fi

  if ((BP_COLUMNS > 150)); then
    BP_COLUMNS=$(("$BP_COLUMNS" / 3 - 1))
    cs-variables | "${BP_SELF_DIR}"/dev/columnize.py --columns 3
    return
  fi

  if ((BP_COLUMNS > 100)); then
    BP_COLUMNS=$(("$BP_COLUMNS" / 2 - 1))
    cs-variables | "${BP_SELF_DIR}"/dev/columnize.py --columns 2
    return
  fi
  cs-variables
}

#shellcheck disable=2016
cs-variables() {
  # https://devhints.io/bash

  bpPrintLine "BASH variables"
  bpPrintDesc "BASH" ""
  bpPrintDesc "BASHOPTS" ""
  bpPrintDesc "BASHPID" ""
  bpPrintDesc "BASH_ALIASES" ""
  bpPrintDesc "BASH_ARGC" ""
  bpPrintDesc "BASH_ARGV" ""
  bpPrintDesc "BASH_ARGV0" ""
  bpPrintDesc "BASH_CMDS" ""
  bpPrintDesc "BASH_COMMAND" ""
  bpPrintDesc "BASH_COMPAT" ""
  bpPrintDesc "BASH_ENV" ""
  bpPrintDesc "BASH_EXECUTION_STRING" ""
  bpPrintDesc "BASH_LINENO" ""
  bpPrintDesc "BASH_LOADABLES_PATH" ""
  bpPrintDesc "BASH_REMATCH" ""
  bpPrintDesc "BASH_SOURCE" ""
  bpPrintDesc "BASH_SUBSHELL" ""
  bpPrintDesc "BASH_VERSIONINFO[]" ""
  bpPrintDesc "BASH_VERSION" ""
  bpPrintDesc "BASH_XTRACEFD" ""
  bpPrintDesc "CHILD_MAX" ""
  bpPrintDesc "COLUMNS" ""
  bpPrintDesc "COMP_CWORD" ""
  bpPrintDesc "COMP_LINE" ""
  bpPrintDesc "COMP_POINT" ""
  bpPrintDesc "COMP_TYPE" ""
  bpPrintDesc "COMP_KEY" ""
  bpPrintDesc "COMP_WORDBREAKS" ""
  bpPrintDesc "COMP_WORD" ""
  bpPrintDesc "COMREPLY" ""
  bpPrintDesc "COPROC" ""
  bpPrintDesc "DIRSTACK" ""
  bpPrintDesc "EMACS" ""
  bpPrintDesc "ENV" ""
  bpPrintDesc "EPOCHREALTIME" ""
  bpPrintDesc "EPOCHSECONDS" ""
  bpPrintDesc "EUID" ""
  bpPrintDesc "EXECIGNORE" ""
  bpPrintDesc "FCEDIT" ""
  bpPrintDesc "FIGNORE" ""
  bpPrintDesc "FUNCNAME" ""
  bpPrintDesc "FUNCNEST" ""
  bpPrintDesc "GLOBIGNORE" ""
  bpPrintDesc "GROUPS" ""
  bpPrintDesc "HOME" ""
  bpPrintDesc "histchars" ""
  bpPrintDesc "HISTCMD" ""
  bpPrintDesc "HISTCONTROL" ""
  bpPrintDesc "HISTFILE" ""
  bpPrintDesc "HISTFILESIZE" ""
  bpPrintDesc "HISTIGNORE" ""
  bpPrintDesc "HISTSIZE" ""
  bpPrintDesc "HISTTIMEFORMAT" ""
  bpPrintDesc "HOSTFILE" ""
  bpPrintDesc "HOSTNAME" ""
  bpPrintDesc "HOSTTYPE" ""
  bpPrintDesc "IFS" ""
  bpPrintDesc "IGNOREEOF" ""
  bpPrintDesc "INPUTRC" ""
  bpPrintDesc "INSIDE_EMACS" ""
  bpPrintDesc "LANG" ""
  bpPrintDesc "LC_ALL" ""
  bpPrintDesc "LC_COLLATE" ""
  bpPrintDesc "LC_CTYPE" ""
  bpPrintDesc "LC_MESSAGES" ""
  bpPrintDesc "LC_NUMERIC" ""
  bpPrintDesc "LC_TIME" ""
  bpPrintDesc "LINENO" ""
  bpPrintDesc "LINES" ""
  bpPrintDesc "MACHTYPE" ""
  bpPrintDesc "MAILCHECK" ""
  bpPrintDesc "MAPFILE" ""
  bpPrintDesc "OLDPWD" ""
  bpPrintDesc "OPTERR" ""
  bpPrintDesc "OSTYPE" ""
  bpPrintDesc "PIPETYPE" ""
  bpPrintDesc "POSIXLY_CORRECT" ""
  bpPrintDesc "PPID" ""
  bpPrintDesc "PROMPT_COMMAND" ""
  bpPrintDesc "PROMPT_DIRTRIM" ""
  bpPrintDesc "PS0" ""
  bpPrintDesc "PS1" ""
  bpPrintDesc "PS2" ""
  bpPrintDesc "PS3" ""
  bpPrintDesc "PWD" ""
  bpPrintDesc "RANDOM" ""
  bpPrintDesc "READLINE_ARGUMENT" ""
  bpPrintDesc "READLINE_LINE" ""
  bpPrintDesc "READLINE_MARK" ""
  bpPrintDesc "READLINE_POINT" ""
  bpPrintDesc "REPLY" ""
  bpPrintDesc "SECONDS" ""
  bpPrintDesc "SHELL" ""
  bpPrintDesc "SHELLOPTS" ""
  bpPrintDesc "SHLVL" ""
  bpPrintDesc "SRANDOM" ""
  bpPrintDesc "TIMEFORMAT" ""
  bpPrintDesc "TMOUT" ""
  bpPrintDesc "TMPDIR" ""
  bpPrintDesc "UID" ""

  bpPrintLine "Positional parameters"
  bpPrintDesc '$0, $1, $2, etc' ""
  bpPrintDesc '$#' ""
  bpPrintDesc '$*' ""
  bpPrintDesc '$@' ""

  bpPrintLine "Other special parameters"
  bpPrintDesc '$-' ""
  bpPrintDesc '$!' ""
  bpPrintDesc '$_' ""
  bpPrintDesc '$?' ""
  bpPrintDesc '$$' ""
}

printChar() {
  printf " ${BP_C_FILENAME}%3s  ${E_GREEN}%3s  ${E_MAGENTA}%-8s  ${E_RED}%-4s ${E_YELLOW}%-3s  ${BP_C_DESCRIPTION}%s${E_RESET}\n" "$1" "$2" "$3" "$4" "$5" "$6"
}

ascii() { ##D Print Ascii table
  BP_LINE_CHAR=""
  #BP_KEY_LENGTH="6"

  # if ((BP_COLUMNS > 232)); then
  #   BP_COLUMNS=$(("$BP_COLUMNS" / 4 - 1))
  #   print-ascii | "${BP_SELF_DIR}"/dev/columnize.py --columns 4
  #   return
  # fi

  if ((BP_COLUMNS > 174)); then
    BP_COLUMNS=$(("$BP_COLUMNS" / 3 - 1))
    print-ascii | "${BP_SELF_DIR}"/dev/columnize.py --columns 3
    return
  fi

  if ((BP_COLUMNS > 116)); then
    BP_COLUMNS=$(("$BP_COLUMNS" / 2 - 1))
    print-ascii | "${BP_SELF_DIR}"/dev/columnize.py --columns 2
    return
  fi

  print-ascii
}

asciie() { ##D Print extended Ascii table
  BP_LINE_CHAR=""

  if ((BP_COLUMNS > 174)); then
    BP_COLUMNS=$(("$BP_COLUMNS" / 3 - 1))
    print-asciie | "${BP_SELF_DIR}"/dev/columnize.py --columns 3
    return
  fi

  if ((BP_COLUMNS > 116)); then
    BP_COLUMNS=$(("$BP_COLUMNS" / 2 - 1))
    print-asciie | "${BP_SELF_DIR}"/dev/columnize.py --columns 2
    return
  fi

  print-asciie
}

print-ascii() {
  printChar "Dec" "Hex" "Bin" "Sym" "Esc" "Description"
  print-table 0 127 "${asciiTable[@]}"
}

print-asciie() {
  printChar "Dec" "Hex" "Bin" "Sym" "Esc" "Description"
  print-table 128 255 "${asciiTable[@]}"
}

print-table() {
  table=("${@:3}")
  LEN=$((($2 + 1) * (6)))
  i=$(($1 * 6))

  while [ "$i" -lt "$LEN" ]; do
    dec=${table[$i]}
    ((i++))
    hex=${table[$i]}
    ((i++))
    bin=${table[$i]}
    ((i++))
    symbol=${table[$i]}
    ((i++))
    escape=${table[$i]}
    ((i++))
    desc=${table[$i]}
    ((i++))
    printChar "$dec" "$hex" "$bin" "$symbol" "$escape" "$desc"
  done
}

asciiTable=(
  "0" "00" "00000000" "NUL" "\0" "Null character"
  "1" "01" "00000001" "SOH" "" "Start of Heading"
  "2" "02" "00000010" "STX" "" "Start of Text"
  "3" "03" "00000011" "ETX" "" "End of Text"
  "4" "04" "00000100" "EOT" "" "End of Transmission"
  "5" "05" "00000101" "ENQ" "" "Enquiry"
  "6" "06" "00000110" "ACK" "" "Acknowledge"
  "7" "07" "00000111" "BEL" "\a" "Bell, Alert"
  "8" "08" "00001000" "BS" "\b" "Backspace"
  "9" "09" "00001001" "HT" "\t" "Horizontal Tab"
  "10" "0A" "00001010" "LF" "\n" "Line Feed"
  "11" "0B" "00001011" "VT" "\v" "Vertical Tabulation"
  "12" "0C" "00001100" "FF" "\f" "Form Feed"
  "13" "0D" "00001101" "CR" "\r" "Carriage Return"
  "14" "0E" "00001110" "SO" "" "Shift Out"
  "15" "0F" "00001111" "SI" "" "Shift In"
  "16" "10" "00010000" "DLE" "" "Data Link Escape"
  "17" "11" "00010001" "DC1" "" "Device Control One (XON)"
  "18" "12" "00010010" "DC2" "" "Device Control Two"
  "19" "13" "00010011" "DC3" "" "Device Control Three (XOFF)"
  "20" "14" "00010100" "DC4" "" "Device Control Four"
  "21" "15" "00010101" "NAK" "" "Negative Acknowledge"
  "22" "16" "00010110" "SYN" "" "Synchronous Idle"
  "23" "17" "00010111" "ETB" "" "End of Transmission Block"
  "24" "18" "00011000" "CAN" "" "Cancel"
  "25" "19" "00011001" "EM" "" "End of medium"
  "26" "1A" "00011010" "SUB" "" "Substitute"
  "27" "1B" "00011011" "ESC" "\e" "Escape"
  "28" "1C" "00011100" "FS" "" "File Separator"
  "29" "1D" "00011101" "GS" "" "Group Separator"
  "30" "1E" "00011110" "RS" "" "Record Separator"
  "31" "1F" "00011111" "US" "" "Unit Separator"
  "32" "20" "00100000" "SP" "" "Space"
  "33" "21" "00100001" "!" "" "Exclamation mark"
  "34" "22" "00100010" '"' "" "Double quotes"
  "35" "23" "00100011" "#" "" "Number sign"
  "36" "24" "00100100" "$" "" "Dollar"
  "37" "25" "00100101" "%" "" "Per cent sign"
  "38" "26" "00100110" "&" "" "Ampersand"
  "39" "27" "00100111" "'" "" "Single quote"
  "40" "28" "00101000" "(" "" "Open parenthesis"
  "41" "29" "00101001" ")" "" "Close parenthesis"
  "42" "2A" "00101010" "*" "" "Asterisk"
  "43" "2B" "00101011" "+" "" "Plus"
  "44" "2C" "00101100" "," "" "Comma"
  "45" "2D" "00101101" "-" "" "Hyphen-minus"
  "46" "2E" "00101110" "." "" "Period, dot or full stop"
  "47" "2F" "00101111" "/" "" "Slash or divide"
  "48" "30" "00110000" "0" "" "Zero"
  "49" "31" "00110001" "1" "" "One"
  "50" "32" "00110010" "2" "" "Two"
  "51" "33" "00110011" "3" "" "Three"
  "52" "34" "00110100" "4" "" "Four"
  "53" "35" "00110101" "5" "" "Five"
  "54" "36" "00110110" "6" "" "Six"
  "55" "37" "00110111" "7" "" "Seven"
  "56" "38" "00111000" "8" "" "Eight"
  "57" "39" "00111001" "9" "" "Nine"
  "58" "3A" "00111010" ":" "" "Colon"
  "59" "3B" "00111011" ";" "" "Semicolon"
  "60" "3C" "00111100" "<" "" "Less than"
  "61" "3D" "00111101" "=" "" "Equals"
  "62" "3E" "00111110" ">" "" "Greater than"
  "63" "3F" "00111111" "?" "" "Question mark"
  "64" "40" "01000000" "@" "" "At sign"
  "65" "41" "01000001" "A" "" "Uppercase A"
  "66" "42" "01000010" "B" "" "Uppercase B"
  "67" "43" "01000011" "C" "" "Uppercase C"
  "68" "44" "01000100" "D" "" "Uppercase D"
  "69" "45" "01000101" "E" "" "Uppercase E"
  "70" "46" "01000110" "F" "" "Uppercase F"
  "71" "47" "01000111" "G" "" "Uppercase G"
  "72" "48" "01001000" "H" "" "Uppercase H"
  "73" "49" "01001001" "I" "" "Uppercase I"
  "74" "4A" "01001010" "J" "" "Uppercase J"
  "75" "4B" "01001011" "K" "" "Uppercase K"
  "76" "4C" "01001100" "L" "" "Uppercase L"
  "77" "4D" "01001101" "M" "" "Uppercase M"
  "78" "4E" "01001110" "N" "" "Uppercase N"
  "79" "4F" "01001111" "O" "" "Uppercase O"
  "80" "50" "01010000" "P" "" "Uppercase P"
  "81" "51" "01010001" "Q" "" "Uppercase Q"
  "82" "52" "01010010" "R" "" "Uppercase R"
  "83" "53" "01010011" "S" "" "Uppercase S"
  "84" "54" "01010100" "T" "" "Uppercase T"
  "85" "55" "01010101" "U" "" "Uppercase U"
  "86" "56" "01010110" "V" "" "Uppercase V"
  "87" "57" "01010111" "W" "" "Uppercase W"
  "88" "58" "01011000" "X" "" "Uppercase X"
  "89" "59" "01011001" "Y" "" "Uppercase Y"
  "90" "5A" "01011010" "Z" "" "Uppercase Z"
  "91" "5B" "01011011" "[" "" "Opening bracket"
  "92" "5C" "01011100" "\\" "" "Backslash"
  "93" "5D" "01011101" "]" "" "Closing bracket"
  "94" "5E" "01011110" "^" "" "Caret - circumflex"
  "95" "5F" "01011111" "_" "" "Underscore"
  "96" "60" "01100000" '´' "" " Grave accent"
  "97" "61" "01100001" "a" "" "Lowercase a"
  "98" "62" "01100010" "b" "" "Lowercase b"
  "99" "63" "01100011" "c" "" "Lowercase c"
  "100" "64" "01100100" "d" "" "Lowercase d"
  "101" "65" "01100101" "e" "" "Lowercase e"
  "102" "66" "01100110" "f" "" "Lowercase f"
  "103" "67" "01100111" "g" "" "Lowercase g"
  "104" "68" "01101000" "h" "" "Lowercase h"
  "105" "69" "01101001" "i" "" "Lowercase i"
  "106" "6A" "01101010" "j" "" "Lowercase j"
  "107" "6B" "01101011" "k" "" "Lowercase k"
  "108" "6C" "01101100" "l" "" "Lowercase l"
  "109" "6D" "01101101" "m" "" "Lowercase m"
  "110" "6E" "01101110" "n" "" "Lowercase n"
  "111" "6F" "01101111" "o" "" "Lowercase o"
  "112" "70" "01110000" "p" "" "Lowercase p"
  "113" "71" "01110001" "q" "" "Lowercase q"
  "114" "72" "01110010" "r" "" "Lowercase r"
  "115" "73" "01110011" "s" "" "Lowercase s"
  "116" "74" "01110100" "t" "" "Lowercase t"
  "117" "75" "01110101" "u" "" "Lowercase u"
  "118" "76" "01110110" "v" "" "Lowercase v"
  "119" "77" "01110111" "w" "" "Lowercase w"
  "120" "78" "01111000" "x" "" "Lowercase x"
  "121" "79" "01111001" "y" "" "Lowercase y"
  "122" "7A" "01111010" "z" "" "Lowercase z"
  "123" "7B" "01111011" '{' "" "Opening brace"
  "124" "7C" "01111100" '|' "" "Vertical bar"
  "125" "7D" "01111101" '}' "" "Closing brace"
  "126" "7E" "01111110" '~' "" "Equivalency sign - tilde"
  "127" "7F" "01111111" "DEL" "" "Delete"
  "128" "80" "10000000" "€" "" "Euro sign"
  "129" "81" "10000001" "" "" "Unused"
  "130" "82" "10000010" "‚" "" "Single low-9 quotation mark"
  "131" "83" "10000011" "ƒ" "" "Latin small letter f with hook"
  "132" "84" "10000100" "„" "" "Double low-9 quotation mark"
  "133" "85" "10000101" "…" "" "Horizontal ellipsis"
  "134" "86" "10000110" "†" "" "Dagger"
  "135" "87" "10000111" "‡" "" "Double dagger"
  "136" "88" "10001000" "ˆ" "" "Modifier letter circumflex accent"
  "137" "89" "10001001" "‰" "" "Per mille sign"
  "138" "8A" "10001010" "Š" "" "Latin capital letter S with caron"
  "139" "8B" "10001011" "‹" "" "Single left-pointing angle quotation"
  "140" "8C" "10001100" "Œ" "" "Latin capital ligature OE"
  "141" "8D" "10001101" "" "" "Unused"
  "142" "8E" "10001110" "Ž" "" "Latin capital letter Z with caron"
  "143" "8F" "10001111" "" "" "Unused"
  "144" "90" "10010000" "" "" "Unused"
  "145" "91" "10010001" "‘" "" "Left single quotation mark"
  "146" "92" "10010010" "’" "" "Right single quotation mark"
  "147" "93" "10010011" "“" "" "Left double quotation mark"
  "148" "94" "10010100" "”" "" "Right double quotation mark"
  "149" "95" "10010101" "•" "" "Bullet"
  "150" "96" "10010110" "–" "" "En dash"
  "151" "97" "10010111" "—" "" "Em dash"
  "152" "98" "10011000" "˜" "" "Small tilde"
  "153" "99" "10011001" "™" "" "Trade mark sign"
  "154" "9A" "10011010" "š" "" "Latin small letter S with caron"
  "155" "9B" "10011011" "›" "" "Single right-pointing angle quotation mark"
  "156" "9C" "10011100" "œ" "" "Latin small ligature oe"
  "157" "9D" "10011101" "" "" "Unused"
  "158" "9E" "10011110" "ž" "" "Latin small letter z with caron"
  "159" "9F" "10011111" "Ÿ" "" "Latin capital letter Y with diaeresis"
  "160" "A0" "10100000" "NBSP" "" "Non-breaking space"
  "161" "A1" "10100001" "¡" "" "Inverted exclamation mark"
  "162" "A2" "10100010" "¢" "" "Cent sign"
  "163" "A3" "10100011" "£" "" "Pound sign"
  "164" "A4" "10100100" "¤" "" "Currency sign"
  "165" "A5" "10100101" "¥" "" "Yen sign"
  "166" "A6" "10100110" "¦" "" "Pipe, broken vertical bar"
  "167" "A7" "10100111" "§" "" "Section sign"
  "168" "A8" "10101000" "¨" "" "Spacing diaeresis - umlaut"
  "169" "A9" "10101001" "©" "" "Copyright sign"
  "170" "AA" "10101010" "ª" "" "Feminine ordinal indicator"
  "171" "AB" "10101011" "«" "" "Left double angle quotes"
  "172" "AC" "10101100" "¬" "" "Negation"
  "173" "AD" "10101101" "­SHY" "" "Soft hyphen"
  "174" "AE" "10101110" "®" "" "Registered trade mark sign"
  "175" "AF" "10101111" "¯" "" "Spacing macron - overline"
  "176" "B0" "10110000" "°" "" "Degree sign"
  "177" "B1" "10110001" "±" "" "Plus-or-minus sign"
  "178" "B2" "10110010" "²" "" "Superscript two - squared"
  "179" "B3" "10110011" "³" "" "Superscript three - cubed"
  "180" "B4" "10110100" "´" "" "Acute accent - spacing acute"
  "181" "B5" "10110101" "µ" "" "Micro sign"
  "182" "B6" "10110110" "¶" "" "Pilcrow sign - paragraph sign"
  "183" "B7" "10110111" "·" "" "Middle dot - Georgian comma"
  "184" "B8" "10111000" "¸" "" "Spacing cedilla"
  "185" "B9" "10111001" "¹" "" "Superscript one"
  "186" "BA" "10111010" "º" "" "Masculine ordinal indicator"
  "187" "BB" "10111011" "»" "" "Right double angle quotes"
  "188" "BC" "10111100" "¼" "" "Fraction one quarter"
  "189" "BD" "10111101" "½" "" "Fraction one half"
  "190" "BE" "10111110" "¾" "" "Fraction three quarters"
  "191" "BF" "10111111" "¿" "" "Inverted question mark"
  "192" "C0" "11000000" "À" "" "Latin capital letter A with grave"
  "193" "C1" "11000001" "Á" "" "Latin capital letter A with acute"
  "194" "C2" "11000010" "Â" "" "Latin capital letter A with circumflex"
  "195" "C3" "11000011" "Ã" "" "Latin capital letter A with tilde"
  "196" "C4" "11000100" "Ä" "" "Latin capital letter A with diaeresis"
  "197" "C5" "11000101" "Å" "" "Latin capital letter A with ring above"
  "198" "C6" "11000110" "Æ" "" "Latin capital letter AE"
  "199" "C7" "11000111" "Ç" "" "Latin capital letter C with cedilla"
  "200" "C8" "11001000" "È" "" "Latin capital letter E with grave"
  "201" "C9" "11001001" "É" "" "Latin capital letter E with acute"
  "202" "CA" "11001010" "Ê" "" "Latin capital letter E with circumflex"
  "203" "CB" "11001011" "Ë" "" "Latin capital letter E with diaeresis"
  "204" "CC" "11001100" "Ì" "" "Latin capital letter I with grave"
  "205" "CD" "11001101" "Í" "" "Latin capital letter I with acute"
  "206" "CE" "11001110" "Î" "" "Latin capital letter I with circumflex"
  "207" "CF" "11001111" "Ï" "" "Latin capital letter I with diaeresis"
  "208" "D0" "11010000" "Ð" "" "Latin capital letter ETH"
  "209" "D1" "11010001" "Ñ" "" "Latin capital letter N with tilde"
  "210" "D2" "11010010" "Ò" "" "Latin capital letter O with grave"
  "211" "D3" "11010011" "Ó" "" "Latin capital letter O with acute"
  "212" "D4" "11010100" "Ô" "" "Latin capital letter O with circumflex"
  "213" "D5" "11010101" "Õ" "" "Latin capital letter O with tilde"
  "214" "D6" "11010110" "Ö" "" "Latin capital letter O with diaeresis"
  "215" "D7" "11010111" "×" "" "Multiplication sign"
  "216" "D8" "11011000" "Ø" "" "Latin capital letter O with slash"
  "217" "D9" "11011001" "Ù" "" "Latin capital letter U with grave"
  "218" "DA" "11011010" "Ú" "" "Latin capital letter U with acute"
  "219" "DB" "11011011" "Û" "" "Latin capital letter U with circumflex"
  "220" "DC" "11011100" "Ü" "" "Latin capital letter U with diaeresis"
  "221" "DD" "11011101" "Ý" "" "Latin capital letter Y with acute"
  "222" "DE" "11011110" "Þ" "" "Latin capital letter THORN"
  "223" "DF" "11011111" "ß" "" "Latin small letter sharp s - ess-zed"
  "224" "E0" "11100000" "à" "" "Latin small letter a with grave"
  "225" "E1" "11100001" "á" "" "Latin small letter a with acute"
  "226" "E2" "11100010" "â" "" "Latin small letter a with circumflex"
  "227" "E3" "11100011" "ã" "" "Latin small letter a with tilde"
  "228" "E4" "11100100" "ä" "" "Latin small letter a with diaeresis"
  "229" "E5" "11100101" "å" "" "Latin small letter a with ring above"
  "230" "E6" "11100110" "æ" "" "Latin small letter ae"
  "231" "E7" "11100111" "ç" "" "Latin small letter c with cedilla"
  "232" "E8" "11101000" "è" "" "Latin small letter e with grave"
  "233" "E9" "11101001" "é" "" "Latin small letter e with acute"
  "234" "EA" "11101010" "ê" "" "Latin small letter e with circumflex"
  "235" "EB" "11101011" "ë" "" "Latin small letter e with diaeresis"
  "236" "EC" "11101100" "ì" "" "Latin small letter i with grave"
  "237" "ED" "11101101" "í" "" "Latin small letter i with acute"
  "238" "EE" "11101110" "î" "" "Latin small letter i with circumflex"
  "239" "EF" "11101111" "ï" "" "Latin small letter i with diaeresis"
  "240" "F0" "11110000" "ð" "" "Latin small letter eth"
  "241" "F1" "11110001" "ñ" "" "Latin small letter n with tilde"
  "242" "F2" "11110010" "ò" "" "Latin small letter o with grave"
  "243" "F3" "11110011" "ó" "" "Latin small letter o with acute"
  "244" "F4" "11110100" "ô" "" "Latin small letter o with circumflex"
  "245" "F5" "11110101" "õ" "" "Latin small letter o with tilde"
  "246" "F6" "11110110" "ö" "" "Latin small letter o with diaeresis"
  "247" "F7" "11110111" "÷" "" "Division sign"
  "248" "F8" "11111000" "ø" "" "Latin small letter o with slash"
  "249" "F9" "11111001" "ù" "" "Latin small letter u with grave"
  "250" "FA" "11111010" "ú" "" "Latin small letter u with acute"
  "251" "FB" "11111011" "û" "" "Latin small letter u with circumflex"
  "252" "FC" "11111100" "ü" "" "Latin small letter u with diaeresis"
  "253" "FD" "11111101" "ý" "" "Latin small letter y with acute"
  "254" "FE" "11111110" "þ" "" "Latin small letter thorn"
  "255" "FF" "11111111" "ÿ" "" "Latin small letter y with diaeresis"
)

bp_phh() {
  if [ -z "${BP_INIT_RUN}" ]; then
    bpInfo "Make sure to do load bp_init ( source $(realpath bp_init) )"
    echo
  fi
}

#---------------------------------------------------------------------
# Bashplate settings
#---------------------------------------------------------------------
bpInitSettings() {

  ##V Script version info
  BP_VERSION="1.10"

  ##V Usage info
  BP_USAGE="Usage: ${BP_SELF_NAME} command [option]"

  ##V Description text
  BP_DESC="Generate bash scripts from templates"

  ##V logfile (uncomment to use logfile)
  BP_LOGFILE=${BP_SELF_DIR}/${BP_SELF_NAME}.log

  ##V Lock file (uncomment to use lock file feature )
  BP_LOCK_FILE=/tmp/${BP_SELF_NAME}.lock

  ##V Logging options (uncomment to activate logging parameters)
  BP_LOG_OK=1
  BP_LOG_INFO=1
  BP_LOG_WARNING=1
  BP_LOG_ERROR=1
  BP_LOG_CRITICAL=1

  ##V Activate settings function (will create settings file when run)
  BP_CONF=1

}
#---------------------------------------------------------------------
# Bashplate Hooks
#---------------------------------------------------------------------

##V Default command (uncomment to use a default command )
DEFAULT_CMD_HOOK=help

##V Pre script hook, execute this function before every command
#PRE_SCRIPT_HOOK=

##V Post script hook, execute this function after every command
#POST_SCRIPT_HOOK=

##V Function to be executed before every other cmd except DEFAULT function
#PRE_CMD_HOOK=

##V Function to be executed after every other function except DEFAULT function
#POST_CMD_HOOK=

##V Function to be executed after information command
#POST_INFO_HOOK=

##V Function run before help command is executed
PRE_HELP_HOOK=bp_phh

##V Function run after help command is executed
#POST_HELP_HOOK=

#---------------------------------------------------------------------
# Signal traps
#---------------------------------------------------------------------

signalInt() {
  bpCleanUp
  exit "$BP_OK"
}

signalHup() {
  bpCleanUp
  exit "$BP_OK"
}

signalQuit() {
  echo "Quit"
  bpCleanUp
}

signalTerm() {
  echo "Term"
  bpCleanUp
}

signalErr() {
  echo
  echo
  bpError "Trace error Row: $2  Function: $1"
  echo
  bpCallStack "$*"
  bpExit 1
}

signalDbg() {
  echo "Debug Row: $2  Function: $1"
}

##C- IHELP Exit and cleanup

bpCallStack() { ##I Print out BASH call stack
  bpPrintLine "Call stack"
  echo
  local frame=0
  while caller "$frame" | sed -r -e "s/[0-9]*/${BP_C_VALUE}&${E_RESET}/"; do
    ((frame++))
  done
  echo "$*"
  bpPrintLine
}

bpCleanUp() {             ##I Cleanup function
  rm -f "${BP_LOCK_FILE}" # remove Lock file
  #  echo -e "${E_SHOW}"     # Turn on cursor if turned of
}

#
# $1 exit code, if not given exit code is 0=SUCCESS
#
bpExit() { ##I Function for safely exiting script
  bpCleanUp

  # execute postscript hook if existing
  if [ -n "$POST_SCRIPT_HOOK" ]; then
    ${POST_SCRIPT_HOOK}
  fi

  # Check if argument is given
  if [ -z "$1" ]; then
    exit "$BP_OK"
  else
    exit "$1"
  fi
}

bpErrorExit() { ##I Safely exit script with a error
  bpError "${1}"
  bpCleanUp
  exit 1
}

#---------------------------------------------------------------------
# ANSI escape codes
#---------------------------------------------------------------------

# Check if terminal is 16 color only
if [[ "linux rxvt-16color" = *${TERM}* ]]; then

  # ANSI foreground colors codes
  #
  E_BLACK=$'\e[30m'        # Black
  E_RED=$'\e[31m'          # Red
  E_GREEN=$'\e[32m'        # Green
  E_YELLOW=$'\e[33m'       # Yellow
  E_BLUE=$'\e[34m'         # Blue
  E_MAGENTA=$'\e[35m'      # Magenta
  E_CYAN=$'\e[36m'         # Cyan
  E_GRAY=$'\e[37m'         # Gray
  E_DARKGRAY=$'\e[1;30m'   # Dark Gray
  E_BR_RED=$'\e[1;31m'     # Bright Red
  E_BR_GREEN=$'\e[1;32m'   # Bright Green
  E_BR_YELLOW=$'\e[1;33m'  # Bright Yellow
  E_BR_BLUE=$'\e[1;34m'    # Bright Blue
  E_BR_MAGENTA=$'\e[1;35m' # Bright Magenta
  E_BR_CYAN=$'\e[1;36m'    # Bright Cyan
  E_WHITE=$'\e[1;37m'      # White

  # ANSI background color codes
  #
  E_BG_BLACK=$'\e[40m'      # Black
  E_BG_RED=$'\e[41m'        # Red
  E_BG_GREEN=$'\e[42m'      # Green
  E_BG_YELLOW=$'\e[43m'     # Yellow
  E_BG_BLUE=$'\e[44m'       # Blue
  E_BG_MAGENTA=$'\e[45m'    # Magenta
  E_BG_CYAN=$'\e[46m'       # Cyan
  E_BG_GRAY=$'\e[47m'       # Gray
  E_BG_DARK_GRAY=$'\e[40m'  # Dark gray
  E_BG_BR_RED=$'\e[41m'     # Bright Red
  E_BG_BR_GREEN=$'\e[42m'   # Bright Green
  E_BG_BR_YELLOW=$'\e[43m'  # Bright Yellow
  E_BG_BR_BLUE=$'\e[44m'    # Bright Blue
  E_BG_BR_MAGENTA=$'\e[45m' # Bright Magenta
  E_BG_BR_CYAN=$'\e[46m'    # Bright Cyan
  E_BG_WHITE=$'\e[47m'      # White

else

  # ANSI foreground colors codes
  #
  E_BLACK=$'\e[38:5:0m'       # Black
  E_RED=$'\e[38:5:1m'         # Red
  E_GREEN=$'\e[38:5:2m'       # Green
  E_YELLOW=$'\e[38:5:3m'      # Yellow
  E_BLUE=$'\e[38:5:4m'        # Blue
  E_MAGENTA=$'\e[38:5:5m'     # Magenta
  E_CYAN=$'\e[38:5:6m'        # Cyan
  E_GRAY=$'\e[38:5:7m'        # Gray
  E_DARKGRAY=$'\e[38:5:8m'    # Dark Gray
  E_BR_RED=$'\e[38:5:9m'      # Bright Red
  E_BR_GREEN=$'\e[38:5:10m'   # Bright Green
  E_BR_YELLOW=$'\e[38:5:11m'  # Bright Yellow
  E_BR_BLUE=$'\e[38:5:12m'    # Bright Blue
  E_BR_MAGENTA=$'\e[38:5:13m' # Bright Magenta
  E_BR_CYAN=$'\e[38:5:14m'    # Bright Cyan
  E_WHITE=$'\e[38:5:15m'      # White

  # ANSI background color codes
  #
  E_BG_BLACK=$'\e[48;5;0m'       # Black
  E_BG_RED=$'\e[48;5;1m'         # Red
  E_BG_GREEN=$'\e[48;5;2m'       # Green
  E_BG_YELLOW=$'\e[48;5;3m'      # Yellow
  E_BG_BLUE=$'\e[48;5;4m'        # Blue
  E_BG_MAGENTA=$'\e[48;5;5m'     # Magenta
  E_BG_CYAN=$'\e[48;5;6m'        # Cyan
  E_BG_GRAY=$'\e[48;5;7m'        # Gray
  E_BG_DARK_GRAY=$'\e[48;5;8m'   # Dark gray
  E_BG_BR_RED=$'\e[48;5;9m'      # Bright Red
  E_BG_BR_GREEN=$'\e[48;5;10m'   # Bright Green
  E_BG_BR_YELLOW=$'\e[48;5;11m'  # Bright Yellow
  E_BG_BR_BLUE=$'\e[48;5;12m'    # Bright Blue
  E_BG_BR_MAGENTA=$'\e[48;5;13m' # Bright Magenta
  E_BG_BR_CYAN=$'\e[48;5;14m'    # Bright Cyan
  E_BG_WHITE=$'\e[48;5;15m'      # White
fi

# ANSI underline color codes
#
# Not in standard. implemented in Kitty, VTE, mintty, etc.
#
E_UL_BLACK=$'\e[58;5;0m'       # Black
E_UL_RED=$'\e[58;5;1m'         # Red
E_UL_GREEN=$'\e[58;5;2m'       # Green
E_UL_YELLOW=$'\e[58;5;3m'      # Yellow
E_UL_BLUE=$'\e[58;5;4m'        # Blue
E_UL_MAGENTA=$'\e[58;5;5m'     # Magenta
E_UL_CYAN=$'\e[58;5;6m'        # Cyan
E_UL_GRAY=$'\e[58;5;7m'        # Gray
E_UL_DARKGRAY=$'\e[58;5;8m'    # Dark Gray
E_UL_BR_RED=$'\e[58;5;9m'      # Bright Red
E_UL_BR_GREEN=$'\e[58;5;10m'   # Bright Green
E_UL_BR_YELLOW=$'\e[58;5;11m'  # Bright Yellow
E_UL_BR_BLUE=$'\e[58;5;12m'    # Bright Blue
E_UL_BR_MAGENTA=$'\e[58;5;13m' # Bright Magenta
E_UL_BR_CYAN=$'\e[58;5;14m'    # Bright Cyan
E_UL_WHITE=$'\e[58;5;15m'      # White

# ANSI Text attributes
E_RESET=$'\e[0m'              # Clear all attributes
E_BOLD=$'\e[1m'               # Bold text
E_DIM=$'\e[2m'                # Dim(low intensity) text
E_ITALIC=$'\e[3m'             # Italic text
E_UNDERLINE=$'\e[4m'          # Underlined text
E_UNDERLINE_DOUBLE=$'\e[4:2m' # Double underline (limited support)
E_UNDERLINE_CURLY=$'\e[4:3m'  # Curly underline (limited support)
E_UNDERLINE_DOT=$'\e[4:4m'    # Dotted underline (limited support)
E_UNDERLINE_DASH=$'\e[4:5m'   # Dashed underline (limited support)
E_BLINK=$'\e[5m'              # Blinking text
E_RAPID_BLINK=$'\e[6m'        # Rapid blink (Limited support)
E_REVERSE=$'\e[7m'            # Reverse color
E_CROSSED=$'\e[9m'            # Crossed over text
E_FRAKTUR=$'\e[20m'           # Gothic (limited support)
E_FRAMED=$'\e[51m'            # Framed (limited support)
E_OVERLINED=$'\e[53m'         # Overlined text
E_SUPERSCRIPT=$'\e[73m'       # Superscript text (limited support)
E_SUBSCRIPT=$'\e[74m'         # Subscript text (limited support)

# ANSI cursor operations
#
E_RETURN=$'\e[F'  # Move cursor to begining of line
E_UP=$'\e[A'      # Move cursor one line up
E_DOWN=$'\e[B'    # Move cursor one line down
E_FORWARD=$'\e[C' # Move cursor forward
E_BACK=$'\e[D'    # Move cursor backward
E_HIDE=$'\e[?25l' # Hide cursor
E_SHOW=$'\e[?25h' # Show cursor

# Default Bashplate colortheme
BP_C_OK="${E_BR_GREEN}"
BP_C_INFO="${E_BR_CYAN}"
BP_C_DEBUG="${E_BG_GREEN}${E_WHITE}"
BP_C_WARNING="${E_BR_YELLOW}"
BP_C_ERROR="${E_BR_RED}"
BP_C_CRITICAL="${E_BG_RED}${E_WHITE}"
BP_C_LINE="${E_DARKGRAY}"
BP_C_LINETEXT="${E_YELLOW}"
BP_C_DESCRIPTION="${E_CYAN}"
BP_C_KEY="${E_BR_MAGENTA}"

BP_C_FILENAME="${E_BR_CYAN}"
BP_C_PATH="${E_CYAN}"
BP_C_URL_SCHEME="${E_DARKGRAY}"
# BP_C_URL_USER=""
# BP_C_URL_HOST=""
BP_C_TIME="${E_BR_MAGENTA}"
BP_C_DATE="${E_MAGENTA}"

BP_C_QUERY=$'\e[38;5;194m'
BP_C_QUERY_DEF=$'\e[38;5;240m'
BP_C_EMPHASIS=$'\e[38;5;255m'
BP_C_DEEMPHASIS=$'\e[38;5;250m'

# Shellscript colorize colors
BP_C_RESERVED="${E_RED}"
BP_C_COMMENT="${E_CYAN}"
BP_C_STRING="${E_GREEN}"
BP_C_VAR="${E_BR_YELLOW}"

# Separator line character
BP_LINE_CHAR="-"

# Exit codes
#
BP_OK=0 # successful termination

# Formating
#
BP_KEY_LENGTH=24
BP_LEFT_MARGIN=3
BP_RIGHT_MARGIN=3

#---------------------------------------------------------------------
# Bashplate internal functions
#---------------------------------------------------------------------

##C- IHELP Printing functions

#
# $1 text to be printed
# $2 text color
# $3 line color
# $4 middle character
#
bpPrintLineGeneric() { ##I Print text with adjusted line after with selectable colors
  len1="${#1}"
  len4="${#4}"

  echo -en "${2}${1}${4}${3}"
  if [ "${BP_LINE_CHAR}" != "" ]; then
    l=$((BP_COLUMNS - len1 - len4))
    seq -s"${BP_LINE_CHAR}" "${l}" | tr -d '[:digit:]'
    echo -en "${E_RESET}"
  else
    echo -e "${E_RESET}"
  fi
}

#
# $1 text to be printed
# $2 text color
# $3 line color
#
bpTextLineC() { ##I Print text with adjusted line after with selectable colors
  bpPrintLineGeneric "$1" "$2" "$3" " "
}

bpPrintLine() { ##I Print text with line
  if [ "${#1}" -eq 0 ]; then
    bpPrintLineGeneric "" "" "${BP_C_LINE}" ""
  else
    bpPrintLineGeneric "$1" "${BP_C_LINETEXT}" "${BP_C_LINE}" " "
  fi
}

#
# $1 key color
# $2 description color
# $3 key
# $4 description
# $5 key length override (optional)
#
bpPrintDescGeneric() { # Generic key/description printout function
  KEY_COLOR="$1"
  DESC_COLOR="$2"
  KEY="$3"
  DESC="$4"
  if [ -n "$5" ]; then
    KL="$5"
  else
    KL=${BP_KEY_LENGTH}
  fi

  if ((${#4} == 0)); then
    printf "${1}  %-${KL}.${KL}s${E_RESET} ${2}%s${E_RESET}\n" "$3" ""
  fi

  len=${#}
  a=$(("${BP_COLUMNS}" - "$KL" - "$BP_RIGHT_MARGIN"))
  #LINES=$(fmt -s -w"${a}" <<<"$4")
  LINES=$(fold -w"${a}" <<<"$DESC")

  IFS=$'\n'
  L1=0
  for line in ${LINES}; do
    if [ "${L1}" -eq 0 ]; then                # First line
      if ((${#KEY} > "$BP_KEY_LENGTH")); then # Oversized key
        printf "${KEY_COLOR}  %-${KL}s${E_RESET}\n" "$KEY"
        printf "${KEY_COLOR}  %-${KL}.${KL}s${E_RESET} ${DESC_COLOR}%s${E_RESET}\n" "" "$line"
      else # Normal key
        printf "${KEY_COLOR}  %-${KL}.${KL}s${E_RESET} ${DESC_COLOR}%s${E_RESET}\n" "$KEY" "$line"
      fi
      L1=1
    else # Rest of the lines
      printf "${KEY_COLOR}  %-${KL}.${KL}s${E_RESET} ${DESC_COLOR}%s${E_RESET}\n" "" "$line"
    fi
  done
}

#
# $1 key
# $2 description
# $3 (optional) left alignment
#
bpPrintDesc() { ##I Print key description
  bpPrintDescGeneric "${BP_C_KEY}" "${BP_C_DESCRIPTION}" "$1" "$2" "$3"
}

bpPrintDescAlt() {
  bpPrintDescGeneric "${E_DARKGRAY}" "${BP_C_DESCRIPTION}" "$1" "$2"
}

#
# $1 variablename
# $2 alternative key text (optional)
# $3 alternative value text (optional)
#
bpPrintVar() { ##I Print variable value and description
  VAR="$1"

  if [ -n "$2" ]; then
    KEY=${2}
  else
    KEY="${VAR}"
  fi

  if [ "${!VAR}" ]; then
    if [ -n "$3" ]; then
      VAL=${3}
    else
      VAL="${!VAR}"
    fi

    bpPrintDesc "${KEY}" "${VAL}"
  else
    bpPrintDesc "${KEY}" "${BP_C_ERROR}N/A"
  fi
}

#
# Colorize string containing filename
#
# $1 string with filename to colorize
# ret colorized string
#
bpColorizeFile() { ##I Colorize string containing filename
  echo "${BP_C_PATH}$(dirname "$1")/${BP_C_FILENAME}$(basename "$1")${E_RESET}"
}

#
# $1 string with url to colorize
# ret colorized string
#
# todo: give username and port own color
#
bpColorizeUrl() { ##I Colorize string containing URL
  URL=$(sed -r -e "s/^.*\/\///" <<<"$1")
  SCHEME=$(sed -r -e "s/:\/.*//" <<<"$1")
  # USERNAME=$(sed -r -e "s/@.*//" <<<"$URL")
  # PORT=$(sed -r -e "s/^:[0-9]*/XXX/" <<<"$URL")
  # echo -e "Username: $USERNAME"
  # echo -e "Port: $PORT"

  #URL=$(echo -n "$1" | sed -r -e "s/^.*\/\///")
  #SCHEME=$(echo -n "$1" | sed -r -e "s/:\/.*//")

  echo -e -n "${BP_C_URL_SCHEME}${SCHEME}${E_RESET}://$(bpColorizeFile "${URL}")"
}

#
# $1 string to be filtered
#
bpFilterEscape() { ##I Filter escape characters from string
  echo "$1" | sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g"
}

##C- IHELP File operations

#
# $1 directory to change to
#
bpCd() { ##I Safe cd function (exits on fail)
  cd "$1" || bpExit "Failed to cd to [$1]"
}

#
# $1 Directory to be created
#
bpMkDir() { ##I Create a directory if it does not exist
  if [ ! -d "$1" ]; then
    if mkdir -p "$1"; then
      bpOk "Creating directory $(bpColorizeFile "${1}")."
      return 0
    else
      bpError "Failed to create directory $(bpColorizeFile "${1}")."
      return 1
    fi
  fi
}

#
# $1 target file/dir
# $2 link
#
bpLn() { ##I Create symbolic link
  if [ ! -L "$1" ]; then
    if ln -sf "${1}" "${2}"; then
      bpOk "Creating link $(bpColorizeFile "${2}")."
      return 0
    else
      bpError "Failed to create link $(bpColorizeFile "${2}")."
      return 1
    fi
  fi
}

#
# $1 file(s) to be copied
# $2 destination
#
bpCp() { ##I Copy file(s)
  if cp -rf "$@"; then
    bpOk "Copying $(bpColorizeFile "${1}") to $(bpColorizeFile "${2}")"
    return 0
  else
    bpError "Failed copying $(bpColorizeFile "${1}") to $(bpColorizeFile "${2}")"
    return 1
  fi
}

#
# $1 file(s) to be moved
# $2 destination
#
bpMv() { ##I Move file(s)
  if mv "$1" "$2"; then
    bpOk "Moving file $(bpColorizeFile "${1}") to $(bpColorizeFile "${2}")."
    return 0
  else
    bpError "Failed moving file $(bpColorizeFile "${1}") to $(bpColorizeFile "${2}")."
    return 1
  fi
}

#
# $1 file(s) to be removed
#
bpRm() { ##I Remove file(s)
  if rm -rf "${1}"; then
    bpOk "Removing file $(bpColorizeFile "${1}")."
    return 0
  else
    bpError "Failed removing file $(bpColorizeFile "${1}")."
    return 1
  fi
}

#
# $1 file to be backed up
#
bpBackup() { ##I Make backup of file
  BF="${1}_$(date +"%Y%m%d")-$(date +"%H%M%S").bak"

  if cp -rf "$1" "${BF}"; then
    bpOk "Backing up file $(bpColorizeFile "$1") to $(bpColorizeFile "${BF}")."
    return 0
  else
    bpError "Failed backing up file $(bpColorizeFile "$1") to $(bpColorizeFile "${BF}")."
    return 1
  fi
}

##C- IHELP File editing

#
# $1 file
# $2 text to replace
# $3 new text
#
bpReplace() { ##I Replace all ocurances of text in file
  sed -i -e "s/${2}/${3}/g" "$1"
}

#
# $1 file
# $2 pattern matching line
# $3 new text
#
bpReplaceLine() { ##I Replace entire line matching pattern
  sed -i -e "0,/${2}/s/${2}.*/${3}/" "${1}"
}

#
# $1 file
# $2 line to append
#
bpAppendIfNoSuchLine() { ##I Append a line if it does not exist in file
  grep -q -F "$2" "$1" || echo "$2" >>"$1"
}

#
# $1 file
# $2 string
#
bpRemoveLineContaining() { ##I Remove line in file if it contains given string
  grep -v "$2" "$1" >"${1}_tmp"
  mv -f "${1}_tmp" "${1}"
}

#
# $1 file
# $2 string
# return true if existing
#
bpStrExist() { ##I Check if string exist in file
  if [ ! -f "$1" ]; then
    return 1
  fi

  if grep -q -F "$2" "$1"; then
    return 0
  else
    return 1
  fi
}

#
# $1 file to open in editor
# $2 override editor (optional)
#
bpEdit() { ##I Open file in editor set by BP_EDIT variable

  if [ -n "$2" ]; then
    bpRun "$2" "$1"
    return 0
  fi

  if [ -n "$BP_EDITOR" ]; then
    bpRun "${BP_EDITOR}" "${1}"
  else
    bpError "BP_EDITOR variable not set, can't open file ${1}"
  fi
}

#
# $1 file
# $2 start marker
# $3 end marker
#
bpGetSection() { ##I Get text from file between two markers
  grep -A 10000 -m 1 "$2" <"$1" | grep -B 10000 -m 1 "$3" | grep -v "$2" | grep -v "$3"
}

#
# $1 File to import
#
bpImport() { ## Import file into variable
  if [ -f "$1" ]; then
    cat "$1"
  fi
}

#
# $1 file
# $2 match
# $3 text to insert
#
bpInsert() { ##I Insert text into file
  a=$(grep -A 10000 "$2" <"$1" | grep -v "$2")
  b=$(grep -B 10000 "$2" <"$1" | grep -v "$2")

  echo "$b" "$3" "$a" >|"$1"
}

##C- IHELP Input

#
# $1  Question string
# $2  Default value
# return string read from cmdline/default if enter pressed
#
bpReadGeneric() { ##I Read from commandline
  QUERY="$1"
  DEFAULT="$2"

  read -er -i "$DEFAULT" -p "${BP_C_QUERY}${1}${E_RESET} > " RESULT
  if [ "${RESULT}" == "" ]; then
    RESULT="${2}"
  fi
  echo "${RESULT}"
}

#
# $1  Question string
# $2  Default value
# return string read from cmdline/default if enter pressed
#
bpReadStr() { ##I Read string from commandline
  QUERY="$1"
  DEFAULT="$2"

  RESULT=$(bpReadGeneric "$QUERY" "$DEFAULT")
  bpLogInfo "User entered: $RESULT  ($QUERY)"
  echo "${RESULT}"
}

#
# $1  Question string
# $2  Default value
# $3  min value
# $4  max value
# return integer read from cmdline/default if enter pressed
#
bpReadInt() { ##I Read integer from commandline
  QUERY="$1"
  DEFAULT="$2"
  MIN="$3"
  MAX="$4"

  RANGE=""
  if [ -n "$MIN" ] || [ -n "$MAX" ]; then
    RANGE=" ${BP_C_QUERY_DEF}[${E_RESET}$3-$4${BP_C_QUERY_DEF}]${E_RESET}"
  fi

  while true; do
    read -er -i "$DEFAULT" -p "${BP_C_QUERY}${1}${E_RESET}${RANGE} > " RESULT

    if [ "$RESULT" -eq "$RESULT" ] 2>/dev/null; then

      if [ -n "${RANGE}" ]; then
        #if [ -n "$MIN" ] && [ -n "$MAX" ]; then
        if [ $((RESULT)) -ge "$MIN" ] && [ $((RESULT)) -le "$MAX" ]; then
          break
        fi
      else
        break
      fi
    fi
  done
  bpLogInfo "User entered: $RESULT  ($QUERY)"
  echo "${RESULT}"
}

#
# $1 question text
# $2 default answer 0 = yes, 1 = no
# return 0 = Yes, 1=No
#
bpReadBool() { ##I Ask yes/no question generic
  QUERY="$1"
  DEFAULT="$2"
  while true; do

    if [ "$2" -eq 1 ]; then
      yn=$(bpReadGeneric "${BP_C_QUERY}${1}${E_RESET} ${BP_C_QUERY_DEF}[${BP_C_DEEMPHASIS}y${BP_C_QUERY_DEF}/${BP_C_EMPHASIS}N${BP_C_QUERY_DEF}]${E_RESET}")
    else
      yn=$(bpReadGeneric "${BP_C_QUERY}${1}${E_RESET} ${BP_C_QUERY_DEF}[${E_RESET}${BP_C_EMPHASIS}Y${BP_C_QUERY_DEF}/${BP_C_DEEMPHASIS}n${BP_C_QUERY_DEF}]${E_RESET}")
    fi

    case "$yn" in
    [Yy]*)
      bpLogInfo "User entered: Yes  ($QUERY)"
      return 0
      break
      ;;
    [Nn]*)
      bpLogInfo "User entered: No  ($QUERY)"
      return 1
      break
      ;;
    "")
      if [ "$2" -eq 0 ]; then
        bpLogInfo "User entered: Yes  ($QUERY)"
      else
        bpLogInfo "User entered: No  ($QUERY)"
      fi
      return "$2"
      break
      ;;
    *) echo "Please answer yes or no." ;;
    esac
  done
}

#
# $1 Question text
# return 0 = Yes, 1=No
#
bpReadBoolDY() { ##I Ask yes/no question default yes
  bpReadBool "$1" 0
  return $?
}

#
# $1 Question text
# return 0 = Yes, 1=No
#
bpReadBoolDN() { ##I Ask yes/no question default no
  bpReadBool "$1" 1
  return $?
}

bpPrintChoiceList() { # Print items in selection list
  echo
  arr=("${@:2}")
  len=${#arr[@]}
  i=1
  while [ "$i" -lt "$len" ]; do
    key=${arr[$i]}
    ((i++))
    val=${arr[$i]}
    ((i++))
    desc=${arr[$i]}
    ((i++))

    if [ "$key" == "$1" ]; then
      default=">"
    else
      default=" "
    fi

    if [ "${desc}" == ":" ]; then
      printf "%1s ${BP_C_KEY}%-7s  ${BP_C_DESCRIPTION}%s${E_RESET}\n" "$default" "$key" "$val"
    else
      printf "%1s ${BP_C_KEY}%-7s  ${BP_C_DESCRIPTION}%s${E_RESET}\n" "$default" "$key" "$desc"
    fi
  done
}

#
# Select from list of choices
#
# $1 Default value
# $2 Question
# $* Array of choices
#
# Return: bpReturn
#
# Example choice list.
# list=(
#  "a" ":" "Choice A"
#  "b" ":" "Choice B"
#  "c" ":" "Choice C"
# )
bpSelectFromList() { ##I Select from list
  QUERY="$2"
  while true; do
    bpPrintChoiceList "$1" "${@:2}"
    echo
    x=$(bpReadGeneric "$2" "$1")

    arr=("${@}")
    len=${#arr[@]}
    i=2
    while [ "$i" -lt "$len" ]; do
      key=${arr[$i]}
      ((i++))
      val=${arr[$i]}
      ((i++))
      ((i++))
      if [ "$key" == "$x" ]; then
        if [ "$val" == ":" ]; then
          bpReturn="${key}"
        else
          bpReturn="${val}"
        fi
        bpLogInfo "User entered: $bpReturn  ($QUERY)"
        return 0
      fi
    done
  done
}

# Settings file ------------------------------------------------------

##C- BP_CONF Bashplate config file
##C- IHELP Bashplate config file

#
# $1 config file
# $2 key
# $3 value
# $4 description
#
bpAddSetting() { ##I Add setting to config file
  if ! bpStrExist "${1}" "${2}"; then
    {
      echo "# ${4}"
      echo "${2}=\"${3}\""
      echo
    } >>"${1}"

    bpOk "Added setting \"$2=$3\""
  fi
}

# Change setting in config file (key value pair)
#
# $1 config file
# $2 key
# $3 value
# $4 description
#
bpChangeSetting() { ##I Change setting in config file
  FILE="$1"
  KEY="$2"
  VAL="$3"
  DESC="$4"
  if ! bpStrExist "${1}" "${KEY}"; then
    bpAddSetting "$FILE" "$KEY" "$VAL" "$DESC"
  fi
  sed -i "s/^\(${KEY}\s*=\s*\).*\$/\1${VAL}/" "${FILE}"
  bpOk "Changing ${KEY} to ${VAL}"
}

#
# $1 key
# $2 config array
#
bpConfGetDesc() { ##I Get config desription
  arr=("${@:1}")
  len=${#arr[@]}
  bpReturn=""
  i=1
  while [ "$i" -lt "$len" ]; do
    key=${arr[$i]}
    ((i++))
    def=${arr[$i]}
    ((i++))
    desc=${arr[$i]}
    ((i++))
    #echo "$key"
    if [ "$key" == "$1" ]; then
      echo "$desc"
      return 0
    fi
  done
  return 1
}

#
# $1 key
# $2 value
# $3 config array
#
bpConfChangeSetting() {
  KEY="$1"
  VAL="$2"
  CONF=("${@:2}")
  FILE=${CONF[1]}
  DESC=$(bpConfGetDesc "$KEY" "${CONF[@]}")

  if ! bpConfInList "$KEY" "${CONF[@]}"; then
    bpError "\"$KEY\" is not a valid setting"
    return
  fi

  if ! bpStrExist "${FILE}" "${KEY}"; then
    bpAddSetting "${FILE}" "$KEY" "$VAL" "${DESC}"
    return "$BP_OK"
  fi

  bpChangeSetting "$FILE" "$KEY" "$VAL" "$DESC"
}

#
# $1 File
# $2 Headertext
# $3 config array
#
bpConfCreate() { ##I Create configuration file
  FILE="$1"
  bpMkDir "${BP_CONFIG_DIR}"
  bpMkDir "${BP_CONFIG_PATHS}"
  bpMkDir "${BP_CONFIG_MODULES}"
  {
    echo "# "
    echo "# $2"
    echo "# "
    echo
  } >>"${FILE}"

  arr=("${@:2}")
  len=${#arr[@]}
  i=1
  while [ "$i" -lt "$len" ]; do
    key=${arr[$i]}
    ((i++))
    default=${arr[$i]}
    ((i++))
    desc=${arr[$i]}
    ((i++))
    bpAddSetting "$FILE" "$key" "$default" "$desc"
  done
}

#
# $1 Config file
#
bpConfLoad() { ##I Load config file
  if [ -n "${1}" ]; then
    if [ ! -e "${1}" ]; then
      bpConfCreate "${@}"
    fi
    source "${1}"
  fi
}

#
# $1 key
# $2 config array
#
bpConfInList() { ##I Check if key exist in config file list
  arr=("${@:1}")
  len=${#arr[@]}
  bpReturn=""
  i=3
  while [ "$i" -lt "$len" ]; do
    key=${arr[$i]}
    ((i++))
    def=${arr[$i]}
    ((i++))
    desc=${arr[$i]}
    ((i++))
    #echo "Key = $key  Default = $def  Desc = $desc"
    if [ "$key" == "$1" ]; then
      bpReturn="$key"
      return 0
    fi
  done
  return 1
}

bpConfPrint() { ##I Print settings in config list
  echo
  bpPrintDesc "Config file" "$(bpColorizeFile "$3")"
  echo
  arr=("${@:4}")
  i=1
  while [ "$i" -lt ${#arr[@]} ]; do
    KEY=${arr[$i]}
    ((i++))
    DEF=${arr[$i]}
    ((i++))
    DESC=${arr[$i]}
    ((i++))
    printf "%s%s\n" "${E_DARKGRAY}" "${DESC}"
    bpPrintVar "$KEY"
  done
}

bpset() { ##C BP_CONF Change setting in bp config file
  if [ -z "$2" ]; then
    bpConfPrint "" "" "${BP_CONFIG_LIST[@]}"
    return
  fi
  if bpConfInList "$2" "${BP_CONFIG_LIST[@]}"; then
    bpChangeSetting "${BP_CONFIG_FILE}" "${bpReturn}" "\"${3}\""
    return
  fi
  bpError "\"$2\" is not a valid setting"
}

##C- IHELP Bashrc path/module handling

bpLsPaths() { ##I List paths
  shopt -s nullglob dotglob
  for p in "${BP_CONFIG_PATHS}"/*; do
    echo "A: $(readlink "${p}")"
  done
}

#
# $1 directory to add to path
#
bpAddPath() { ##I Add dir to PATH variable
  ll=$(echo "${1}" | sed -e 's/\//_/g')

  bpInfo "Adding PATH \"${2}\""
  if [ ! -L "$1" ]; then
    bpLn "${1}" "${BP_CONFIG_PATHS}/${ll}"
  fi
}

bpRmPath() { ##I Remove path
  bpRm "${BP_CONFIG_PATHS}/${1}"
}

bpLsModules() { ##I List modules
  shopt -s nullglob dotglob
  for p in "${BP_CONFIG_MODULES}"/*; do
    readlink "${p}"
  done
}

bpAddModule() { ##I Add init script to
  m=$(realpath "${1}")
  if [ ! -L "$m" ]; then
    rm -f "${BP_CONFIG_MODULES}/$(basename "${m}")"
    bpLn "$m" "${BP_CONFIG_MODULES}/."
  fi
}

bpRmModule() { ##I Remove module
  bpRm "${BP_CONFIG_MODULES}/${1}"
}

##-

# Logging ---------------------------------------------------------

##C- IHELP Log functions

#
# Function logging to file
#
# $1 String to log to file
#
bpLog() { ##I Log to file command
  # check for BP_LOGFILE variable
  if [ -n "$BP_LOGFILE" ]; then
    ts=$(date +"%Y-%m-%d %H:%M:%S")
    bpFilterEscape "$ts $1" >>"${BP_LOGFILE}"
  fi
}

bpLogOk() { ##I Log Ok message to file
  bpLog "[ Ok ] $1"
}

bpLogInfo() { ##I Log Info message to file
  bpLog "[Info] $1"
}

bpLogDebug() { ##I Log Info message to file
  bpLog "[Debg] $1"
}

bpLogWarning() { ##I Log Warning message to file
  bpLog "[Warn] $1"
}

bpLogError() { ##I Log Error message to file
  bpLog "[Erro] $1"
}

bpLogCritical() { ##I Log Critical message to file
  bpLog "[Crit] $1"
}

log() { ##C BP_LOGFILE View logfile
  if [ -n "$BP_LOGFILE" ]; then
    if [ -f "${BP_LOGFILE}" ]; then # Check that logfile exists
      D=$(sed -r -e "s|\[Info\]|\[\\${BP_C_INFO}Info\\${E_RESET}\]|" \
        -e "s|\[Warn\]|\[\\${BP_C_WARNING}Warn\\${E_RESET}\]|" \
        -e "s|\[Erro\]|\[\\${BP_C_ERROR}Erro\\${E_RESET}\]|" \
        -e "s|\[ Ok \]|\[\\${BP_C_OK} Ok \\${E_RESET}\]|" \
        -e "s/[-0-9]+/\\${BP_C_DATE}&\\${E_RESET}/1" \
        -e "s/[:0-9]+/\\${BP_C_TIME}&\\${E_RESET}/6" \
        -e "s|\[Crit\]|\[\\${E_BG_RED}\\${E_WHITE}Crit\\${E_RESET}\]|" <"${BP_LOGFILE}")
      echo -e "$D"
    fi
  else
    bpInfo "Logging is not activated"
    bpExit
  fi
}

mlog() { ##C BP_LOGFILE Monitor logfile
  if [ -n "$BP_LOGFILE" ]; then
    if [ -f "${BP_LOGFILE}" ]; then # Check that logfile exists
      tail -f "${BP_LOGFILE}" | sed -r -e "s|\[Info\]|\[\\${BP_C_INFO}Info\\${E_RESET}\]|" \
        -e "s|\[Warn\]|\[\\${BP_C_WARNING}Warn\\${E_RESET}\]|" \
        -e "s|\[Erro\]|\[\\${BP_C_ERROR}Erro\\${E_RESET}\]|" \
        -e "s|\[ Ok \]|\[\\${BP_C_OK} Ok \\${E_RESET}\]|" \
        -e "s/[-0-9]+/\\${E_GREEN}&\\${E_RESET}/1" \
        -e "s/[:0-9]+/\\${E_BR_GREEN}&\\${E_RESET}/6" \
        -e "s|\[Crit\]|\[\\${E_BG_RED}\\${E_WHITE}Crit\\${E_RESET}\]|"
    fi
  else
    bpInfo "Logging is not activated"
    bpExit
  fi
}

##C- IHELP Message

bpOk() { ##I Success message
  if [ -n "$BP_LOG_OK" ]; then
    bpLogOk "$1"
  fi
  echo -e "[${BP_C_OK}Ok${E_RESET}] $1"
}

bpInfo() { ##I Info message
  if [ -n "$BP_LOG_INFO" ]; then
    bpLogInfo "$1"
  fi
  echo -e "[${BP_C_INFO}Info${E_RESET}] $1"
}

bpDebug() { ##I Debug message
  if [ -z "$BP_DEBUG" ]; then
    return
  fi
  if [ -n "$BP_LOG_INFO" ]; then
    bpLogDebug "$1"
  fi

  echo -e "[${BP_C_DEBUG}Dbg${E_RESET}] $1"
}

bpWarning() { ##I Warning message
  if [ -n "$BP_LOG_WARNING" ]; then
    bpLogWarning "$1"
  fi
  echo -e "[${BP_C_WARNING}Warning${E_RESET}] $1"
}

bpError() { ##I Error message
  if [ -n "$BP_LOG_ERROR" ]; then
    bpLogError "$1"
  fi
  echo -e "[${BP_C_ERROR}Error${E_RESET}] $1"
}

bpCritical() { ##I Critical error message
  if [ -n "$BP_LOG_CRITICAL" ]; then
    bpLogCritical "$1"
  fi
  echo -e "[${BP_C_CRITICAL}Critical${E_RESET}] $1"
  bpExit
}

# Various  ---------------------------------------------------------

##C- IHELP Assert

bpAssertRoot() { ##I Assert that user is root
  if [ "$(whoami)" != root ]; then
    bpError "Must be root to use this command."
    bpExit "1"
  fi
}

bpAssertNoLockFile() { ##I Assert that lockfile is not present
  if [ -n "$BP_LOCK_FILE" ]; then
    if [ -f "$BP_LOCK_FILE" ]; then
      bpError "Script is already running. (${BP_LOCK_FILE})"
      exit "1" # do not use bpExit because lock file belongs to prexsisting process
    fi
    touch "$BP_LOCK_FILE"
  fi
}

#
# $1 string list of programs that are required
#
bpAssertProgs() { ##I Assert that required programs are available on the system
  things=("$@")
  e=0
  for thing in "${things[@]}"; do
    hash "$thing" 2>&- ||
      {
        bpError "Required program \"$thing\" not found."
        e=1
      }
  done
  if [ "$e" -eq 1 ]; then
    bpExit 1
  fi
}

##C- IHELP Misc

#
# $1 command to check
#
bpHasCmd() { ##I Check whether a command exists in path and is executable
  if [ -x "$(command -v "${1}")" ]; then
    return 0
  else
    return 1
  fi
}

bpIsFunction() { ##I Check if and identifier is declared as a function
  if [ "$(type -t "$1")" == "function" ]; then
    return 0
  fi
  return 1
}

#
# Filter out function from script file
#
# $1 file
# $2 function
#
bpGetFunction() {
  grep --no-filename -A 60 "$1" -e "${2}()" | grep -B 60 -m 1 -x "}"
}

#
# $1 command to execute
#
bpRun() { ##I Execute command
  if ! bpHasCmd "${1}"; then
    bpError "Could not execute $1, command does not exist!"
    return 1
  fi

  "$@"
  return $?
}

##C- IHELP Debug/Controll

icheck() { ##I Run shellcheck on script
  bpAssertProgs "shellcheck"
  shellcheck "$0"
}

irt() { ##I Remove tabs from script
  sed -i -e 's/\t/  /g' "${BP_SELF_DIR}/${BP_SELF}"
}

##C- IHELP Help & info

printCommand() {
  IFS=$' '
  read -r -a LINE <<<"$1"
  DESC="${LINE[*]:3}"
  bpPrintDesc "${LINE[0]}" "${DESC}"
}

printCondCommand() {
  IFS=$' '
  read -r -a LINE <<<"$1"
  DESC="${LINE[*]:4}"
  COND=${LINE[3]}

  if [ -n "$IHELP" ] && [ "$COND" != "IHELP" ]; then
    return
  fi

  if [ -n "${!COND}" ]; then
    bpPrintDesc "${LINE[0]}" "${DESC}"
    return
  fi

  if [ "$2" -eq 1 ]; then
    bpPrintDescAlt "${LINE[0]}" "${DESC}"
  fi

}

printNamedLine() {
  IFS=$' '
  read -r -a LINE <<<"$1"
  bpPrintLine "${LINE[*]:1}"
}

printCondNamedLine() {
  IFS=$' '
  read -r -a LINE <<<"$1"
  DESC=${LINE[*]:2}
  COND=${LINE[1]}

  if [ -n "$IHELP" ] && [ "$COND" != "IHELP" ]; then
    return
  fi

  if [ -n "${!COND}" ]; then
    bpPrintLine "$DESC"
  fi
}

help() { ##D Print help information
  echo "$BP_USAGE"
  echo -e "$BP_DESC"
  echo

  BP_HELP=1

  if [ ! -e "${BP_CONFIG_DIR}" ] && [ -n "${BP_CONFIG}" ]; then
    BPINIT=1
  fi

  # bpExecHook "PRE_HELP_HOOK"
  if [ -n "$PRE_HELP_HOOK" ]; then
    "${PRE_HELP_HOOK}"
  fi

  IFS=$'\n'
  SC="$1"
  LINES=$(grep -h '##' "$0" | grep -v -e 'grep' -e '##I' -e '##V' -e '\*##C' -e '\*##C-' -e '\"##' -e '##-//' -e 'LINE' -e 'printLine')
  LINES="${LINES//()/}"

  for LINE in ${LINES}; do
    case "$LINE" in
    *"##-"*) printNamedLine "$LINE" ;;
    *"##C-"*) printCondNamedLine "$LINE" ;;
    *"##CV"*) printCondCommand "$LINE" 1 ;;
    *"##C"*) printCondCommand "$LINE" 0 ;;
    *"##D"*) printCommand "$LINE" '##D' ;;
    *) ;;

    esac
  done

  if [ -n "$POST_HELP_HOOK" ]; then
    "${POST_HELP_HOOK}"
  fi
}

#
# $1 command
#
ihelp() { ##I Print internal help information

  # Singe command documentation
  if [ "$2" != "" ]; then
    echo
    bpPrintLine "$2"
    echo
    echo "#"
    echo -n "# "
    grep --no-filename "$0" -e "${2}()" | sed -n -e 's/^.*##I //p'
    grep --no-filename -B 8 "$0" -e "${2}()" | grep "#" | grep -v "##"
    bpPrintLine
    bpExit
  fi

  IFS=$'\n'
  SC="$1"

  IHELP=1      # Force ihelp documentations
  BP_LOGFILE=1 # Force log documentation

  LINES=$(grep -h '##[C|I]' "$0" | grep -v -e 'grep' -e '\*"##[ A-Z]"\*' -e 'LINE' -e 'printNamedLine' -e 'awk' -e 'bpPrintDesc' -e 'name')
  LINES=$(echo -e "$LINES" | sed -s 's/()//g')

  for LINE in ${LINES}; do
    case "$LINE" in
    *"##C-"*) printCondNamedLine "$LINE" ;;
    *"##I"*) printCommand "$LINE" '##I' ;;
    *"##C"*) printCondCommand "$LINE" 0 ;;
    *) ;;

    esac
  done

  bpPrintLine "Bashplates comments"
  bpPrintDesc "##D Description" "Subcommand information comment (shown with help)"
  bpPrintDesc "##C COND Description" "Conditional subcommand comment (shown with help)"
  bpPrintDesc "##I Description" "Internal function comment (shown with ihelp)"
  bpPrintDesc "##- [Text]" "Separator line (shown with help)"
  bpPrintDesc "##C- COND [Text]" "Conditional separator line (shown with help)"
  bpPrintLine
}

iinfo() { ##I Show information about script
  bpPrintLine "Script information"
  bpPrintVar BP_SELF "Script" "$(bpColorizeFile "${BP_SELF_DIR}/${BP_SELF}")"
  bpPrintVar BP_VERSION "Script version"
  bpPrintVar BP_TEMPLATE_VERSION "Template version"
  bpPrintVar BP_CONFIG "Bashplate settings file" "$(bpColorizeFile "${BP_CONFIG}")"
  bpPrintVar BP_LOGFILE "Log file" "$(bpColorizeFile "${BP_LOGFILE}")"
  bpPrintVar BP_LOCK_FILE "Lock file" "$(bpColorizeFile "${BP_LOCK_FILE}")"
  bpPrintVar DEFAULT_CMD_HOOK "Default function"
  bpPrintDesc "PID" $$
  bpPrintVar BP_DATE "Date"
  bpPrintVar BP_TIME "Time"
  bpPrintVar TERM "Terminal"
  bpPrintVar BP_COLUMNS "Terminal columns"
  bpPrintVar BP_LINES "Terminal lines"

  if [ -n "${POST_INFO_HOOK}" ]; then
    bpPrintLine "App. information"
    ${POST_INFO_HOOK}
  fi

  if [ -z "$BP_CONF" ]; then
    bpPrintLine
    return
  fi
  bpPrintLine "Bashplate config"
  i=2
  while [ "$i" -lt ${#BP_CONFIG_LIST[@]} ]; do
    KEY=${BP_CONFIG_LIST[$i]}
    ((i++))
    ((i++))
    ((i++))
    bpPrintVar "$KEY"
  done

  bpPrintLine
}

iview() { ##I View example
  # Singe command documentation
  if [ "$2" == "" ]; then
    bpExit
  fi

  echo
  if bpHasCmd batcat; then # Use batcat, if available, to view function
    bpGetFunction "$0" "${2}" | batcat --language bash --decorations never
  else
    bpGetFunction "$0" "${2}" |
      sed -e "s/#.*/\\${BP_C_COMMENT}&\\${E_RESET}/" \
        -e "s/\<echo\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<if\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<then\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<else\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<fi\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<do\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<done\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<elif\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<case\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<esac\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<for\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<in\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<select\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<time\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<until\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<select\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<eval\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<break\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<while\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\".*\"/\\${BP_C_STRING}&\\${E_RESET}/" \
        -e "s/\([^=]*\)=/${BP_C_VAR}\1\\${E_RESET}=/"
  fi
  bpPrintLine
  bpExit
}

ivars() { ##I Print internal variables
  bpPrintLine "Script variables"
  echo
  IFS=$'\n'
  LINES=$(grep -v -e 'LINES' -e 'LINE' "$0" | grep -A 1 '##V') # | sed "s/--//" )
  for line in ${LINES}; do
    if [ "$line" == "--" ]; then
      echo
    else
      LINE=$(echo "${line}" | sed -u -e "s/##V[ ]/${BP_C_DESCRIPTION}/i" -e "s/^.*=/${BP_C_KEY}&${E_RESET}/i" -e "s/=/${E_RESET}=/")
      echo -e "$LINE"
      echo -en "$E_RESET"
    fi
  done
  echo
}

ied() { ##I Open this file with default editor
  bpEdit "$0" "$2"
}

#
# $1 File to diff with, if not given diff with bashplate template
#
idiff() { ##I Run diff with file or bashplate template

  if [ -z "$BP_DIFF" ]; then
    bpError "Diff program not declared (BP_DIFF)"
    return
  fi

  if [ -z "$2" ]; then
    if [ -n "${BP_PATH}" ]; then
      bpRun "${BP_DIFF}" "${BP_SELF_DIR}/${BP_SELF}" "${BP_PATH}/templates/bashplate"
      return
    fi
  fi
  bpRun "${BP_DIFF}" "${BP_SELF_DIR}/${BP_SELF}" "$2"
}

version() { ##D Print version information
  echo "$BP_VERSION"
}

# Runs a function in this file as a command
bpRunCommand() {
  if [ "$BP_ARGUMENTS" -eq 0 ]; then

    # check for a default command
    if [ -n "$DEFAULT_CMD_HOOK" ]; then
      "$DEFAULT_CMD_HOOK" "$1" "$2" "$3" "$4" "$5" "$6" "$7" "$8" "$9" "${10}"
      bpExit
    fi
    bpErrorExit "No command given"
  fi

  if [ "$(type -t "$1")" != "function" ]; then # Check if subcommand is declared as function
    bpErrorExit "Command \"$1\" not found"
  fi

  command=$1
  # execute pre command hook  if existing
  if [ -n "$PRE_CMD_HOOK" ]; then
    "${PRE_CMD_HOOK}" "$command"
  fi

  # Check if command is conditional
  CL=$(grep -E "${command}().*##C" "$0")
  if [[ "$CL" = *"##C"* ]]; then

    # Check if condition is true and then execute else printout error message
    read -r -a ARR <<<"$CL"
    CV="${ARR[3]}"
    if [ -n "$CV" ]; then
      if [ -n "${!CV}" ]; then
        # execute command
        "${command}" "$@"
      else
        bpError "Command \"$command\" not available right now."
      fi
    else
      bpError "Command \"$command\" is conditional, but is missing conditional variable"
    fi
  else
    # command is not conditional, execute
    "${command}" "$@"
  fi

  # execute post command hook  if existing
  if [ -n "$POST_CMD_HOOK" ]; then
    "${POST_CMD_HOOK}" "$command"
  fi
  bpExit
}

#---------------------------------------------------------------------
# Initiate internal variables
#---------------------------------------------------------------------

##V Bashplate version
BP_TEMPLATE_VERSION="1.40beta2"

##V Directory where script is located
BP_SELF_DIR="${0%/*}"

##V Name of script
BP_SELF_NAME=$(basename "$0")

##V Name of script (to be repurposed)
BP_SELF=$(basename "$0")

##V Number of arguments given to script
BP_ARGUMENTS=$#

##V Current date
BP_DATE=$(date +"%Y-%m-%d")

##V Current time
BP_TIME=$(date +"%H:%M:%S")

##V Number of columns in terminal
BP_COLUMNS=$(tput cols)

##V Number of lines in terminal
BP_LINES=$(tput lines)

##V Settings directory
BP_CONFIG_DIR=~/.config/bashplates

##V Settings file
BP_CONFIG_FILE=${BP_CONFIG_DIR}/bashplates.conf

##V System Path's
BP_CONFIG_PATHS="${BP_CONFIG_DIR}/path"

##V Links to modules
BP_CONFIG_MODULES="${BP_CONFIG_DIR}/modules"

# Initiate bashplate settings
bpInitSettings

# Initiate user settings
bpUserSettings

#---------------------------------------------------------------------
# Setup signal traps
#---------------------------------------------------------------------

trap signalQuit SIGQUIT
trap signalInt SIGINT
trap signalHup SIGHUP
trap signalTerm SIGTERM
trap 'signalErr ${FUNCNAME} ${LINENO}' ERR

#trap  'signalDbg ${FUNCNAME} ${LINENO}' DEBUG

#---------------------------------------------------------------------
# Load settings and execute script handler
#---------------------------------------------------------------------

BP_CONFIG_LIST=(
  "${BP_CONFIG_FILE}"
  "Bashplates common settings"
  "BP_NAME" "John Doe" "Users name"
  "BP_EMAIL" "john.doe@foo.bar" "Users email"
  "BP_ORG" "ACME" "Organisation"
  "BP_HOME" "www.foo.bar" "Home"
  "BP_LICENSE" "MIT" "Default license"
  "BP_EDITOR" "vi" "Default editor"
  "BP_DIFF" "meld" "Default diff program"
  "BP_GITSERVER" "github.com" "Default git server"
  "BP_GITUSER" "" "Default git user"
  "BP_GITPROTO" "http" "Default git protocol"
)

# Load configuration file settings
bpConfLoad "${BP_CONFIG_LIST[@]}"

# execute prescript hook if existing
if [ -n "$PRE_SCRIPT_HOOK" ]; then
  ${PRE_SCRIPT_HOOK} "$@"
fi

# Run command parser
bpRunCommand "$@"

# Exit cleanly
bpExit

##C- BP_HELP
