#!/usr/bin/env bash
# shellcheck disable=2034
# shellcheck disable=1090
# shellcheck disable=2317
#---------------------------------------------------------------------
#
#  [Description]
#    Bashplate example script. This script inludes a number of examples
#    demonstrating a number features of the bashplate template.
#
#  [Author]
#    Peter Malmberg <peter.malmberg@gmail.com>
#
#  [Date]
#    2016-xx-xx
#
#  [License]
#     MIT
#
#---------------------------------------------------------------------
# This script was generated by bashplates template generator.
#
# Bashplates is developed by: Peter Malmberg <peter.malmberg@gmail.com>
# Bashplates is available at: https://github.com/zonbrisad/bashplates
#---------------------------------------------------------------------
#

# Display commands as they are executed
#set -o xtrace
# Display shell input lines as they are read
#set -v
#set -o errtrace

# Exit script when a command fails. Append ||true if error is expected
#set -o errexit # || true
# Exit script when undeclared variable is used
#set -o nounset
# Exit script when pipe fails
set -o pipefail

#---------------------------------------------------------------------
# User defined Settings
#---------------------------------------------------------------------
bpUserSettings() {
  :
}
#---------------------------------------------------------------------
# User defined functions
#---------------------------------------------------------------------

##- Bashplate tests

logtest() { ##D Test of log function
  bpRm "${LOGFILE}"
  bpLogInfo "Some information log"
  bpLogWarning "Oh no a warning"
  bpLogError "F#\$ck"
  bpLogCritical "SNAFU"
  bpLogOk "Ahh"
  log
}

traptest() { ##D Trap signal test
  TRAPTEST=1
  bpReadStr "Press CTRL-C"
}

roottest() { ##D Test assert root
  bpAssertRoot
  bpOk "Great you are root"
}

locktest() { ##D Lock file test
  bpAssertNoLockFile
  "${BP_SELF_DIR}/bpexample" locktest
}

assertProgs() { ##D Assert required programs test
  bpAssertRequiredProgs
}

prefunc() {
  echo -e "${E_WHITE}Prefunc${E_RESET} -------------------------------------------------------"
}

postfunc() {
  echo -e "${E_WHITE}Postfunc${E_RESET} ------------------------------------------------------"
}

infoHook() {
  bpPrintVar "Information test1" "Test1"
  bpPrintVar "Information test2" "Test2"
}

appendTest() { ##D Testing append line to file function
  rm -f append
  touch append

  bpAppendIfNoSuchLine "append" "Line to append1"
  bpAppendIfNoSuchLine "append" "Line to append2"
  bpAppendIfNoSuchLine "append" "Line to append3"

  echo "File first time"
  cat append

  bpAppendIfNoSuchLine "append" "Line to append1"
  bpAppendIfNoSuchLine "append" "Line to append2"
  bpAppendIfNoSuchLine "append" "Line to append3"

  echo -e "\nFile second time"
  cat append

  bpRemoveLineContaining "append" "append2"
  echo -e "\nFile third time"
  cat append
}

errorTest() { ##D Test of error messages
  echo "$LOGFILE"
  bpInfo "Info test"
  bpWarning "Warning test"
  bpError "Error test"
  bpCritical "Critical test"
}

##- Hook tests

precmd() { ##D Test preCmdHook
  echo
}

postcmd() { ##D Test postCmdHook
  echo
}

preCmdHook() {
  if [ "$1" == "precmd" ]; then
    bpOk "This is the precmdhook"
  fi
}

postCmdHook() {
  if [ "$1" == "postcmd" ]; then
    bpOk "This is the postmdhook"
  fi
}

##- Misc

pipe() { ##D Pipe data to script
  stdin=$(cat)
  bpInfo "The follwing text was \"piped\" to the script"
  echo -e "$stdin"
}

##- ANSI Terminal

print_attr() {
  eval "ATTR=\$${1}"
  printf "${ATTR}%-30s ${E_GREEN}%-20s${E_RESET}\n" "${2}${E_RESET}" "${1}"
}

print_attr2() {
  eval "ATTR=\$${1}"
  printf "${E_UNDERLINE}${ATTR}%-30s ${E_GREEN}%-20s${E_RESET}\n" "${2}${E_RESET}" "${1}"
}

attr() { ##D demonstrate font attributes
  echo
  bpPrintLine "Font style attributes"
  echo
  print_attr "E_RESET" "Normal text"
  print_attr "E_BOLD" "Bold text"
  print_attr "E_DIM" "Dim text"
  print_attr "E_ITALIC" "Italic text"
  print_attr "E_REVERSE" "Reverse text"
  print_attr "E_BLINK" "Blink text"
  print_attr "E_UNDERLINE" "Underline text"
  print_attr "E_CROSSED" "Crossed text"
  echo
  bpPrintLine "Extended font style attributes(limited support)"
  echo
  print_attr "E_FRACTUR" "Fractur/gothic"
  print_attr "E_UNDERLINE_CURLY" "Underline curly"
  print_attr "E_UNDERLINE_DOUBLE" "Underline double"
  print_attr "E_UNDERLINE_DOT" "Underline dotted"
  print_attr "E_UNDERLINE_DASH" "Underline dashed"
  print_attr "E_SUBSCRIPT" "Subscript"
  print_attr "E_SUPERSCRIPT" "Superscript"
  print_attr "E_RAPID_BLINK" "Rapid blink"
  print_attr "E_FRAME" "Frame"
  echo
  print_attr "E_OVERLINED" "Overlined"
  echo
}

textc() { ##D Font color

  echo
  bpPrintLine "Foreground color attributes"
  echo
  print_attr "E_RED" "Foreground red"
  print_attr "E_YELLOW" "Foreground yellow"
  print_attr "E_GREEN" "Foreground green"
  print_attr "E_BLUE" "Foreground blue"
  print_attr "E_CYAN" "Foreground cyan"
  print_attr "E_MAGENTA" "Foreground magenta"
  print_attr "E_DARKGRAY" "Foreground dark gray"
  print_attr "E_BR_RED" "Foreground red"
  print_attr "E_BR_YELLOW" "Foreground yellow"
  print_attr "E_BR_GREEN" "Foreground green"
  print_attr "E_BR_BLUE" "Foreground blue"
  print_attr "E_BR_CYAN" "Foreground cyan"
  print_attr "E_BR_MAGENTA" "Foreground magenta"
  print_attr "E_GRAY" "Foreground gray"
  print_attr "E_WHITE" "Foreground white"
  echo
  bpPrintLine "Background color attributes"
  echo
  print_attr "E_BG_RED" "Background red"
  print_attr "E_BG_YELLOW" "Background yellow"
  print_attr "E_BG_GREEN" "Background green"
  print_attr "E_BG_BLUE" "Background blue"
  print_attr "E_BG_CYAN" "Background cyan"
  print_attr "E_BG_MAGENTA" "Background magenta"
  print_attr "E_BG_DARKGRAY" "Background dark gray"
  print_attr "E_BG_BR_RED" "Background red"
  print_attr "E_BG_BR_YELLOW" "Background yellow"
  print_attr "E_BG_BR_GREEN" "Background green"
  print_attr "E_BG_BR_BLUE" "Background blue"
  print_attr "E_BG_BR_CYAN" "Background cyan"
  print_attr "E_BG_BR_MAGENTA" "Background magenta"
  print_attr "E_BG_GRAY" "Background gray"
  print_attr "E_BG_WHITE" "Background white"
  echo
  bpPrintLine "Underline color attributes (only supported on certain terminals)"
  echo
  print_attr2 "E_UL_RED" "Underline red"
  print_attr2 "E_UL_YELLOW" "Underline yellow"
  print_attr2 "E_UL_GREEN" "Underline green"
  print_attr2 "E_UL_BLUE" "Underline blue"
  print_attr2 "E_UL_CYAN" "Underline cyan"
  print_attr2 "E_UL_MAGENTA" "Underline magenta"
  print_attr2 "E_UL_DARKGRAY" "Underline dark gray"
  print_attr2 "E_UL_BR_RED" "Underline red"
  print_attr2 "E_UL_BR_YELLOW" "Underline yellow"
  print_attr2 "E_UL_BR_GREEN" "Underline green"
  print_attr2 "E_UL_BR_BLUE" "Underline blue"
  print_attr2 "E_UL_BR_CYAN" "Underline cyan"
  print_attr2 "E_UL_BR_MAGENTA" "Underline magenta"
  print_attr2 "E_UL_GRAY" "Underline gray"
  print_attr2 "E_UL_WHITE" "Underline white"
  echo
}

c16() { ##D Standard 16 colors
  FCOLORS=(E_BLACK E_RED E_GREEN E_YELLOW E_BLUE E_MAGENTA E_CYAN E_GRAY E_DARKGRAY E_BR_RED E_BR_GREEN E_BR_YELLOW E_BR_BLUE E_BR_MAGENTA E_BR_CYAN E_WHITE)
  BCOLORS=(E_BG_BLACK E_BG_RED E_BG_GREEN E_BG_YELLOW E_BG_BLUE E_BG_MAGENTA E_BG_CYAN E_BG_WHITE)
  BCOLORS_BR=(E_BG_DARK_GRAY E_BG_BR_RED E_BG_BR_GREEN E_BG_BR_YELLOW E_BG_BR_BLUE E_BG_BR_MAGENTA E_BG_BR_CYAN E_BG_GRAY)

  echo
  bpPrintLine "16 color map"
  echo
  for fc in "${FCOLORS[@]}"; do
    eval "FG=\$$fc"
    for bc in "${BCOLORS[@]}"; do
      eval "BG=\$$bc"
      printf "${FG}${BG}%-10s${E_RESET}" "${fc:2}"
    done
    echo
  done

  echo

  for fc in "${FCOLORS[@]}"; do
    eval "FG=\$$fc"
    for bc in "${BCOLORS_BR[@]}"; do
      eval "BG=\$$bc"
      printf "${FG}${BG}%-10s${E_RESET}" "${fc:2}"
    done
    echo
  done

  echo
}

c256() { ##D Show example of all 256 colors

  echo
  #  bpPrintLine "256 Colors foreground"
  echo
  for i in {0..231}; do
    printf "\x1b[38;5;%sm  %3d  ${E_RESET} " "$i" "$i"
    if ((i == 7)) || ((i == 15)) || ( ((i > 15)) && (((i - 15) % 6 == 0))); then
      echo

      if ((i == 15)); then
        echo
      fi
    fi
  done

  echo
  for i in {232..255}; do
    printf "\x1b[38;5;%sm %3d ${E_RESET}" "$i" "$i"
    if ((i == 243)); then
      echo
    fi
  done
  echo -e "\n"

  echo
  #  bpPrintLine "256 Colors background"
  echo
  for i in {0..231}; do
    printf "\x1b[48;5;%sm  %3d  ${E_RESET} " "$i" "$i"
    if ((i == 7)) || ((i == 15)) || ( ((i > 15)) && (((i - 15) % 6 == 0))); then
      echo
      if ((i == 15)); then
        echo
      fi
    fi
  done

  echo
  for i in {232..255}; do
    printf "\x1b[48;5;%sm %3d ${E_RESET}" "$i" "$i"
    if ((i == 243)); then
      echo
    fi
  done
  echo -e "\n"
}

##- Some fun

bpElapsedTime() { ##D Return elapsed time
  #dt=$((etime - stime))
  dt=$SECONDS # total time elapsed in seconds
  ds=$((dt % 60))
  dm=$(((dt / 60) % 60))
  dh=$((dt / 3600))
  printf '%02d:%02d:%02d' "$dh" "$dm" "$ds"
}

print_spinner() {

  XX=("|" "/" "-" "\\")
  if [ -n "$SPINNER" ]; then
    SPINNER=$((SPINNER + 1))
    if [ "$SPINNER" -gt 3 ]; then
      SPINNER=0
    fi
  else
    SPINNER=0
  fi
  echo " ${XX[$SPINNER]} $1"
  echo -e "$E_RETURN $E_UP"
}

spinner() { ##D Spinner example
  echo "$E_HIDE"
  for i in {1..100}; do
    print_spinner "Processing... $(bpElapsedTime)"
    sleep 0.1
  done
  echo -e "${E_SHOW}"
}

bpWait() { ##I Wait for n seconds
  echo "${E_HIDE}"
  a=0
  tmp=${SECONDS}
  while [ "$a" -lt "$1" ]; do
    a=$((SECONDS - tmp))
    print_spinner "Waiting... $a"
    sleep 0.1
  done
  echo -e "${E_SHOW}"
}

wait() { ##D Wait for n seconds
  bpWait "$2"
}

print_bar() {

  echo -n " ["
  for jx in $(seq 1 "${2}"); do
    echo -n "="
  done
  for jx in $(seq 1 $((${1} - ${2}))); do
    echo -n " "
  done
  echo -n "] ${2}"
}

bar() { ##D print a testbar (ANSI)
  bpPrintLine "Bar test"
  echo -en "$E_HIDE"
  for i in {1..60}; do
    sleep 0.03
    print_bar 60 "$i"
    #echo -e "$E_RETURN $E_UP"
    echo -en "$E_RETURN$E_DOWN"
  done
  echo -e "$E_SHOW"
}

barcr() { ##D print a testbar using carriage return(ANSI)
  bpPrintLine "Bar test"
  echo -en "$E_HIDE"
  for i in {1..60}; do
    sleep 0.03
    print_bar 60 "$i"
    echo -en "\r"
  done
  echo -e "$E_SHOW"
}

shade() { ##D Shade demo (256 color terminal required)
  #echo -en '\033]1 Kalle \007'
  #echo
  bpPrintLine "B/W shading"
  echo -en "$E_HIDE"
  echo
  echo -en "$E_RETURN"
  for i in {232..255} {255..232}; do
    sleep 0.05
    printf "\x1b[38;5;%sm _____ Shading text _____ ${E_RESET}" "$i"
    echo -en "$E_RETURN$E_DOWN"
  done
  echo -e "$E_SHOW"
}

FLAG_BLUE="\x1b[48;5;20m"
FLAG_YELLOW="\x1b[48;5;226m"

smallFlag() {
  echo -e "${FLAG_BLUE}     ${FLAG_YELLOW}  ${FLAG_BLUE}          ${E_RESET}"
  echo -e "${FLAG_BLUE}     ${FLAG_YELLOW}  ${FLAG_BLUE}          ${E_RESET}"
  echo -e "${FLAG_YELLOW}                 ${E_RESET}"
  echo -e "${FLAG_BLUE}     ${FLAG_YELLOW}  ${FLAG_BLUE}          ${E_RESET}"
  echo -e "${FLAG_BLUE}     ${FLAG_YELLOW}  ${FLAG_BLUE}          ${E_RESET}"
}

mediumFlag() {
  echo -e "${FLAG_BLUE}        ${FLAG_YELLOW}  ${FLAG_BLUE}              ${E_RESET}"
  echo -e "${FLAG_BLUE}        ${FLAG_YELLOW}  ${FLAG_BLUE}              ${E_RESET}"
  echo -e "${FLAG_BLUE}        ${FLAG_YELLOW}  ${FLAG_BLUE}              ${E_RESET}"
  echo -e "${FLAG_YELLOW}                        ${E_RESET}"
  echo -e "${FLAG_BLUE}        ${FLAG_YELLOW}  ${FLAG_BLUE}              ${E_RESET}"
  echo -e "${FLAG_BLUE}        ${FLAG_YELLOW}  ${FLAG_BLUE}              ${E_RESET}"
  echo -e "${FLAG_BLUE}        ${FLAG_YELLOW}  ${FLAG_BLUE}              ${E_RESET}"
}

largeFlag() {
  echo -e "${FLAG_BLUE}           ${FLAG_YELLOW}    ${FLAG_BLUE}                       ${E_RESET}"
  echo -e "${FLAG_BLUE}           ${FLAG_YELLOW}    ${FLAG_BLUE}                       ${E_RESET}"
  echo -e "${FLAG_BLUE}           ${FLAG_YELLOW}    ${FLAG_BLUE}                       ${E_RESET}"
  echo -e "${FLAG_BLUE}           ${FLAG_YELLOW}    ${FLAG_BLUE}                       ${E_RESET}"
  echo -e "${FLAG_BLUE}           ${FLAG_YELLOW}    ${FLAG_BLUE}                       ${E_RESET}"
  echo -e "${FLAG_YELLOW}                                      ${E_RESET}"
  echo -e "${FLAG_YELLOW}                                      ${E_RESET}"
  echo -e "${FLAG_BLUE}           ${FLAG_YELLOW}    ${FLAG_BLUE}                       ${E_RESET}"
  echo -e "${FLAG_BLUE}           ${FLAG_YELLOW}    ${FLAG_BLUE}                       ${E_RESET}"
  echo -e "${FLAG_BLUE}           ${FLAG_YELLOW}    ${FLAG_BLUE}                       ${E_RESET}"
  echo -e "${FLAG_BLUE}           ${FLAG_YELLOW}    ${FLAG_BLUE}                       ${E_RESET}"
  echo -e "${FLAG_BLUE}           ${FLAG_YELLOW}    ${FLAG_BLUE}                       ${E_RESET}"
}

hugeFlag() {
  echo -e "${FLAG_BLUE}               ${FLAG_YELLOW}      ${FLAG_BLUE}                            ${E_RESET}"
  echo -e "${FLAG_BLUE}               ${FLAG_YELLOW}      ${FLAG_BLUE}                            ${E_RESET}"
  echo -e "${FLAG_BLUE}               ${FLAG_YELLOW}      ${FLAG_BLUE}                            ${E_RESET}"
  echo -e "${FLAG_BLUE}               ${FLAG_YELLOW}      ${FLAG_BLUE}                            ${E_RESET}"
  echo -e "${FLAG_BLUE}               ${FLAG_YELLOW}      ${FLAG_BLUE}                            ${E_RESET}"
  echo -e "${FLAG_BLUE}               ${FLAG_YELLOW}      ${FLAG_BLUE}                            ${E_RESET}"
  echo -e "${FLAG_YELLOW}                                                 ${E_RESET}"
  echo -e "${FLAG_YELLOW}                                                 ${E_RESET}"
  echo -e "${FLAG_YELLOW}                                                 ${E_RESET}"
  echo -e "${FLAG_BLUE}               ${FLAG_YELLOW}      ${FLAG_BLUE}                            ${E_RESET}"
  echo -e "${FLAG_BLUE}               ${FLAG_YELLOW}      ${FLAG_BLUE}                            ${E_RESET}"
  echo -e "${FLAG_BLUE}               ${FLAG_YELLOW}      ${FLAG_BLUE}                            ${E_RESET}"
  echo -e "${FLAG_BLUE}               ${FLAG_YELLOW}      ${FLAG_BLUE}                            ${E_RESET}"
  echo -e "${FLAG_BLUE}               ${FLAG_YELLOW}      ${FLAG_BLUE}                            ${E_RESET}"
  echo -e "${FLAG_BLUE}               ${FLAG_YELLOW}      ${FLAG_BLUE}                            ${E_RESET}"
}

flags() { ##D Print swedish flags
  echo
  smallFlag
  echo
  mediumFlag
  echo
  largeFlag
  echo
  hugeFlag
  echo
}

fret() {
  sleep 0.1
  echo "$E_RETURN" "$E_UP" "$E_UP" "$E_UP" "$E_UP" "$E_UP" "$E_UP" "$E_UP"
  mediumFlag
}

fadeflag() { ##D Fade flag

  FLAG_BLUE="\x1b[48;5;16m"
  FLAG_YELLOW="\x1b[48;5;58m"
  mediumFlag
  FLAG_BLUE="\x1b[48;5;17m"
  FLAG_YELLOW="\x1b[48;5;94m"
  fret
  FLAG_BLUE="\x1b[48;5;18m"
  FLAG_YELLOW="\x1b[48;5;142m"
  fret
  FLAG_BLUE="\x1b[48;5;19m"
  FLAG_YELLOW="\x1b[48;5;178m"
  fret
  FLAG_BLUE="\x1b[48;5;20m"
  FLAG_YELLOW="\x1b[48;5;220m"
  fret
  FLAG_BLUE="\x1b[48;5;21m"
  FLAG_YELLOW="\x1b[48;5;226m"
  fret

  echo "$E_DOWN $E_DOWN $E_DOWN $E_DOWN $E_DOWN"
}

flash() { ##D Flash screen
  while true; do
    printf \\e[?5h
    sleep 0.1
    printf \\e[?5l
    read -s -n1 -t1 && break
  done
}

E_RGB=$'\e[0;36m' # RGB
rgb() {           ##D Many colors
  echo -e "\e[0;38;2;123;132;123m AA"
  echo -e "\e[0;38;2;123;132;240m AA"
  echo -e "\e[0;38;2;12;13;10m AA"
}

##- Read tests

readstr() { ##D Test string read from cmdline
  x=$(bpReadStr "Enter a string" "Default value")
  echo "You entered \"$x\""
  x=$(bpReadStr "Just press enter" "Default value")
  echo "You entered \"$x\""
}

readint() { ##D Test integer read from cmdline
  x=$(bpReadInt "Enter value" "12" "0" "100")
  echo "You entered \"$x\""
  x=$(bpReadInt "Just press enter" "45" "0" "100")
  echo "You entered \"$x\""
}

readbool() { ##D Test Yes/No question from cmdline
  if bpReadBoolDY "Default yes"; then
    echo "YES"
  else
    echo "NO"
  fi

  if bpReadBoolDN "Default no"; then
    echo "YES"
  else
    echo "NO"
  fi
}

#
# $1 Question
# $2 default value
# $3 question array
#
bpReadSelect() {
  arr=("${@}")
  len=${#arr[@]}

  while [ true ]; do
    echo "$1"

    i=2
    while [ "$i" -lt "$len" ]; do
      choice=${arr[$i]}
      ((i++))
      desc=${arr[$i]}
      ((i++))
      bpPrintInfo "${choice}) " "${desc}"
    done

    ans=$(bpReadStr "Choice" "${2}")

    i=2
    while [ "$i" -lt "$len" ]; do
      choice=${arr[$i]}
      if [ "${choice}" == "${ans}" ]; then
        echo "$ans"
        return 0

      fi
      ((i++))
      ((i++))
    done
  done
}

readselect() { ##D Test select from list read command

  slist=(
    "a" "First choice"
    "b" "Second choice"
    "3" "Third alternative"
    "4" "Fourth alternative"
    "penta" "Fifth choice"
    "hexa" "Sixth choice"
  )

  bpReadSelect "Please choose an alternative" "3" "${slist[@]}"
}

##- Experiments

bpShow() {
  for a in {1..10}; do
    echo -e "${E_RED}$1${E_RESET}"
    sleep 0.3
    echo -e "${E_UP}${E_RETURN}"
    echo -e "${E_BR_RED}$1${E_RESET}"
    sleep 0.3
    # echo -e "${E_UP}${E_RETURN}"
    echo -e "${E_UP}${E_RETURN}"
    #		echo -e "${E_RETURN}"

  done
}

blink() { ##D Test
  bpShow "Blinking message"
}

listfiles() { ##D list files
  for file in ./*; do
    echo "$file"
    if [ -L "$file" ]; then
      echo "A"
    else
      echo "B"
    fi
  done
}

#
# $1 Number of iterations
# $2 Command to execute
#
bpRepeat() { ##I Repeat command n times
  local i max
  max=$1
  shift
  for ((i = 1; i <= max; i++)); do # --> C-like syntax
    eval "$@"
  done

}

repeat() { ##D Test repeat
  bpRepeat 10 "ls ; sleep 1"
}

#
# $1 Text to set as title
#
bpTitle() { ##I Set terminal window title
  case "$TERM" in
  *term* | rxvt)
    echo -en "\e]0;$*\a"
    ;;
  *) ;;
  esac
}

title() { ##D Set title
  bpTitle "Kalle"
  bpWait 10
}

#
# String contains
#
# $1 Substring to search
# $2 String to search in
#
bpInString() {

  if [[ "$1" = *"$2"* ]]; then
    echo 1
  else
    echo 0
  fi
}

inString() { ##D String contains test
  A="Hello world"

  if [ "$(bpInString HelloX "$A")" = "1" ]; then
    #  if  $( bpInString "Hello" "$A" ) ; then
    echo "A"
  else
    echo "B"
  fi

  bpInString "Hello" "$A"
  bpInString "Kalle" "$A"
}

aVeryLongCommandTestCommand() { ##D Testing truncation of long command strings
  echo
}

#ICMD=10
inactiveCommand() { ##CV ICMD Inactive command test
  echo "Only possible if ICMD is set."
}

# Directory where to store archives
ARCHIVEDIR="archive"
BACKUP_DIR="backup"
OUTDIR="output"
BUILDDIR="build"

#TARGET="kalle"
#
# Archive makeplate project
#
# $1 Target name
#
archive() { ##D Make a tar archive of the source code
  DT=$(date +"%Y%m%d-%H%M%S")
  bpMkDir "${ARCHIVEDIR}"
  tar -cvzf "${ARCHIVEDIR}/${1}_${DT}.tar.gz" ./* \
    --exclude="${ARCHIVEDIR}" \
    --exclude="${BACKUP_DIR}" \
    --exclude="${OUTDIR}" \
    --exclude="${BUILDDIR}" \
    --exclude='*.a' \
    --exclude='*.o' \
    --exclude='*.ko' \
    --exclude='*.obj' \
    --exclude='*.a' \
    --exclude='*.la' \
    --exclude='*.lo' \
    --exclude='*.slo' \
    --exclude='*.lib' \
    --exclude='*.so' \
    --exclude='*.so*' \
    --exclude='.dep' \
    --exclude='.svn' \
    --exclude='.git' \
    --exclude='*.elf' \
    --exclude='*.hex' \
    --exclude='*.bin' \
    --exclude='*.exe' \
    --exclude='*.sym' \
    --exclude='*.lss' \
    --exclude='*.map' \
    --exclude='*.app' \
    --exclude='*.i*86' \
    --exclude='*.x86_64' \
    --exclude='*~' \
    --exclude="*.old" \
    --exclude="*.tmp"
}

# Max number of backups
BACKUPS=100

backup() { ##D Make an incremental backup
  bpMkDir "${BACKUP_DIR}"
  # remove oldest backup
  bpRm "${BACKUP_DIR}/backup_${BACKUPS}"
  # rotate backups
  for ((x = BACKUPS; x > 0; x--)); do
    bdir=${BACKUP_DIR}/backup_$((x - 1))
    # check if directory exist before renameing  it
    if [ -d "${bdir}" ]; then
      mv -f "${bdir}" "${BACKUP_DIR}/backup_${x}"
    fi
  done
  rsync --archive \
    --delete \
    --relative \
    --exclude="${BACKUP_DIR}" \
    --exclude="${ARCHIVEDIR}" \
    --exclude="${OUTDIR}" \
    --link-dest="${PWD}/${BACKUP_DIR}/backup_1" \
    . \
    "${BACKUP_DIR}/backup_0"
}

backupfile() { ##D Backup file
  bpBackup "$2"
}

#XXX=-e 's/[0-9]*/\\${BP_C_VALUE}&\\${E_RESET}/' \

#---------------------------------------------------------------------
# Bashplate settings
#---------------------------------------------------------------------
bpInitSettings() {

  ##V Script version info
  BP_VERSION="1.00"

  ##V Usage info
  BP_USAGE="Usage: ${BP_NAME} command [option]"

  ##V Description text
  BP_DESC="Examples of how to use bashplates."

  ##V logfile (uncomment to use logfile)
  BP_LOGFILE=${BP_SELF_DIR}/${BP_SELF}.log

  ##V Lock file (uncomment to use lock file feature )
  BP_LOCK_FILE=/tmp/${BP_NAME}.lock

  ##V Logging options (uncomment to activate logging parameters)
  BP_LOG_OK=1
  BP_LOG_INFO=1
  BP_LOG_WARNING=1
  BP_LOG_ERROR=1
  BP_LOG_CRITICAL=1

  ##V Activate settings function (will create settings file when run)
  BP__CONF=1

}
#---------------------------------------------------------------------
# Bashplate Hooks
#---------------------------------------------------------------------

##V Default command (uncomment to use a default command )
DEFAULT_CMD_HOOK=help

##V Pre script hook, execute this function before every command
#PRE_SCRIPT_HOOK=

##V Post script hook, execute this function after every command
#POST_SCRIPT_HOOK=

##V Function to be executed before every other cmd except DEFAULT function
PRE_CMD_HOOK=preCmdHook

##V Function to be executed after every other function except DEFAULT function
POST_CMD_HOOK=postCmdHook

##V Function to be executed after information command
POST_INFO_HOOK=infoHook

##V Function run before help command is executed
#PRE_HELP_HOOK=

##V Function run after help command is executed
#POST_HELP_HOOK=

#---------------------------------------------------------------------
# Signal traps
#---------------------------------------------------------------------

signalInt() {
  if [ -n "$TRAPTEST" ]; then
    echo
    bpOk "This text is printed from signal \"trap\" sigint."
  fi
  bpCleanUp
  exit "$BP_E_OK"
}

signalHup() {
  bpCleanUp
}

signalQuit() {
  echo "Quit"
  bpCleanUp
}

signalTerm() {
  echo "Term"
  bpCleanUp
}

signalErr() {
  echo
  echo
  bpError "Trace error Row: $2  Function: $1"
  echo
  bpCallStack "$*"
  bpExit 1
}

signalDbg() {
  echo "Debug Row: $2  Function: $1"
}

##C- IHELP Exit and cleanup

bpCallStack() { ##I Print out BASH call stack
  bpPrintLine "Call stack"
  echo
  local frame=0
  while caller "$frame" | sed -r -e "s/[0-9]*/${BP_C_VALUE}&${E_RESET}/"; do
    ((frame++))
  done
  echo "$*"
  bpPrintLine
}

bpCleanUp() {           ##I Cleanup function
  rm -f "$BP_LOCK_FILE" # remove Lock file
  #  echo -e "${E_SHOW}"     # Turn on cursor if turned of
}

#
# $1 exit code, if not given exit code is 0=SUCCESS
#
bpExit() { ##I Function for safely exiting script
  bpCleanUp

  # execute postscript hook if existing
  if [ -n "$POST_SCRIPT_HOOK" ]; then
    ${POST_SCRIPT_HOOK}
  fi

  # Check if argument is given
  if [ -z "$1" ]; then
    exit 0 # Success
  else
    exit "$1"
  fi

}

bpErrorExit() { ##I Safely exit script with a error
  bpError "${1}"
  bpCleanUp
  exit 1
}

#---------------------------------------------------------------------
# ANSI escape codes
#---------------------------------------------------------------------

# ANSI foreground colors codes
#
E_BLACK=$'\e[38:5:0m'       # Black
E_RED=$'\e[38:5:1m'         # Red
E_GREEN=$'\e[38:5:2m'       # Green
E_YELLOW=$'\e[38:5:3m'      # Yellow
E_BLUE=$'\e[38:5:4m'        # Blue
E_MAGENTA=$'\e[38:5:5m'     # Magenta
E_CYAN=$'\e[38:5:6m'        # Cyan
E_GRAY=$'\e[38:5:7m'        # Gray
E_DARKGRAY=$'\e[38:5:8m'    # Dark Gray
E_BR_RED=$'\e[38:5:9m'      # Bright Red
E_BR_GREEN=$'\e[38:5:10m'   # Bright Green
E_BR_YELLOW=$'\e[38:5:11m'  # Bright Yellow
E_BR_BLUE=$'\e[38:5:12m'    # Bright Blue
E_BR_MAGENTA=$'\e[38:5:13m' # Bright Magenta
E_BR_CYAN=$'\e[38:5:14m'    # Bright Cyan
E_WHITE=$'\e[38:5:15m'      # White

# ANSI background color codes
#
E_BG_BLACK=$'\e[48;5;0m'       # Black
E_BG_RED=$'\e[48;5;1m'         # Red
E_BG_GREEN=$'\e[48;5;2m'       # Green
E_BG_YELLOW=$'\e[48;5;3m'      # Yellow
E_BG_BLUE=$'\e[48;5;4m'        # Blue
E_BG_MAGENTA=$'\e[48;5;5m'     # Magenta
E_BG_CYAN=$'\e[48;5;6m'        # Cyan
E_BG_GRAY=$'\e[48;5;7m'        # Gray
E_BG_DARK_GRAY=$'\e[48;5;8m'   # Dark gray
E_BG_BR_RED=$'\e[48;5;9m'      # Bright Red
E_BG_BR_GREEN=$'\e[48;5;10m'   # Bright Green
E_BG_BR_YELLOW=$'\e[48;5;11m'  # Bright Yellow
E_BG_BR_BLUE=$'\e[48;5;12m'    # Bright Blue
E_BG_BR_MAGENTA=$'\e[48;5;13m' # Bright Magenta
E_BG_BR_CYAN=$'\e[48;5;14m'    # Bright Cyan
E_BG_WHITE=$'\e[48;5;15m'      # White

# ANSI underline color codes
#
# Not in standard. implemented in Kitty, VTE, mintty, etc.
#
E_UL_BLACK=$'\e[58;5;0m'       # Black
E_UL_RED=$'\e[58;5;1m'         # Red
E_UL_GREEN=$'\e[58;5;2m'       # Green
E_UL_YELLOW=$'\e[58;5;3m'      # Yellow
E_UL_BLUE=$'\e[58;5;4m'        # Blue
E_UL_MAGENTA=$'\e[58;5;5m'     # Magenta
E_UL_CYAN=$'\e[58;5;6m'        # Cyan
E_UL_GRAY=$'\e[58;5;7m'        # Gray
E_UL_DARKGRAY=$'\e[58;5;8m'    # Dark Gray
E_UL_BR_RED=$'\e[58;5;9m'      # Bright Red
E_UL_BR_GREEN=$'\e[58;5;10m'   # Bright Green
E_UL_BR_YELLOW=$'\e[58;5;11m'  # Bright Yellow
E_UL_BR_BLUE=$'\e[58;5;12m'    # Bright Blue
E_UL_BR_MAGENTA=$'\e[58;5;13m' # Bright Magenta
E_UL_BR_CYAN=$'\e[58;5;14m'    # Bright Cyan
E_UL_WHITE=$'\e[58;5;15m'      # White

# ANSI Text attributes
E_BOLD=$'\e[1m'               # Bold text
E_LOWI=$'\e[2m'               # Low intensity
E_ITALIC=$'\e[3m'             # Italic text
E_UNDERLINE=$'\e[4m'          # Underlined text
E_UNDERLINE_DOUBLE=$'\e[4:2m' # Double underline (limited support)
E_UNDERLINE_CURLY=$'\e[4:3m'  # Curly underline (limited support)
E_UNDERLINE_DOT=$'\e[4:4m'    # Dotted underline (limited support)
E_UNDERLINE_DASH=$'\e[4:5m'   # Dashed underline (limited support)
E_BLINK=$'\e[5m'              # Blinking text
E_RAPID_BLINK=$'\e[6m'        # Rapid blink (Limited support)
E_REVERSE=$'\e[7m'            # Reverse color
E_CROSSED=$'\e[9m'            # Crossed over text
E_FRAKTUR=$'\e[20m'           # Gothic (limited support)
E_FRAMED=$'\e[51m'            # Framed (limited support)
E_OVERLINED=$'\e[53m'         # Overlined text
E_SUPERSCRIPT=$'\e[73m'       # Superscript text (limited support)
E_SUBSCRIPT=$'\e[74m'         # Subscript text (limited support)

# ANSI cursor operations
#
E_RETURN=$'\e[F'  # Move cursor to begining of line
E_UP=$'\e[A'      # Move cursor one line up
E_DOWN=$'\e[B'    # Move cursor one line down
E_FORWARD=$'\e[C' # Move cursor forward
E_BACK=$'\e[D'    # Move cursor backward
E_HIDE=$'\e[?25l' # Hide cursor
E_SHOW=$'\e[?25h' # Show cursor

E_RESET=$'\e[0m' # Clear Attributes

# Default Bashplate colortheme
BP_C_OK="${E_BR_GREEN}"
BP_C_INFO="${E_BR_CYAN}"
BP_C_DEBUG="${E_BG_GREEN}${E_WHITE}"
BP_C_WARNING="${E_BR_YELLOW}"
BP_C_ERROR="${E_BR_RED}"
BP_C_CRITICAL="${E_BG_RED}${E_WHITE}"
BP_C_LINE="${E_DARKGRAY}"
BP_C_LINE_TEXT="${E_YELLOW}"
BP_C_DESCRIPTION="${E_GREEN}"
BP_C_ID="${E_CYAN}"

BP_C_FILENAME="${E_BR_CYAN}"
BP_C_PATH="${E_CYAN}"
BP_C_URL_SCHEME="${E_DARKGRAY}"
# BP_C_URL_USER=""
# BP_C_URL_HOST=""
BP_C_TIME="${E_BR_MAGENTA}"
BP_C_DATE="${E_MAGENTA}"

# Shellscript colorize colors
BP_C_RESERVED="${E_RED}"
BP_C_COMMENT="${E_CYAN}"
BP_C_STRING="${E_GREEN}"
BP_C_VAR="${E_BR_YELLOW}"

# Exit codes
#
BP_E_OK=0 # successful termination

#---------------------------------------------------------------------
# Bashplate internal functions
#---------------------------------------------------------------------

##C- IHELP Printing functions

#
# $1 text to be printed
# $2 text color
# $3 line color
# $4 middle character
# $5 line character
#
bpPrintLineGeneric() { ##I Print text with adjusted line after with selectable colors
  len1="${#1}"
  len4="${#4}"

  echo -en "${2}${1}${4}${3}"
  l=$((BP_COLUMNS - len1 - len4))
  seq -s"${5}" "${l}" | tr -d '[:digit:]'
  echo -en "${E_RESET}"
}

#
# $1 text to be printed
# $2 text color
# $3 line color
#
bpTextLineC() { ##I Print text with adjusted line after with selectable colors
  bpPrintLineGeneric "$1" "$2" "$3" " " "-"
}

bpPrintLine() { ##I Print text with line after
  #  echo "$1 ${#1}"
  if [ "${#1}" -eq 0 ]; then
    bpPrintLineGeneric "" "" "${BP_C_LINE}" "" "-"
  else
    bpPrintLineGeneric "$1" "${BP_C_LINE_TEXT}" "${BP_C_LINE}" " " "-"
  fi
}

#
# $1 command color
# $2 description color
# $3 command text
# $4 desccription text
#
bpPrintInfoGeneric() { # Generic command/description printout function
  if [ -n "$5" ]; then
    X="$5"
  else
    X=24
  fi
  printf "${1}  %-${X}.${X}s${E_RESET} ${2}%s${E_RESET}\n" "$3" "$4"
}

#
# $1 text for column 1
# $2 text for column 2
# $3 (optional) left alignment
#
bpPrintInfo() { ##I Print text into two columns
  bpPrintInfoGeneric "${BP_C_ID}" "${BP_C_DESCRIPTION}" "$1" "$2" "$3"
}

bpPrintInfoAlt() {
  bpPrintInfoGeneric "${E_DARKGRAY}" "${BP_C_DESCRIPTION}" "$1" "$2"
}

#
# $1 text for column 1
# $2 variable for column 2
# $3 optional text form column 2
# $4 (optional) left alignment
#
bpPrintVar() { ##I Print variable value and description
  var="$2"
  if [ "${!var}" ]; then
    if [ -n "$3" ]; then
      X=${3}
    else
      X="${!var}"
    fi
    bpPrintInfo "$1" "${X}"
  else
    printf "${BP_C_ID}  %-24s${E_RESET} ${BP_C_ERROR}N/A${E_RESET}\n" "$1"
  fi
}

#
# Colorize string containing filename
#
# $1 string with filename to colorize
# ret colorized string
#
bpColorizeFile() { ##I Colorize string containing filename
  echo "${BP_C_PATH}$(dirname "$1")/${BP_C_FILENAME}$(basename "$1")${E_RESET}"
}

#
# $1 string with url to colorize
# ret colorized string
#
# todo: give username and port own color
#
bpColorizeUrl() { ##I Colorize string containing URL
  URL=$(sed -r -e "s/^.*\/\///" <<<"$1")
  SCHEME=$(sed -r -e "s/:\/.*//" <<<"$1")
  # USERNAME=$(sed -r -e "s/@.*//" <<<"$URL")
  # PORT=$(sed -r -e "s/^:[0-9]*/XXX/" <<<"$URL")
  # echo -e "Username: $USERNAME"
  # echo -e "Port: $PORT"

  #URL=$(echo -n "$1" | sed -r -e "s/^.*\/\///")
  #SCHEME=$(echo -n "$1" | sed -r -e "s/:\/.*//")

  echo -e -n "${BP_C_URL_SCHEME}${SCHEME}${E_RESET}://$(bpColorizeFile "${URL}")"
}

#
# $1 string to be filtered
#
bpFilterEscape() { ##I Filter escape characters from string
  echo "$1" | sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g"
}

##C- IHELP File operations

#
# $1 command to execute
#
bpRun() { ##I Execute command
  if bpHasCmd "${1}"; then
    "$@"
    return $?
  else
    bpError "Could not execute $1, command does not exist!"
    return 1
  fi
}

#
# $1 directory to change to
#
bpCd() { ##I Safe cd function (exits on fail)
  cd "$1" || bpExit "Failed to cd to [$1]"
}

#
# $1 Directory to be created
#
bpMkDir() { ##I Create a directory if it does not exist
  if [ ! -d "$1" ]; then
    if mkdir -p "$1"; then
      bpOk "Creating directory $(bpColorizeFile "${1}")."
      return 0
    else
      bpError "Failed to create directory $(bpColorizeFile "${1}")."
      return 1
    fi
  fi
}

#
# $1 target file/dir
# $2 link
#
bpLn() { ##I Create symbolic link
  if [ ! -L "$1" ]; then
    if ln -sf "${1}" "${2}"; then
      bpOk "Creating link $(bpColorizeFile "${2}")."
      return 0
    else
      bpError "Failed to create link $(bpColorizeFile "${2}")."
      return 1
    fi
  fi
}

#
# $1 file(s) to be copied
# $2 destination
#
bpCp() { ##I Copy file(s)
  if cp -rf "$@"; then
    bpOk "Copying $(bpColorizeFile "${1}") to $(bpColorizeFile "${2}")"
    return 0
  else
    bpError "Failed copying $(bpColorizeFile "${1}") to $(bpColorizeFile "${2}")"
    return 1
  fi
}

#
# $1 file(s) to be moved
# $2 destination
#
bpMv() { ##I Move file(s)
  if mv "$1" "$2"; then
    bpOk "Moving file $(bpColorizeFile "${1}") to $(bpColorizeFile "${2}")."
    return 0
  else
    bpError "Failed moving file $(bpColorizeFile "${1}") to $(bpColorizeFile "${2}")."
    return 1
  fi
}

#
# $1 file(s) to be removed
#
bpRm() { ##I Remove file(s)
  if rm -rf "${1}"; then
    bpOk "Removing file $(bpColorizeFile "${1}")."
    return 0
  else
    bpError "Failed removing file $(bpColorizeFile "${1}")."
    return 1
  fi
}

#
# $1 file to be backed up
#
bpBackup() { ##I Make backup of file
  BF="${1}_$(date +"%Y%m%d")-$(date +"%H%M%S").bak"

  if cp -rf "$1" "${BF}"; then
    bpOk "Backing up file $(bpColorizeFile "$1") to $(bpColorizeFile "${BF}")."
    return 0
  else
    bpError "Failed backing up file $(bpColorizeFile "$1") to $(bpColorizeFile "${BF}")."
    return 1
  fi
}

#
# $1 file
# $2 text to replace
# $3 new text
#
bpReplace() { ##I Replace all ocurances of text in file
  sed -i -e "s/${2}/${3}/g" "$1"
}

#
# $1 file
# $2 pattern matching line
# $3 new text
#
bpReplaceLine() { ##I Replace entire line matching pattern
  sed -i -e "0,/${2}/s/${2}.*/${3}/" "${1}"
}

#
# $1 file
# $2 line to append
#
bpAppendIfNoSuchLine() { ##I Append a line if it does not exist in file
  grep -q -F "$2" "$1" || echo "$2" >>"$1"
}

#
# $1 file
# $2 string
#
bpRemoveLineContaining() { ##I Remove line in file if it contains given string
  grep -v "$2" "$1" >"${1}_tmp"
  mv -f "${1}_tmp" "${1}"
}

#
# $1 file
# $2 string
# return true if existing
#
bpStrExist() { ##I Check if string exist in file
  if [ ! -f "$1" ]; then
    return 1
  fi

  if grep -q -F "$2" "$1"; then
    return 0
  else
    return 1
  fi
}

#
# $1 file to open in editor
# $2 override editor (optional)
#
bpEdit() { ##I Open file in editor set by BP_EDIT variable

  if [ -n "$2" ]; then
    bpRun "$2" "$1"
    return 0
  fi

  if [ -n "$BP_EDITOR" ]; then
    bpRun "${BP_EDITOR}" "${1}"
  else
    bpError "BP_EDITOR variable not set, can't open file ${1}"
  fi
}

#
# $1 file
# $2 start marker
# $3 end marker
#
bpGetSection() { ##I Get text from file between two markers
  grep -A 10000 -m 1 "$2" <"$1" | grep -B 10000 -m 1 "$3" | grep -v "$2" | grep -v "$3"
}

#
# $1 File to import
#
bpImport() { ## Import file into variable
  if [ -f "$1" ]; then
    cat "$1"
  fi
}

#
# $1 file
# $2 match
# $3 text to insert
#
bpInsert() { ##I Insert text into file
  a=$(grep -A 10000 "$2" <"$1" | grep -v "$2")
  b=$(grep -B 10000 "$2" <"$1" | grep -v "$2")

  echo "$b" "$3" "$a" >|"$1"
}

##C- IHELP Input

#
# $1  Question string
# $2  Default value
# return string read from cmdline/default if enter pressed
#
bpReadStr() { ##I Read string from commandline

  if [ "${2}" == "" ]; then
    read -erp "${1} > " result
  else
    read -erp "${1} [$2] > " result
    if [ "${result}" == "" ]; then
      result="${2}"
    fi
  fi

  echo "${result}"
}

#
# $1  Question string
# $2  Default value
# $3  min value
# $4  max value
# return integer read from cmdline/default if enter pressed
#
bpReadInt() { ##I Read integer from commandline
  while true; do
    if [ "${2}" == "" ]; then
      read -erp "${1} ($3-$4) >" result
      if [ "${result}" == "" ]; then
        result=$(($3 - 1))
      fi
    else
      read -erp "${1} ($3-$4) [$2] >" result
      if [ "${result}" == "" ]; then
        result="${2}"
      fi
    fi
    if [ $((result)) -ge "$3" ] && [ $((result)) -le "$4" ]; then
      break
    fi
  done
  echo "${result}"
}

#
# $1 question text
# $2 default answer 0 = yes, 1 = no
# return 0 = Yes, 1=No
#
bpReadBool() { ##I Ask yes/no question generic
  while true; do

    if [ "$2" -eq 1 ]; then
      yn=$(bpReadStr "${1} [y/N]")
    else
      yn=$(bpReadStr "${1} [Y/n]")
    fi

    case "$yn" in
    [Yy]*)
      return 0
      break
      ;;
    [Nn]*)
      return 1
      break
      ;;
    "")
      return "$2"
      break
      ;;
    *) echo "Please answer yes or no." ;;
    esac
  done
}

#
# $1 Question text
# return 0 = Yes, 1=No
#
bpReadBoolDY() { ##I Ask yes/no question default yes
  bpReadBool "$1" 0
  return $?
}

#
# $1 Question text
# return 0 = Yes, 1=No
#
bpReadBoolDN() { ##I Ask yes/no question default no
  bpReadBool "$1" 1
  return $?
}

#---------------------------------------------------------------------
#
#---------------------------------------------------------------------

# Settings file ------------------------------------------------------

##C- BP_CONF Bashplate settings

#
# $1 config file
# $2 setting name
# $3 setting value
# $4 setting description
#
bpAddSetting() {

  if ! bpStrExist "${1}" "${2}"; then
    {
      echo "# ${4}"
      echo "${2}=\"${3}\""
      echo
    } >>"${1}"
  fi
}

bpAddSettings() {
  bpAddSetting "$BP_SETTINGS" "BP_NAME" "John Doe" "Name of user"
  bpAddSetting "$BP_SETTINGS" "BP_EMAIL" "JohnDoe@foo.bar" "Email of user"
  bpAddSetting "$BP_SETTINGS" "BP_EDITOR" "vi" "Default editor"
  bpAddSetting "$BP_SETTINGS" "BP_LICENSE" "MIT" "Default project license"
  bpAddSetting "$BP_SETTINGS" "BP_ORG" "ACME" "Default organisation"
  bpAddSetting "$BP_SETTINGS" "BP_DIFF" "meld" "Default diff program"
  bpAddSetting "$BP_SETTINGS" "BP_PATH" "${BP_SELF_DIR}" "Path to Bashplates directory"
}

# Change setting in config file (key value pair)
#
# $1 config file
# $2 setting to change
# $3 new value for setting
#
bpChSetting() {
  SETTING="$2"
  VAL="$3"

  S=$(bpStrExist "${1}" "${2}")
  if [ "${S}" == "0" ]; then
    bpAddSettings
  fi
  sed -i "s/^\(${SETTING}\s*=\s*\).*\$/\1$VAL/" "$1"

  bpOk "Setting ${SETTING} to ${VAL}"
}

bpCreateSettings() {
  bpInfo "Creating new bashplates settings. $(bpColorizeFile "${BP_SETTINGS}")"
  bpMkDir "${BP_SETTINGS_DIR}"
  bpMkDir "${BP_SETTINGS_PATHS}"
  bpMkDir "${BP_SETTINGS_MODULES}"

  # if file does not exist add header
  if [ ! -e "${BP_SETTINGS}" ]; then
    echo "# " >>"${BP_SETTINGS}"
    echo "# Bashplates common settings" >"${BP_SETTINGS}"
    echo "# " >>"${BP_SETTINGS}"
    echo >>"${BP_SETTINGS}"
  fi
  bpAddSettings
}

bpLoadSettings() {
  if [ -n "${BP_SETTINGS}" ]; then
    if [ -e "${BP_SETTINGS}" ]; then
      source "${BP_SETTINGS}"
    else
      bpCreateSettings
      source "${BP_SETTINGS}"
    fi
  fi
}

settings() { ##C BP_CONF Print bashplate settings
  bpPrintLine "Bashplates settings"
  bpPrintVar "Name:" BP_NAME
  bpPrintVar "Email:" BP_EMAIL
  bpPrintVar "Default license:" BP_LICENSE
  bpPrintVar "Default editor" BP_EDITOR
  bpPrintVar "Default organisation" BP_ORG
  bpPrintVar "Default diff program" BP_DIFF
  bpPrintLine
}

setname() { ##C BP_CONF Set name
  bpChSetting "${BP_SETTINGS}" "BP_NAME" "\"${2}\""
}

setemail() { ##C BP_CONF Set email address
  bpChSetting "${BP_SETTINGS}" "BP_EMAIL" "\"${2}\""
}

seteditor() { ##C BP_CONF Set default editor
  bpChSetting "${BP_SETTINGS}" "BP_EDITOR" "\"${2}\""
}

setlic() { ##C BP_CONF Set default license
  bpChSetting "${BP_SETTINGS}" "BP_LICENSE" "\"${2}\""
}

setorg() { ##C BP_CONF Set default organisation
  bpChSetting "${BP_SETTINGS}" "BP_ORG" "\"${2}\""
}

setdiff() { ##C BP_CONF Set default diff program
  bpChSetting "${BP_SETTINGS}" "BP_DIFF" "\"${2}\""
}

##C- IHELP Bashrc path/module handling

bpLsPaths() { ##I List paths
  shopt -s nullglob dotglob
  for p in "${BP_SETTINGS_PATHS}"/*; do
    echo "A: $(readlink "${p}")"
  done
}

#
# $1 directory to add to path
#
bpAddPath() { ##I Add dir to PATH variable
  ll=$(echo "${1}" | sed -e 's/\//_/g')

  bpInfo "Adding PATH \"${2}\""
  if [ ! -L "$1" ]; then
    bpLn "${1}" "${BP_SETTINGS_PATHS}/${ll}"
  fi
}

bpRmPath() { ##I Remove path
  bpRm "${BP_SETTINGS_PATHS}/${1}"
}

bpLsModules() { ##I List modules
  shopt -s nullglob dotglob
  for p in "${BP_SETTINGS_MODULES}"/*; do
    readlink "${p}"
  done
}

bpAddModule() { ##I Add init script to
  m=$(realpath "${1}")
  if [ ! -L "$m" ]; then
    rm -f "${BP_SETTINGS_MODULES}/$(basename "${m}")"
    bpLn "$m" "${BP_SETTINGS_MODULES}/."
  fi
}

bpRmModule() { ##I Remove module
  bpRm "${BP_SETTINGS_MODULES}/${1}"
}

##-

# Logging ---------------------------------------------------------

##C- IHELP Log functions

#
# Function logging to file
#
# $1 String to log to file
#
bpLog() { ##I Log to file command
  # check for BP_LOGFILE variable
  if [ -n "$BP_LOGFILE" ]; then
    ts=$(date +"%Y-%m-%d %H:%M:%S")
    bpFilterEscape "$ts $1" >>"${BP_LOGFILE}"
  fi
}

bpLogOk() { ##I Log Ok message to file
  bpLog "[ Ok ] $1"
}

bpLogInfo() { ##I Log Info message to file
  bpLog "[Info] $1"
}

bpLogWarning() { ##I Log Warning message to file
  bpLog "[Warn] $1"
}

bpLogError() { ##I Log Error message to file
  bpLog "[Erro] $1"
}

bpLogCritical() { ##I Log Critical message to file
  bpLog "[Crit] $1"
}

log() { ##C BP_LOGFILE View logfile
  if [ -n "$BP_LOGFILE" ]; then
    if [ -f "${BP_LOGFILE}" ]; then # Check that logfile exists
      D=$(sed -r -e "s|\[Info\]|\[\\${BP_C_INFO}Info\\${E_RESET}\]|" \
        -e "s|\[Warn\]|\[\\${BP_C_WARNING}Warn\\${E_RESET}\]|" \
        -e "s|\[Erro\]|\[\\${BP_C_ERROR}Erro\\${E_RESET}\]|" \
        -e "s|\[ Ok \]|\[\\${BP_C_OK} Ok \\${E_RESET}\]|" \
        -e "s/[-0-9]+/\\${BP_C_DATE}&\\${E_RESET}/1" \
        -e "s/[:0-9]+/\\${BP_C_TIME}&\\${E_RESET}/6" \
        -e "s|\[Crit\]|\[\\${E_BG_RED}\\${E_WHITE}Crit\\${E_RESET}\]|" <"${BP_LOGFILE}")

      echo -e "$D"
    fi
  else
    bpInfo "Logging is not activated"
    bpExit
  fi
}

mlog() { ##C BP_LOGFILE Monitor logfile
  if [ -n "$BP_LOGFILE" ]; then
    if [ -f "${BP_LOGFILE}" ]; then # Check that logfile exists
      tail -f "${BP_LOGFILE}" | sed -r -e "s|\[Info\]|\[\\${BP_C_INFO}Info\\${E_RESET}\]|" \
        -e "s|\[Warn\]|\[\\${BP_C_WARNING}Warn\\${E_RESET}\]|" \
        -e "s|\[Erro\]|\[\\${BP_C_ERROR}Erro\\${E_RESET}\]|" \
        -e "s|\[ Ok \]|\[\\${BP_C_OK} Ok \\${E_RESET}\]|" \
        -e "s/[-0-9]+/\\${E_GREEN}&\\${E_RESET}/1" \
        -e "s/[:0-9]+/\\${E_BR_GREEN}&\\${E_RESET}/6" \
        -e "s|\[Crit\]|\[\\${E_BG_RED}\\${E_WHITE}Crit\\${E_RESET}\]|"

    fi
  else
    bpInfo "Logging is not activated"
    bpExit
  fi
}

##C- IHELP Message

bpOk() { ##I Success message
  if [ -n "$BP_LOG_OK" ]; then
    bpLogOk "$1"
  fi
  echo -e "[${BP_C_OK}Ok${E_RESET}] $1"
}

bpInfo() { ##I Info message
  if [ -n "$BP_LOG_INFO" ]; then
    bpLogInfo "$1"
  fi
  echo -e "[${BP_C_INFO}Info${E_RESET}] $1"
}

bpDbg() { ##I Debug message
  if [ -z "$BP_DEBUG" ]; then
    return
  fi
  if [ -n "$BP_LOG_INFO" ]; then
    bpLogDebug "$1"
  fi

  echo -e "[${BP_C_DEBUG}Dbg${E_RESET}] $1"
}

bpWarning() { ##I Warning message
  if [ -n "$BP_LOG_WARNING" ]; then
    bpLogWarning "$1"
  fi
  echo -e "[${BP_C_WARNING}Warning${E_RESET}] $1"
}

bpError() { ##I Error message
  if [ -n "$BP_LOG_ERROR" ]; then
    bpLogError "$1"
  fi
  echo -e "[${BP_C_ERROR}Error${E_RESET}] $1"
}

bpCritical() { ##I Critical error message
  if [ -n "$BP_LOG_CRITICAL" ]; then
    bpLogCritical "$1"
  fi
  echo -e "[${BP_C_CRITICAL}Critical${E_RESET}] $1"
  bpExit
}

# Various  ---------------------------------------------------------

##C- IHELP Assert

bpAssertRoot() { ##I Assert that user is root
  if [ "$(whoami)" != root ]; then
    bpError "Must be root to use this command."
    bpExit "1"
  fi
}

bpAssertNoLockFile() { ##I Assert that lockfile is not present
  if [ -n "$BP_LOCK_FILE" ]; then
    if [ -f "$BP_LOCK_FILE" ]; then
      bpError "Script is already running. (${BP_LOCK_FILE})"
      exit "1" # do not use bpExit because lock file belongs to prexsisting process
    fi
    touch "$BP_LOCK_FILE"
  fi
}

#
# $1 string list of programs that are required
#
bpAssertProgs() { ##I Assert that required programs are available on the system
  things=("$@")
  e=0
  for thing in "${things[@]}"; do
    hash "$thing" 2>&- ||
      {
        bpError "Required program \"$thing\" not found."
        e=1
      }
  done
  if [ $e -eq 1 ]; then
    bpExit 1
  fi
}

##C- IHELP Debug/Controll

icheck() { ##I Run shellcheck on script
  bpAssertProgs "shellcheck"
  shellcheck "$0"
}

irt() { ##I Remove tabs from script
  sed -i -e 's/\t/  /g' "${BP_SELF_DIR}/${BP_SELF}"
}

##C- IHELP Help & info

printCommand() {
  IFS=$' '
  read -r -a arr <<<"$1"
  inf="${arr[*]:3}"
  #IFS=$'\n'
  bpPrintInfo "${arr[0]}" "${inf}"
}

printCondCommand() {
  IFS=$' '
  read -r -a arr <<<"$1"
  help_info="${arr[*]:4}"
  COND=${arr[3]}
  eval "D=\$$COND"

  if [ -n "$D" ]; then
    bpPrintInfo "${arr[0]}" "${help_info}"
  else
    if [ "$2" -eq 1 ]; then
      bpPrintInfoAlt "${arr[0]}" "$help_info"
    fi
  fi
}

printNamedLine() {
  IFS=$' '
  read -r -a arr <<<"$1"
  info=${arr[*]:1}
  bpPrintLine "${info}"
}

printCondNamedLine() {
  IFS=$' '
  read -r -a arr <<<"$1"
  name=${arr[*]:2}
  COND=${arr[1]}
  eval "D=\$$COND"
  if [ -n "$D" ]; then
    bpPrintLine "$name"
  fi
}

help() { ##D Print help information
  echo "$BP_USAGE"
  echo -e "$BP_DESC"
  echo

  BP_HELP=1

  if [ ! -e "${BP_SETTINGS_DIR}" ] && [ -n "${BP_SETTINGS}" ]; then
    BPINIT=1
  fi

  # bpExecHook "PRE_HELP_HOOK"
  if [ -n "$PRE_HELP_HOOK" ]; then
    "${PRE_HELP_HOOK}"
  fi

  IFS=$'\n'
  SC="$1"
  HELP_LINES=$(grep -h '##' "$0" | grep -v -e 'grep' -e '##I' -e '##V' -e '\*##C' -e '\*##C-' -e '\"##' -e '##-//' -e 'help_line' -e 'printLine')
  HELP_LINES="${HELP_LINES//()/}"

  for help_line in ${HELP_LINES}; do
    case "$help_line" in
    *"##-"*) printNamedLine "$help_line" ;;
    *"##C-"*) printCondNamedLine "$help_line" ;;
    *"##CV"*) printCondCommand "$help_line" 1 ;;
    *"##C"*) printCondCommand "$help_line" 0 ;;
    *"##D"*) printCommand "$help_line" '##D' ;;
    *) ;;

    esac
  done

  if [ -n "$POST_HELP_HOOK" ]; then
    "${POST_HELP_HOOK}"
  fi
}

#
# $1 command
#
ihelp() { ##I Print internal help information

  # Singe command documentation
  if [ "$2" != "" ]; then
    echo
    bpPrintLine "$2"
    echo
    echo "#"
    echo -n "# "
    grep --no-filename "$0" -e "${2}()" | sed -n -e 's/^.*##I //p'
    grep --no-filename -B 8 "$0" -e "${2}()" | grep "#" | grep -v "##"
    bpPrintLine
    bpExit
  fi

  IFS=$'\n'
  SC="$1"

  IHELP=1      # Force ihelp documentations
  BP_LOGFILE=1 # Force log documentation

  help_lines=$(grep -h '##[C|I|-]' "$0" | grep -v -e 'grep' -e '\*"##[ A-Z]"\*' -e 'help_line' -e 'printNamedLine' -e 'awk' -e 'bpPrintInfo' -e 'name')
  help_lines=$(echo -e "$help_lines" | sed -s 's/()//g')

  for help_line in ${help_lines}; do
    case "$help_line" in
    *"##-"*) printNamedLine "$help_line" ;;
    *"##C-"*) printCondNamedLine "$help_line" ;;
    *"##I"*) printCommand "$help_line" '##I' ;;
    *"##C"*) printCondCommand "$help_line" 0 ;;
    *) ;;

    esac
  done

  bpPrintLine "Bashplates comments"
  bpPrintInfo "##D Description" "Subcommand information comment (shown with help)"
  bpPrintInfo "##C COND Description" "Conditional subcommand comment (shown with help)"
  bpPrintInfo "##- [Text]" "Separator line (shown with help)"
  bpPrintInfo "##C- COND [Text]" "Conditional separator line (shown with help)"
  bpPrintInfo "##I Description" "Internal function comment (shown ihelp)"
  bpPrintLine
}

iinfo() { ##I Show information about script
  bpPrintLine "Script information"
  bpPrintVar "Script" BP_SELF "$(bpColorizeFile "${BP_SELF_DIR}/${BP_SELF}")"
  bpPrintVar "Script version" BP_VERSION
  bpPrintVar "Template version" BP_VERSION
  bpPrintVar "Bashplate settings file" BP_SETTINGS "$(bpColorizeFile "${BP_SETTINGS}")"
  bpPrintVar "Log file" BP_LOGFILE "$(bpColorizeFile "${BP_LOGFILE}")"
  bpPrintVar "Lock file" BP_LOCK_FILE "$(bpColorizeFile "${BP_LOCK_FILE}")"
  bpPrintVar "Default function" DEFAULT_CMD_HOOK
  bpPrintInfo "PID" $$
  bpPrintVar "Date" BP_DATE
  bpPrintVar "Time" BP_TIME
  bpPrintVar "Character columns" BP_COLUMNS
  bpPrintVar "Character lines" BP_LINES

  if [ -n "${POST_INFO_HOOK}" ]; then
    bpPrintLine "App. information"
    ${POST_INFO_HOOK}
  fi
  settings
}

#
# $1 command to check
#
bpHasCmd() { ##I Check if command is available
  if [ -x "$(command -v "${1}")" ]; then
    return 0
  else
    return 1
  fi
}

#
iview() { ##I View example
  # Singe command documentation
  if [ "$2" == "" ]; then
    bpExit
  fi

  if bpHasCmd batcat; then # Use batcat, if available, to view function
    grep --no-filename -A 60 "$0" -e "${2}()" | grep -B 60 -m 1 -x "}" | batcat --language bash
  else
    echo
    bpPrintLine "$2"
    echo
    grep --no-filename -A 60 "$0" -e "${2}()" | grep -B 60 -m 1 -x "}" |
      sed -e "s/#.*/\\${BP_C_COMMENT}&\\${E_RESET}/" \
        -e "s/\<echo\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<if\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<then\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<else\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<fi\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<do\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<done\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<elif\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<case\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<esac\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<for\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<in\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<select\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<time\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<until\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<select\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<eval\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<break\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<while\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\".*\"/\\${BP_C_STRING}&\\${E_RESET}/" \
        -e "s/\([^=]*\)=/${BP_C_VAR}\1\\${E_RESET}=/"
    #             -e $VF
    #             -e 's/\$[{]?[a-zA-Z0-9]*[}]?/XXX/'
    #             -e 's/$?/'"\\${BP_C_VAR}&\\${E_RESET}/" \
    bpPrintLine
  fi
  bpExit
}

ivars() { ##I Print internal variables
  bpPrintLine "Script variables"
  echo
  IFS=$'\n'
  help_lines=$(grep -v -e 'help_lines' -e 'help_line' "$0" | grep -A 1 '##V') # | sed "s/--//" )
  for line in ${help_lines}; do
    if [ "$line" == "--" ]; then
      echo
    else
      help_line=$(echo "${line}" | sed -u -e "s/##V[ ]/${BP_C_DESCRIPTION}/i" -e "s/^.*=/${BP_C_ID}&${E_RESET}/i" -e "s/=/${E_RESET}=/")
      echo -e "$help_line"
      echo -en "$E_RESET"
    fi
  done
  echo
}

ied() { ##I Open this file with default editor
  bpEdit "$0" "$2"
}

version() { ##D Print version information
  echo "$BP_VERSION"
}

# Runs a function in this file as a command
bpRunCommand() {
  if [ "$BP_ARGUMENTS" -eq 0 ]; then

    # check for a default command
    if [ -n "$DEFAULT_CMD_HOOK" ]; then
      "$DEFAULT_CMD_HOOK" "$1" "$2" "$3" "$4" "$5" "$6" "$7" "$8" "$9" "${10}"
      bpExit
    fi
    bpErrorExit "No command given"
  fi

  if [ "$(type -t "$1")" != "function" ]; then # Check if subcommand is declared as function
    bpErrorExit "Command \"$1\" not found"
  fi

  command=$1
  # execute pre command hook  if existing
  if [ -n "$PRE_CMD_HOOK" ]; then
    "${PRE_CMD_HOOK}" "$command"
  fi

  # Check if command is conditional
  CL=$(grep -E "${command}().*##C" "$0")
  if [[ "$CL" = *"##C"* ]]; then

    # Check if condition is true and then execute else printout error message
    read -r -a ARR <<<"$CL"
    CV="${ARR[3]}"
    if [ -n "$CV" ]; then
      eval "D=\$$CV"
      if [ -n "$D" ]; then
        # execute command
        "${command}" "$@"
      else
        bpError "Command \"$command\" not available right now."
      fi
    else
      bpError "Command \"$command\" is conditional, but is missing conditional variable"
    fi
  else
    # command is not conditional, execute
    "${command}" "$@"
  fi

  # execute post command hook  if existing
  if [ -n "$POST_CMD_HOOK" ]; then
    "${POST_CMD_HOOK}" "$command"
  fi
  bpExit
}

#---------------------------------------------------------------------
# Initiate internal variables
#---------------------------------------------------------------------

##V Bashplate version
BP_VERSION="1.20"

##V Directory where script is located
BP_SELF_DIR="${0%/*}"

##V Name of script
BP_SELF=$(basename "$0")

##V Number of arguments given to script
BP_ARGUMENTS=$#

##V Current date
BP_DATE=$(date +"%Y-%m-%d")

##V Current time
BP_TIME=$(date +"%H:%M:%S")

##V Number of columns in terminal
BP_COLUMNS=$(tput cols)

##V Number of lines in terminal
BP_LINES=$(tput lines)

##V Settings directory
BP_SETTINGS_DIR=~/.config/bashplates

##V Settings file
BP_SETTINGS=${BP_SETTINGS_DIR}/bashplates.conf

##V System Path's
BP_SETTINGS_PATHS="${BP_SETTINGS_DIR}/path"

##V Links to modules
BP_SETTINGS_MODULES="${BP_SETTINGS_DIR}/modules"

# Initiate bashplate settings
bpInitSettings

# Initiate user settings
bpUserSettings

#---------------------------------------------------------------------
# Setup signal traps
#---------------------------------------------------------------------

trap signalQuit SIGQUIT
trap signalInt SIGINT
trap signalHup SIGHUP
trap signalTerm SIGTERM
trap 'signalErr ${FUNCNAME} ${LINENO}' ERR

#trap  'signalDbg ${FUNCNAME} ${LINENO}' DEBUG

#---------------------------------------------------------------------
# Load settings and execute script handler
#---------------------------------------------------------------------

# Load configuration file settings
bpLoadSettings

# execute prescript hook if existing
if [ -n "$PRE_SCRIPT_HOOK" ]; then
  ${PRE_SCRIPT_HOOK} "$@"
fi

# Run command parser
bpRunCommand "$@"

# Exit cleanly
bpExit

##C- BP_HELP
