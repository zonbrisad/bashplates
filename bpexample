#!/usr/bin/env bash
# shellcheck disable=2034
#---------------------------------------------------------------------
#
#  [Description]
#    Bashplate example script. This script inludes a number of examples
#    demonstrating a number features of the bashplate template.
#  
#  [Author] 
#    Peter Malmberg <peter.malmberg@gmail.com>
#
#  [License] 
#     MIT
#    
#---------------------------------------------------------------------
# [Bashplates]
# This script is generated from bashplates template generator.
# 
# Bashplates is developed by:
# Peter Malmberg <peter.malmberg@gmail.com>
#
# Bashplates is available at:
# https://github.com/zonbrisad/bashplates
#---------------------------------------------------------------------
#

# Display commands as they are executed
#set -o xtrace
# Display shell input lines as they are read
#set -v

# Exit script when a command fails. Append ||true if error is expected
set -o errexit # || true
# Exit script when undeclared variable is used
#set -o nounset
# Exit script when pipe fails
set -o pipefail

# Directory where script is located
scriptPath=$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )

# Name of script
scriptName=$(basename "$0")

#---------------------------------------------------------------------
# User defined Settings
#---------------------------------------------------------------------


#---------------------------------------------------------------------
# User defined functions
#---------------------------------------------------------------------

##N- Bashplate tests



tlTest() { ## Test textline
	bpTextLineC "Green" ${E_BR_GREEN} ${E_GREEN} "_"
	bpTextLineC "Magenta" ${E_BR_MAGENTA} ${E_MAGENTA} "_"
	bpTextLineC "Blue" ${E_BR_BLUE} ${E_BLUE} "_"
	bpTextLineC "Red" ${E_BR_RED} ${E_RED} "_"
	bpTextLineC "Yellow" ${E_BR_YELLOW} ${E_YELLOW} "_"
	bpTextLineC "Cyan" ${E_BR_CYAN} ${E_CYAN} "_"
	bpTextLineC "White" ${E_WHITE} ${E_GRAY} "_"
	bpTextLine "Standard colors"
}


errorTest() { ## Test of error messages
  echo $LOGFILE
	bpInfo "Info test"
  bpWarning "Warning test"
	bpError "Error test"
	bpCritical "Critical test"
}

print_bar() {
  echo -n " ["
	for jx in $(seq 1 ${2}); do
	  echo -n "="
	done
	for jx in $(seq 1 $((${1} - ${2}))); do
	  echo -n " "
	done
	echo  "]"   
}

bar() { ## print a testbar (ANSI)
  echo -en $E_HID
  for i in {1..30}; do
	  sleep 0.03
		print_bar 30 $i
		echo -e $E_RETURN $E_UP 
	done
  echo -e $E_SHOW
}

shade() { ## Shade demo (256 color terminal required)
  echo -en $E_HID
  for i in {232..255} {255..232} ; do
	  sleep 0.05
		printf "\x1b[38;5;%sm _____ Shading text _____ ${E_END}" "$i"
		echo -e $E_RETURN
	done
  echo -e $E_SHOW
}

clean() { ## Remove leftover files
  find . -name "*~" -delete
}

traptest() { ## Trap signal test
  read -p "Press CTRL-C" -t 30
}

color-test() { 
  echo -e "$1${E_ON_RED}$2 on RED${E_END}"
  echo -e "$1${E_ON_GREEN}$2 on GREEN${E_END}"
  echo -e "$1${E_ON_YELLOW}$2 on YELLOW${E_END}"
  echo -e "$1${E_ON_BLUE}$2 on BLUE${E_END}"
  echo -e "$1${E_ON_MAGENTA}$2 on MAGENTA${E_END}"
  echo -e "$1${E_ON_CYAN}$2 on CYAN${E_END}"
  echo -e "$1${E_ON_WHITE}$2 on WHITE${E_END}"
  echo -e "$1${E_ON_BLACK}$2 on BLACK${E_END}"
}

#colorss=("A" "B" "C")

color1() { ## Standard 16 colors 
  FCOLORS=( ${E_BLACK} ${E_RED} ${E_GREEN} ${E_YELLOW} ${E_BLUE} ${E_MAGENTA} ${E_CYAN} ${E_GRAY} ${E_DARKGRAY} ${E_BR_RED} ${E_BR_GREEN} ${E_BR_YELLOW} ${E_BR_BLUE} ${E_BR_MAGENTA} ${E_BR_CYAN} ${E_WHITE} )
  BCOLORS=( ${E_ON_BLACK} ${E_ON_RED} ${E_ON_GREEN} ${E_ON_YELLOW} ${E_ON_BLUE} ${E_ON_MAGENTA} ${E_ON_CYAN} ${E_ON_WHITE} )

  FCOLORS2=( E_BLACK E_RED E_GREEN E_YELLOW E_BLUE E_MAGENTA E_CYAN E_GRAY E_DARKGRAY E_BR_RED E_BR_GREEN E_BR_YELLOW E_BR_BLUE E_BR_MAGENTA E_BR_CYAN E_WHITE )
	BCOLORS2=( E_ON_BLACK E_ON_RED E_ON_GREEN E_ON_YELLOW E_ON_BLUE E_ON_MAGENTA E_ON_CYAN E_ON_WHITE )

  echo
  for fc in ${FCOLORS2[*]}; do
	  eval "FG=\$$fc"
		for bc in ${BCOLORS2[*]}; do
		  eval "BG=\$$bc"
      printf "${FG}${BG}%-15s${E_END}" $fc
		done
		echo
	done

  echo
	return
  for fc in ${FCOLORS[*]}
	do
	  for bc in ${BCOLORS[*]}
		do
		  echo  -en "${fc}${bc}   XXXX   ${E_END}"
		done
			  echo ""
	done
	echo -e "\n\n"
}	

attr() { ## demonstrate font attributes
  echo
  echo -e "${E_ATTR_UNDERLINE}Underline${E_END}"
  echo -e "${E_ATTR_BOLD}Bold${E_END}"
  echo -e "${E_ATTR_BLINK}Blink${E_END}"
  echo -e "${E_ATTR_LOWI}Low Intensity${E_END}"
  echo -e "${E_ATTR_REVERSE}Reverse video${E_END}"
  echo
}

color2() { ## Show example of all 256 colors
	
  echo
	bpTextLine "256 Colors foreground"
	echo
	for i in {0..231} ; do
	  printf "\x1b[38;5;%sm  %3d  ${E_END} " "$i" "$i"
	  if (( i == 7 )) || (( i == 15 )) || ((( i > 15 )) && (( (i-15) % 6 == 0 ))); then
		  echo
			
			if (( i == 15)); then
			  echo
			fi
	  fi
	done
	
	echo
	for i in {232..255} ; do
	  printf "\x1b[38;5;%sm %3d ${E_END}" "$i" "$i"
	  if (( i == 243 )); then 
	    echo
	  fi
	done
  echo -e "\n"


  echo
	bpTextLine "256 Colors background"
	echo
	for i in {0..231} ; do
	  printf "\x1b[48;5;%sm  %3d  ${E_END} " "$i" "$i"
	  if (( i == 7 )) || (( i == 15 )) || ((( i > 15 )) && (( (i-15) % 6 == 0 ))); then
		  echo
			
			if (( i == 15)); then
			  echo
			fi
	  fi
	done
	
	echo
	for i in {232..255} ; do
	  printf "\x1b[48;5;%sm %3d ${E_END}" "$i" "$i"
	  if (( i == 243 )); then 
	    echo
	  fi
	done
  echo -e "\n"



}


rootTest() { ## Test assert root
  assertRoot
  echo "Great you are root"
}

lockTest() { ## Lock file test
  assertNoLockFile
  ${scriptPath}/bpexample lockTest	
}

assertProgs() { ## Assert required programs test 
  assertRequiredProgs
}

prefunc() {
  echo -e "${E_WHITE}Prefunc${E_END} -------------------------------------------------------"
}

postfunc() {
  echo -e "${E_WHITE}Postfunc${E_END} ------------------------------------------------------"
}

infoHook() {
	printVar "Test1"       "Information test1"
	printVar "Test2"       "Information test2"
}


appendTest() { ## Testing append line to file function
  rm -f append
	touch append
	
  appendIfNoSuchLine "append" "Line to append1"
	appendIfNoSuchLine "append" "Line to append2"
	appendIfNoSuchLine "append" "Line to append3"
	
	echo "File first time"
	cat append

  appendIfNoSuchLine "append" "Line to append1"
	appendIfNoSuchLine "append" "Line to append2"
	appendIfNoSuchLine "append" "Line to append3"

  echo -e "\nFile second time"
	cat append

  removeLineContaining "append" "append2"
  echo -e "\nFile third time"
	cat append
  

}

#--------------------------------------------------------------------- 
# Bashplate settings
#---------------------------------------------------------------------

# Script version info
VERSION="1.05"

##V Bashplate version
BPVERSION="1.09"   

##V Usage info
USAGE="Usage: ${scriptName} command [option]" 

# Description text
DESC="This script demonstrates some of the features of the bashplate template."

##V logfile (uncomment to use logfile)
LOGFILE=${scriptPath}/${scriptName}.log

##V Logging options (uncomment to activate logging parameters)
LOG_INFO=1
LOG_WARNING=1
LOG_ERROR=1
LOG_CRITICAL=1

##V Default command (uncomment to use a default command )
DEFAULT=help

##V Pre script hook, execute this function before every command
#PREHOOK=prefunc

##V Post script hook, execute this function after every command
#POSTHOOK=

##V Function to be executed before every other cmd except DEFAULT function
#PRECMDHOOK=

##V Function to be executed after every other function except DEFAULT function
#POSTCMDHOOK=postfunc

##V Function to be executed after information command
INFOHOOK=infoHook

##V Programs that are required to run the script (uncomment to use)
REQUIRED_PROGRAMS=(ls nisse)

##V Lock file (uncomment to use lock file feature )
#LOCK_FILE=/tmp/${scriptName}.lock

# Activate settings function (will create settings file when run)
SETTINGS=1

# Create settings file if non existent
#CREATEPLSETTINGS=1

bpSettingsDir=~/.config/bashplates
bpSettings=${bpSettingsDir}/bashplates.conf

#--------------------------------------------------------------------- 
# Signal traps
#---------------------------------------------------------------------

signalInt() {
  bpCleanUp
  exit "$BP_E_OK"
}

signalHup() {
  bpCleanUp
}

signalQuit() {
  echo "Quit"
  bpCleanUp
}

signalTerm() {
  echo "Term"
  bpCleanUp
}

bpCleanUp() { ##D Cleanup function 
  rm -f "$LOCK_FILE"    # remove Lock file
}

bpExit() { ##D Function for safely exiting script
  bpCleanUp
	
  # execute postscript hook if existing
  if [ -n "$POSTHOOK" ]; then
     ${POSTHOOK}
  fi
	
  exit
}

bpErrorExit() {  ##D Safely exit script with a error 
  #echo -e "${BP_C_ERROR}${1}${E_END}"
  bpError "${1}"
  bpCleanUp
  exit
}

#--------------------------------------------------------------------- 
# Bashplate internal functions
#---------------------------------------------------------------------

# ANSI foreground colors codes
#

E_BLACK=$'\e[0;30m'        # Black 
E_RED=$'\e[0;31m'          # Red
E_GREEN=$'\e[0;32m'        # Green
E_YELLOW=$'\e[0;33m'       # Yellow
E_BLUE=$'\e[0;34m'         # Blue
E_MAGENTA=$'\e[0;35m'      # Magenta
E_CYAN=$'\e[0;36m'         # Cyan
E_GRAY=$'\e[0;37m'         # Gray
E_DARKGRAY=$'\e[1;30m'     # Dark Gray
E_BR_RED=$'\e[1;31m'       # Bright Red
E_BR_GREEN=$'\e[1;32m'     # Bright Green
E_BR_YELLOW=$'\e[1;33m'    # Bright Yellow
E_BR_BLUE=$'\e[1;34m'      # Bright Blue
E_BR_MAGENTA=$'\e[1;35m'   # Bright Magenta
E_BR_CYAN=$'\e[1;36m'      # Bright Cyan
E_WHITE=$'\e[1;37m'        # White

# ANSI background color codes
#
E_ON_BLACK=$'\e[40m'       # Black
E_ON_RED=$'\e[41m'         # Red
E_ON_GREEN=$'\e[42m'       # Green
E_ON_YELLOW=$'\e[43m'      # Yellow
E_ON_BLUE=$'\e[44m'        # Blue
E_ON_MAGENTA=$'\e[45m'     # Magenta
E_ON_CYAN=$'\e[46m'        # Cyan
E_ON_WHITE=$'\e[47m'       # White

# ANSI Text attributes
E_ATTR_BOLD=$'\e[1m'
E_ATTR_LOWI=$'\e[2m' 
E_ATTR_UNDERLINE=$'\e[4m'
E_ATTR_BLINK=$'\e[5m'
E_ATTR_REVERSE=$'\e[7m'

# ANSI cursor operations
#
E_RETURN=$'\e[F'           # Move cursor to begining of line
E_UP=$'\e[A'               # Move cursor one line up
E_DOWN=$'\e[B'             # Move cursor one line down
E_FORWARD=$'\e[C'          # Move cursor forward
E_BACK=$'\e[D'             # Move cursor backward
E_HIDE=$'\e[?25l'          # Hide cursor 
E_SHOW=$'\e[?25h'          # Show cursor 

E_END=$'\e[m'              # Clear Attributes
 
# Internal bashplate colors
BP_C_OK=$E_BR_GREEN
BP_C_INFO=$E_BR_CYAN
BP_C_WARNING=$E_BR_YELLOW
BP_C_ERROR=$E_BR_RED
BP_C_CRITICAL=$E_ON_RED$E_WHITE
BP_C_LINE=$E_DARKGRAY
BP_C_LINE_TEXT=$E_YELLOW

# Exit codes 
#
BP_E_OK=0            # successful termination 



# Print text with row
#
# arg1 text to be printed
# arg2 text color
# arg3 line color
# arg4 middle character
# arg5 line character
bpPrintLineC() { ##D Print text with adjusted line after with selectable colors
  len1=${#1}
  len4=${#4}
	
  echo -en ${2}${1}${4}${3}
  l=$((${COLUMNS} - ${len1} - ${len4} - 3 ))
  seq -s${5} ${l}|tr -d '[:digit:]'
  echo -en ${E_END} 
}

# Print text with row
#
# arg1 text to be printed
# arg2 text color
# arg3 line color
bpTextLineC() { ##D Print text with adjusted line after with selectable colors
  bpPrintLineC "$1" "$2" "$3" " " "-"
}

bpTextLine() { ##D Print text with line after
  bpTextLineC "$1" "${BP_C_LINE_TEXT}" "${BP_C_LINE}"
}

# Print a divider row
bpLine() { ##D Print a line  
  bpPrintLineC "" "${BP_C_LINE}" "${BP_C_LINE}" "" "-" 
}

# Legacy function (do not use in new applications)
printLine() { 
  bpLine
}


# Print text into two columns
#
# arg1 text for column 1
# arg2 text for column 2
printInfo() {  
  printf "${E_BR_CYAN}%-20s${E_END} ${E_BR_GREEN}%s${E_END}\n" "$1" "$2"
}

# Print a variable + text into two columns
#
# arg1 variable for column 1
# arg2 text for column 2
printVar() {
  var="$1"
  if [ "${!var}" ]; then
    printInfo "$2" "${!var}"
  else 
    printf "${E_BR_CYAN}%-20s${E_END} ${E_BR_RED}N/A${E_END}\n" "$2"
  fi
}



#--------------------------------------------------------------------- 
# 
#---------------------------------------------------------------------

# Settings file ------------------------------------------------------


bpAddSetting() {
  echo "# "${3}    >> ${bpSettings}
	echo ${1}"=\""${2}"\"" >> ${bpSettings}
	echo >> ${bpSettings}
}
			
bpCreateSettings() {
			
  echo "Creating new bashplates settings file. ${bpSettings}"
	mkdir -p ${bpSettingsDir}
					
	echo "# " >> ${bpSettings}
	echo "# Bashplates common settings" > ${bpSettings}
	echo "# " >> ${bpSettings}
	echo      >> ${bpSettings}
	
	bpAddSetting "BP_NAME"  "John Doe"        "Name of user"
	bpAddSetting "BP_EMAIL" "JohnDoe@foo.bar" "Email of user"
	bpAddSetting "BP_EDITOR" "vi"             "Default editor"
	bpAddSetting "BP_LICENSE" "MIT"           "Default project license"
}

bpLoadSettings() {
  if [ -n "${bpSettings}" ]; then
	  if [ -e ${bpSettings} ]; then
	    source ${bpSettings}
	  else
		  bpCreateSettings
			source ${bpSettings}
		fi
	fi
}
																														
##N- Settings
printSettings() { ## Print plate information
	bpTextLine "Bashplates settings"
	printVar BP_NAME      "Name:"
	printVar BP_EMAIL     "Email:"
	printVar BP_LICENSE   "Default license:"
	printVar BP_EDITOR    "Default editor"
	bpLine
}

setname() { ## Set name
	chSetting ${bpSettings} "BP_NAME" "\"${2}\""	
}

setemail() { ## Set email address
	chSetting ${bpSettings} "BP_EMAIL" "\"${2}\""	
}

seteditor() { ## Set default editor
	chSetting ${bpSettings} "BP_EDITOR" "\"${2}\""	
}

setlic() { ## Set default license
	chSetting ${bpSettings} "BP_LICENSE" "\"${2}\""	
}


##-

# Logging ---------------------------------------------------------

#
# Function logging to file
#
# Arg1 String to log to file
# 
bpLog() { ##D Log to file command
  # check for LOGFILE variable
  if [ -n "$LOGFILE" ]; then
    ts=$(date +"%Y-%m-%d %H:%M:%S")
     echo "$ts" "$1" >> "${LOGFILE}"
  fi
}

log() { ##C LOGFILE View logfile
  if [ -n "$LOGFILE" ]; then
    if [ -f ${LOGFILE} ]; then  # Check that logfile exists
	
      D=$(sed -r -e "s|\[Info\]|\[\\${BP_C_INFO}Info\\${E_END}\]|"  \
            -e "s|\[Warn\]|\[\\${BP_C_WARNING}Warn\\${E_END}\]|"  \
            -e "s|\[Erro\]|\[\\${BP_C_ERROR}Erro\\${E_END}\]|"    \
            -e "s/[-0-9]+/\\${E_GREEN}&\\${E_END}/1"            \
            -e "s/[:0-9]+/\\${E_BR_GREEN}&\\${E_END}/6"            \
            -e "s|\[Crit\]|\[\\${E_ON_RED}\\${E_WHITE}Crit\\${E_END}\]|" < "${LOGFILE}" ) 

      echo -e "$D"
    fi
  else
    bpInfo "Logging is not activated"
    exit
  fi
}

mlog() {   ##C LOGFILE Monitor logfile
  if [ -n "$LOGFILE" ]; then
    if [ -f ${LOGFILE} ]; then  # Check that logfile exists
      tail -f ${LOGFILE} | sed -r -e "s|\[Info\]|\[\\${BP_C_INFO}Info\\${E_END}\]|"  \
            -e "s|\[Warn\]|\[\\${BP_C_WARNING}Warn\\${E_END}\]|"  \
            -e "s|\[Erro\]|\[\\${BP_C_ERROR}Erro\\${E_END}\]|"    \
            -e "s/[-0-9]+/\\${E_GREEN}&\\${E_END}/1"            \
            -e "s/[:0-9]+/\\${E_BR_GREEN}&\\${E_END}/6"            \
            -e "s|\[Crit\]|\[\\${E_ON_RED}\\${E_WHITE}Crit\\${E_END}\]|" 

		fi
  else
    bpInfo "Logging is not activated"
    exit
  fi
}

bpOk() { ##D Success message 
  bpLog "[ Ok ] $1"
  echo -e "[${BP_C_OK}Ok${E_END}] $1"
}

bpInfo() { ##D Info message 
  if [ -n "$LOG_INFO" ]; then
    bpLog "[Info] $1"
  fi
  echo -e "[${BP_C_INFO}Info${E_END}] $1"
}

bpWarning() { ##D Warning message
  if [ -n "$LOG_WARNING" ]; then	
    bpLog "[Warn] $1"
  fi
  echo -e "[${BP_C_WARNING}Warning${E_END}] $1"
}

bpError() { ##D Error message
  if [ -n "$LOG_ERROR" ]; then
    bpLog "[Erro] $1"  
  fi
  echo -e "[${BP_C_ERROR}Error${E_END}] $1"
}

bpCritical() { ##D Critical error message
  if [ -n "$LOG_CRITICAL" ]; then
    bpLog "[Crit] $1"
  fi
  echo -e "[${BP_C_CRITICAL}Critical${E_END}] $1"
  bpExit
}

assertRoot() { ##D Assert that user is root
  if [ "$(whoami)" != root ]; then
    bpError "Must be root to use this command."
    bpExit
  fi
}


# Various  ---------------------------------------------------------

assertNoLockFile() { ##D Assert that lockfile is not present
  if [ -n "$LOCK_FILE" ]; then 
    if [ -f "$LOCK_FILE" ]; then
      #echo -e "${BP_C_ERROR}Script is already running. (${LOCK_FILE})${E_END} "
      bpError "Script is already running. (${LOCK_FILE})"
      exit  # do not use bpExit because lock belongs to other process
    fi
    touch "$LOCK_FILE"              
  fi
}

assertRequiredProgs() { ##D Assert that required programs are available on the system
  if [ -n "${REQUIRED_PROGRAMS}" ]; then
    for p in ${REQUIRED_PROGRAMS[@]}; do
      hash "$p" 2>&- || \
        { bpError "Required program \"$p\" not found."; exit 1; }
#      { echo -e >&2 "${BP_C_ERROR}Required program \"$p\" not found.${E_END}"; exit 1; }
    done
  fi
}

info() { ##D Show information about script
  bpTextLine "Script information"
  printVar scriptName      "Script name" 
  printVar scriptPath      "Script path" 
  printVar VERSION         "Script version" 
  printVar BPVERSION       "Template version" 
  printVar LOGFILE         "Log file" 
  printVar LOCK_FILE       "Lock file" 
  printVar DEFAULT         "Default function" 
  printVar "REQUIRED_PROGRAMS" "Dependencies"
  printInfo "PID" $$  
  printVar DATE "Date" 
  printVar TIME "Time"
	
  if [ -n "${INFOHOOK}" ]; then
    bpTextLine "App. information"
    ${INFOHOOK}
  fi
}

check() { ##D Make a shellcheck
  shellcheck "$0"
}

# Change setting in config file (key value pair)
#
# arg1 config file
# arg2 setting to change
# arg3 new value for setting
#
chSetting() { 
  SETTING="$2"
  VAL="$3"
  sed -i "s/^\(${SETTING}\s*=\s*\).*\$/\1$VAL/" "$1"
}

# Replace text in file
#
# arg1 file 
# arg2 text to replace
# arg3 new text
bpReplace() {  ##D Replace text in file
  sed -i -e "s/${2}/${3}/g"  $1
}

# Appends a line to a file if it is not present in that file.
#
# $1 file
# $2 line to append
#
appendIfNoSuchLine() { ##D Append a line if it does not exist in file
  grep -q -F "$2" $1 || echo "$2" >> $1
}
	
# Remove line in file containing a given string
#
# $1 file
# $2 string
#
removeLineContaining() { ##D Remove line in file if it contains given string
  grep -v $2 $1 > $1
}
		

printCommand() { 
  help_line=$1
  help_command=$(echo "$help_line" | sed -s 's/(.*//')
  help_info=$(echo "$help_line" | sed -s 's/^.*'"$2"'//')
  printInfo "$help_command" "$help_info" 
}

printCondCommand() {
  help_line=$1
  C=$(echo "$1" | sed -s 's/^.*##C//' | awk '{print $1}')
  eval "D=\$$C"
  if [ -n "$D" ]; then
    help_command=$(echo "$help_line" | sed -s 's/(.*//')
    help_info=$(echo "$help_line" | sed -s 's/^.*'"$C"'//')
    printInfo "$help_command" "$help_info"
  fi
}

printCondLine() {
  help_line=$1
  C=$(echo "$1" | sed -s 's/^.*##C-//' | awk '{print $1}')
  eval "D=\$$C"
  if [ -n "$D" ]; then
     printLine
  fi
}

printNamedLine() {
  name=$(echo "$1" | sed -e 's/^.*##N-//' -e 's/^[ \t]*//' )
  bpTextLine "$name"
}


printCondNamedLine() {
  help_line=$1
  C=$(echo "$1" | sed -s 's/^.*##CN-//' | awk '{print $1}')
	name=$(echo "$help_line" | sed -e 's/^.*'"$C"'//' -e 's/^[ \t]*//' )
  eval "D=\$$C"
  if [ -n "$D" ]; then
    bpTextLine "$name"
  fi
}

help() { ## Print this help information
  echo "$USAGE"
  echo -e "$DESC"
  echo 
#  printf "%-20s  %s\n" "Command" "Help"
#  printLine
  IFS=$'\n'
  SC=$1
  #help_lines=$(grep -h '##' "$0" | grep -v grep | grep -v '##D' | grep -v '##V' | grep -v '\*##C' | grep -v '\*##C-' |  grep -v '\"##' |  grep -v '##N-//' | grep -v help_line | grep -v printLine)
  help_lines=$(grep -h '##' "$0" | grep -v -e 'grep' -e '##D' -e '##V' -e '\*##C' -e '\*##C-' -e '\"##' -e '##N-//' -e 'help_line' -e   'printLine')
  for help_line in ${help_lines[@]} ; do
    case "$help_line" in
      *"##-"*)   printLine ;;
      *"##C-"*)  printCondLine       "$help_line" ;;
      *"##N-"*)  printNamedLine      "$help_line" ;;
      *"##CN-"*) printCondNamedLine  "$help_line" ;;
      *"##C"*)   printCondCommand    "$help_line" ;;
      *"##"*)    printCommand        "$help_line" '##' ;;
      *)    
      ;;   
    esac
  done 
}

ihelp() { ##D Print internal help information
  printLine
  IFS=$'\n'
  SC=$1
  help_lines=$(grep -h '##' "$0" | grep -v grep | grep -v '\*"##[ A-Z]"\*' | grep -v help_line | grep -v printLine)
  for help_line in ${help_lines[@]}; do
    case "$help_line" in
      "##-")   printLine ;;
      *"##D"*) printCommand "$help_line" '##D' ;;
      *)    
      ;;   
    esac
  done 
	
  printInfo "#" "Normal bash comment"
  printInfo "##" "Subcommand information comment (shown with help)"
  printInfo "##C" "Conditional subcommand comment (shown with help)"
  printInfo "##-" "Generates a line at output (shown with help)"
  printInfo "##d" "Internal function comment (shown ihelp)"
  printLine
}

vhelp() { ##D Print internal variable information
  IFS=$'\n'
  lines=$(grep -A 1 '##V' "$0" | grep -v 'lines')
  echo "$lines"
  for line in ${lines[@]}; do
    echo "$line"
#    case $line in
#      "##x") printLine ;;
#      *"##D"*) 
#          printCommand $help_line '##D' ;;
#      *)    
#      ;;   
#    esac
  done 

#  echo $lines
}

imeld() { ##D Run meld file compare with local installed bashplate
  meld ${scriptPath}/${scriptName} ~/bin/bashplate_files/bashplate
}

version() { ## Print version information
  echo "$VERSION"
}

# Runs a function in this file as a command
runCommand() {
  if [ "$bpArguments" -eq 0 ]; then
   
    # check for a default command
    if [ -n "$DEFAULT" ]; then
      $DEFAULT "$1" "$2" "$3" "$4" "$5" "$6" "$7" "$8" "$9" "${10}"
      bpExit
    fi
    bpErrorExit "No command given"
  fi
  
  funks=$(grep "##" "$0" | grep -v grep | grep -v help_line)
  for line in ${funks[@]}; do
    command=$(echo "$line" | sed -s 's/(.*//')
    if [ "$command" == "$1" ]; then
      
      
      # execute pre command hook  if existing
      if [ -n "$PRECMDHOOK" ]; then
        ${PRECMDHOOK}
      fi
      
      # execute command
      ${command} "$1" "$2" "$3" "$4" "$5" "$6" "$7" "$8" "$9" "${10}"
      
      # execute post command hook  if existing
      if [ -n "$POSTCMDHOOK" ]; then
        ${POSTCMDHOOK}
      fi      
      bpExit
    fi
  done
  bpErrorExit "Command \"$1\" not found"	 
}

# Init magic variables
#
DATE=$(date +"%Y-%m-%d")
TIME=$(date +"%H:%M:%S")
COLUMNS=$(tput cols)
LINES=$(tput lines)

trap  signalQuit SIGQUIT
trap  signalInt  SIGINT
trap  signalHup  SIGHUP
trap  signalTerm SIGTERM

bpArguments=$#

# execute prescript hook if existing
if [ -n "$PREHOOK" ]; then
  ${PREHOOK} "$1" "$2" "$3" "$4" "$5" "$6" "$7" "$8" "$9" "${10}"
fi

# Run command parser
runCommand "$1" "$2" "$3" "$4" "$5" "$6" "$7" "$8" "$9" "${10}"

# Exit cleanly
bpExit

##-
