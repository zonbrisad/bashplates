#!/usr/bin/env bash
# shellcheck disable=2034
# shellcheck disable=2317
# shellcheck disable=1090
#---------------------------------------------------------------------
#
#  bpdev
#
#  [Description]
#    Sandbox for testing new bashplate features.
#
#  [Author]
#    Peter Malmberg <peter.malmberg@gmail.com>
#
#  [Date]
#    2022-07-01
#
#  [License]
#    MIT
#
#---------------------------------------------------------------------
# Generated with bashplates. [https://github.com/zonbrisad/bashplates]
#---------------------------------------------------------------------
#

# Display commands as they are executed
#set -o xtrace
# Display shell input lines as they are read
#set -v

# Exit script when a command fails. Append ||true if error is expected
#set -o errexit # || true
# Exit script when undeclared variable is used
#set -o nounset
# Exit script when pipe fails
set -o pipefail

#---------------------------------------------------------------------
# User defined Settings
#---------------------------------------------------------------------
bpUserSettings() {
  :
}
#---------------------------------------------------------------------
# User defined functions
#---------------------------------------------------------------------

##- Dictionary

bpDictKey() { ##I aa
  local arr=("${@}")
  local len=${#arr[@]}
  local i=0
  while [ "$i" -lt "$len" ]; do
    alt=${arr[$i]}
    ((i++))
    ((i++))
    if [ "$alt" == "$x" ]; then
      bpReturn="${alt}"
      return 0
    fi
  done
}

bpDictPrint() { ##I
  local DICT=("${@}")
  local LEN=${#DICT[@]}
  local i=0
  while [ "$i" -lt "$LEN" ]; do
    KEY=${DICT[$i]}
    ((i++))
    VALUE=${DICT[$i]}
    ((i++))
    bpPrintDesc "$KEY" "$VALUE"
  done
}

#
# $1 key
# $2 dictionary
# return Value
#
bpDictFind() {
  local DICT=("${@:2}")
  local FKEY="${1}"
  local LEN=${#DICT[@]}
  local i=0
  while [ "$i" -lt "$LEN" ]; do
    KEY=${DICT[$i]}
    ((i++))
    VALUE=${DICT[$i]}
    ((i++))
    bpDebug "$KEY = $VALUE  ($FKEY)"

    if [ "$KEY" == "$FKEY" ]; then
      echo "$VALUE"
      return
    fi
  done
  echo ""
}

my_dict=(
  "A" "Value A"
  "B" "Value B"
  "C" "Value C"
  "D" "Value D"
  "E" "Value E"
)

dtest() { ##D Test dictionary test
  bpDictPrint "${my_dict[@]}"
  echo "Dict: $(bpDictFind "C" "${my_dict[@]}")"
  echo "Dict: $(bpDictFind "A" "${my_dict[@]}")"
  echo "Dict: $(bpDictFind "E" "${my_dict[@]}")"
  echo "Dict: $(bpDictFind "XX" "${my_dict[@]}")"
}
##- New ANSII escape functions

icons_() { ## Unicode icons
  for a in {0..31}; do
    hex1=$(printf "%s%02x" "$1" "$a")
    hex2=$(printf "%s%02x" "$1" $(("$a" + 32)))
    hex3=$(printf "%s%02x" "$1" $(("$a" + 64)))
    hex4=$(printf "%s%02x" "$1" $(("$a" + 96)))
    hex5=$(printf "%s%02x" "$1" $(("$a" + 128)))
    hex6=$(printf "%s%02x" "$1" $(("$a" + 160)))
    hex7=$(printf "%s%02x" "$1" $(("$a" + 192)))
    hex8=$(printf "%s%02x" "$1" $(("$a" + 224)))
    echo -e " ${hex1}  \u${hex1}    $hex2  \u${hex2}    $hex3  \u${hex3}   $hex4  \u${hex4}   $hex5  \u${hex5}   $hex6  \u${hex6}   $hex7  \u${hex7}   $hex8  \u${hex8}"
  done
}

usym() { ##D Unicode symbols
  # Enclosed characters
  icons_ "24"
  echo

  icons_ "25"
  echo

  icons_ "26"
  echo

  icons_ "27"
  echo

  # Blind signs
  # icons_ "28"
  # echo

  icons_ "29"
  echo

  icons_ "23"
  echo

  icons_ "22"
  echo

  icons_ "21"
  echo

  icons_ "20"
  echo

  icons_ "101"
  echo

  # Emoticons
  # icons_ "1F6"
  # echo

  # Flags
  #icons_ "1F1"
  #echo

  #  icons_ "1F5"
  #  echo
}

tdim() { ##D Terminal dimensions
  while true; do
    lines=$(tput lines)
    cols=$(tput cols)
    echo "  Lines: ${lines} "
    echo "  Cols: ${cols}   "
    echo -en "$E_RETURN${E_RETURN}"
  done

}

##- Layout and color

msg() { ##D Messsages format test

  bpPrintLine "Unaligned message (current)"
  echo -e "[${BP_C_OK}Ok${E_RESET}] My little error message"
  echo -e "[${BP_C_INFO}Info${E_RESET}] My little error message"
  echo -e "[${BP_C_DEBUG}Debug${E_RESET}] My little error message"
  echo -e "[${BP_C_WARNING}Warning${E_RESET}] My little error message"
  echo -e "[${BP_C_ERROR}Error${E_RESET}] My little error message"
  echo -e "[${BP_C_CRITICAL}Critical${E_RESET}] My little error message"
  echo

  bpPrintLine "Unaligned message (current)"
  echo -e "   [${BP_C_OK}Ok${E_RESET}]    My little error message"
  echo -e "  [${BP_C_INFO}Info${E_RESET}]   My little error message"
  echo -e " [${BP_C_DEBUG}Debug${E_RESET}]   My little error message"
  echo -e "[${BP_C_WARNING}Warning${E_RESET}]  My little error message"
  echo -e " [${BP_C_ERROR}Error${E_RESET}]   My little error message"
  echo -e "[${BP_C_CRITICAL}Critical${E_RESET}] My little error message"
  echo

  bpPrintLine "Uneven message length with left alligned text"
  echo -e "[${BP_C_OK}Ok${E_RESET}]       My little error message"
  echo -e "[${BP_C_INFO}Info${E_RESET}]     My little error message"
  echo -e "[${BP_C_DEBUG}Debug${E_RESET}]    My little error message"
  echo -e "[${BP_C_WARNING}Warning${E_RESET}]  My little error message"
  echo -e "[${BP_C_ERROR}Error${E_RESET}]    My little error message"
  echo -e "[${BP_C_CRITICAL}Critical${E_RESET}] My little error message"
  echo

  bpPrintLine "Full text messages with space padding"
  echo -e "[${BP_C_OK}   Ok   ${E_RESET}] My little error message"
  echo -e "[${BP_C_INFO}  Info  ${E_RESET}] My little error message"
  echo -e "[${BP_C_DEBUG} Debug  ${E_RESET}] My little error message"
  echo -e "[${BP_C_WARNING}Warning ${E_RESET}] My little error message"
  echo -e "[${BP_C_ERROR} Error  ${E_RESET}] My little error message"
  echo -e "[${BP_C_CRITICAL}Critical${E_RESET}] My little error message"
  echo

  bpPrintLine "4 character message with padding"
  echo -e "[${BP_C_OK} Ok ${E_RESET}] My little error message"
  echo -e "[${BP_C_INFO}Info${E_RESET}] My little error message"
  echo -e "[${BP_C_DEBUG}Dbg ${E_RESET}] My little error message"
  echo -e "[${BP_C_WARNING}Warn${E_RESET}] My little error message"
  echo -e "[${BP_C_ERROR}Erro${E_RESET}] My little error message"
  echo -e "[${BP_C_CRITICAL}Crit${E_RESET}] My little error message"
  echo

  bpPrintLine "3 character message with padding"
  echo -e "[${BP_C_OK}Ok ${E_RESET}] My little error message"
  echo -e "[${BP_C_INFO}Inf${E_RESET}] My little error message"
  echo -e "[${BP_C_DEBUG}Dbg${E_RESET}] My little error message"
  echo -e "[${BP_C_WARNING}Wrn${E_RESET}] My little error message"
  echo -e "[${BP_C_ERROR}Err${E_RESET}] My little error message"
  echo -e "[${BP_C_CRITICAL}Cri${E_RESET}] My little error message"
  echo

  bpPrintLine "Debug color tests"
  echo -e "[${BP_C_DEBUG} Debug  ${E_RESET}] Default color"
  echo -e "[${E_BG_BR_GREEN}${E_WHITE} Debug  ${E_RESET}] Bright green bg"
  echo -e "[${E_BG_GREEN}${E_BLACK} Debug  ${E_RESET}] Green bg, black fg"
  echo -e "[${E_BG_BR_GREEN}${E_BLACK} Debug  ${E_RESET}] Bright green bg, black fg"

  echo -e "[${E_BG_BR_GREEN}${E_GREEN} Debug  ${E_RESET}] Bright green bg, green fg"
  echo -e "[${E_BG_GREEN}${E_BR_GREEN} Debug  ${E_RESET}] Green bg, Br green fg"
}

qct() { ##D Query color test
  BP_C_QUERY=$'\e[38;5;218m'
  BP_C_QUERY_DEF=$'\e[38;5;240m'
  BP_C_EMPHASIS=$'\e[38;5;255m'
  BP_C_DEEMPHASIS=$'\e[38;5;250m'
  ptq
  BP_C_EMPHASIS=$'\e[38;5;255m'${E_REVERSE}
  BP_C_DEEMPHASIS=$'\e[38;5;250m'
  ptq
  BP_C_EMPHASIS=$'\e[38;5;250m'${E_REVERSE}
  BP_C_DEEMPHASIS=$'\e[38;5;250m'
  ptq
  BP_C_EMPHASIS=$'\e[38;5;87m'
  BP_C_DEEMPHASIS=$'\e[38;5;75m'
  ptq
  BP_C_QUERY=$'\e[38;5;117m'
  BP_C_QUERY_DEF=$'\e[38;5;240m'
  BP_C_EMPHASIS=$'\e[38;5;255m'
  BP_C_DEEMPHASIS=$'\e[38;5;250m'
  ptq
  BP_C_QUERY=$'\e[38;5;153m'
  BP_C_QUERY_DEF=$'\e[38;5;240m'
  BP_C_EMPHASIS=$'\e[38;5;255m'
  BP_C_DEEMPHASIS=$'\e[38;5;250m'
  ptq
  BP_C_QUERY=$'\e[38;5;195m'
  BP_C_QUERY_DEF=$'\e[38;5;240m'
  BP_C_EMPHASIS=$'\e[38;5;255m'
  BP_C_DEEMPHASIS=$'\e[38;5;250m'
  ptq
  BP_C_QUERY=$'\e[38;5;230m'
  BP_C_QUERY_DEF=$'\e[38;5;237m'
  BP_C_EMPHASIS=$'\e[38;5;255m'
  BP_C_DEEMPHASIS=$'\e[38;5;250m'
  ptq

}

url() {
  echo -e "${1}https${7}://${2}zonbrisad${7}@${3}github.com${7}:${4}80${7}${5}/zonbrisad${7}/${6}bashplates.git${E_RESET}\n"
}

colorize() { ##D Url/file colorize tests

  echo
  F="/use/local/var/log/messages"
  echo -e "Default file colorize: $(bpColorizeFile "$F")"
  echo -e "Default url colorize:  $(bpColorizeUrl https://zonbrisad@github.com:80/zonbrisad/bashplates)"
  echo
  echo "Examples"
  echo

  url "$E_DARKGRAY" "$E_MAGENTA" "$E_GREEN" "$E_CYAN" "${E_GREEN}" "${E_BR_GREEN}"
  url "$E_DARKGRAY" "$E_BR_MAGENTA" "$E_GREEN" "$E_BR_CYAN" "${E_GREEN}" "${E_BR_GREEN}" "${E_GRAY}"
  url "$E_DARKGRAY" "$E_BR_BLUE" "$E_CYAN" "$E_BR_CYAN" "${E_MAGENTA}" "${E_BR_MAGENTA}"  #"${E_GRAY}"
  url "$E_DARKGRAY" "$E_BLUE" "$E_BR_MAGENTA" "$E_MAGENTA" "${E_CYAN}" "${E_BR_CYAN}"     #"${E_GRAY}"
  url "$E_DARKGRAY" "$E_BLUE" "$E_BR_MAGENTA" "$E_DARKGRAY" "${E_CYAN}" "${E_BR_CYAN}"    #"${E_GRAY}"
  url "$E_DARKGRAY" "$E_BLUE" "$E_BR_MAGENTA" "$E_YELLOW" "${E_CYAN}" "${E_BR_CYAN}"      #"${E_GRAY}"
  url "$E_DARKGRAY" "$E_MAGENTA" "$E_BR_MAGENTA" "$E_YELLOW" "${E_CYAN}" "${E_BR_CYAN}"   #"${E_GRAY}"
  url "$E_YELLOW" "$E_MAGENTA" "$E_BR_MAGENTA" "$E_YELLOW" "${E_CYAN}" "${E_BR_CYAN}"     #"${E_GRAY}"
  url "$E_DARKGRAY" "$E_MAGENTA" "$E_BR_MAGENTA" "$E_DARKGRAY" "${E_CYAN}" "${E_BR_CYAN}" #"${E_GRAY}"
  url "$E_DARKGRAY" "$E_BLUE" "$E_BR_BLUE" "$E_DARKGRAY" "${E_CYAN}" "${E_BR_CYAN}"       #"${E_GRAY}"
  url "$E_GRAY" "$E_BLUE" "$E_BR_BLUE" "$E_GRAY" "${E_CYAN}" "${E_BR_CYAN}"               #"${E_GRAY}"
  echo
}

aa() {
  bpPrintLine "$1"
  bpPrintDesc "cmd1" "My command 1"
  bpPrintDesc "cmd2" "My command 2"
  bpPrintVar "NoVar" "Somevariable"
  bpPrintVar "BP_SELF_DIR" "BP_SELF_DIR"
  echo

}

cst() { ##D Color scheme tests
  aa "Default color scheme"

  BP_C_LINE="${E_DARKGRAY}"
  BP_C_LINETEXT="${E_BR_YELLOW}"
  BP_C_DESCRIPTION="${E_BR_CYAN}"
  BP_C_KEY="${E_BR_MAGENTA}"
  BP_C_FILENAME="${E_BR_CYAN}"
  BP_C_PATH="${E_CYAN}"
  BP_C_URL_SCHEME="${E_DARKGRAY}"

  aa "Makeplates color scheme"
}

aVeryLongCommandTestCommand() { ##D Testing truncation of long command strings
  :
}

#ICMD=10
inactiveCommand() { ##CV ICMD Inactive command test
  echo "Only possible if ICMD is set."
}

##- Misc

s2a() { ##D String to array
  X=$'Rad 1\nRad 2\nRad 3'
  #X="Rad 1|Rad 2|Rad 3"
  IFS=$'\n'
  #IFS=$'|'
  read -ra XX <<<"$X"
  for x in "${XX[@]}"; do
    echo "$x"
  done

}

bp1=(
  "██████╗  █████╗ ███████╗██╗  ██╗██████╗ ██╗      █████╗ ████████╗███████╗███████╗"
  "██╔══██╗██╔══██╗██╔════╝██║  ██║██╔══██╗██║     ██╔══██╗╚══██╔══╝██╔════╝██╔════╝"
  "██████╔╝███████║███████╗███████║██████╔╝██║     ███████║   ██║   █████╗  ███████╗"
  "██╔══██╗██╔══██║╚════██║██╔══██║██╔═══╝ ██║     ██╔══██║   ██║   ██╔══╝  ╚════██║"
  "██████╔╝██║  ██║███████║██║  ██║██║     ███████╗██║  ██║   ██║   ███████╗███████║"
  "╚═════╝ ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═╝     ╚══════╝╚═╝  ╚═╝   ╚═╝   ╚══════╝╚══════╝"
)

bp2=(
  "██████   █████  ███████ ██   ██ ██████  ██       █████  ████████ ███████ ███████ "
  "██   ██ ██   ██ ██      ██   ██ ██   ██ ██      ██   ██    ██    ██      ██      "
  "██████  ███████ ███████ ███████ ██████  ██      ███████    ██    █████   ███████ "
  "██   ██ ██   ██      ██ ██   ██ ██      ██      ██   ██    ██    ██           ██ "
  "██████  ██   ██ ███████ ██   ██ ██      ███████ ██   ██    ██    ███████ ███████ "
  "                                                                                 "
)

bp3=(
  "______  _______ _______ _     _  _____         _______ _______ _______ _______"
  "|_____] |_____| |______ |_____| |_____] |      |_____|    |    |______ |______"
  "|_____] |     | ______| |     | |       |_____ |     |    |    |______ ______|"
  "                                                                              "
)

bp4=(
  "___  ____ ____ _  _ ___  _    ____ ___ ____ ____ "
  "|__] |__| [__  |__| |__] |    |__|  |  |___ [__  "
  "|__] |  | ___] |  | |    |___ |  |  |  |___ ___] "
)

bpb() { ##D Print banner

  for x in "${bp1[@]}"; do
    echo -e "$x"
  done

  for x in "${bp2[@]}"; do
    echo -e "$x"
  done

  #  echo ${bp3[@]}

}

XXprintCommand() {
  IFS=$' '
  read -r -a arr <<<"$1"
  inf="${arr[*]:3}"
  #IFS=$'\n'
  echo -n "${arr[0]} "
  # bpPrintDesc "${arr[0]}" "${inf}"
}

completion() { ##D Command completion

  BP_HELP=1

  IFS=$'\n'
  SC="$1"
  # HELP_LINES=$(grep -h '##' "$0" | grep -v -e 'grep' -e '##I' -e '##V' -e '\*##C' -e '\*##C-' -e '\"##' -e '##-//' -e 'LINE' -e 'printLine')
  HELP_LINES=$(grep -h -e "##D" -e "##C" "$0" | grep -v -e 'grep' -e '##I' -e '##V' -e '\*##C' -e '\*##C-' -e '\"##' -e '##-//' -e 'LINE' -e 'printLine')
  HELP_LINES="${HELP_LINES//()/}"

  for LINE in ${HELP_LINES}; do
    case "$LINE" in
    #    *"##-"*) printNamedLine "$LINE" ;;
    #    *"##C-"*) printCondNamedLine "$LINE" ;;
    #    *"##CV"*) printCondCommand "$LINE" 1 ;;
    #    *"##C"*) XXprintCommand "$LINE" 0 ;;
    *"##D"*) XXprintCommand "$LINE" '##D' ;;
    *) ;;

    esac
  done

  bpExecHook "POST_HELP_HOOK"
}

##- Function tests

desctest() { ##D Test bpPrintDesc output
  bpPrintLine
  bpPrintDesc "Key" "Description"
  bpPrintDesc "No description test" ""
  bpPrintDesc "" "No key test"
  bpPrintDesc "A very much too extra long key" "My description of a very much to long key"
  bpPrintDesc "|-----------------------|" "My description of key"
  bpPrintDesc "|----------------------|" "My description of key"
  bpPrintDesc "Multiple lines desc." $'A\nB\nC\nD'
  bpPrintDesc "Color description" "${E_BR_RED}Some ${E_BR_YELLOW}colorful ${E_BR_BLUE}description"
  bpPrintDesc "Keylen override" "Overrideing default key-length" 18
  bpPrintDesc "\"ls -l /\"" "$(ls -l /)"
  bpPrintLine
}

runtest() { ##D Test bpRun
  bpRun "${BP_SELF_DIR}/tests/file_do_not_exist"
  bpRun "${BP_SELF_DIR}/tests/non_executable"
  bpRun "${BP_SELF_DIR}/tests/empty_execute"
}

readtests() { ##D Test read commands
  slist=(
    "a" ":" "First choice"
    "b" ":" "Second choice"
    "3" ":" "Third alternative"
    "4" ":" "Fourth alternative"
    "penta" ":" "Fifth choice"
    "hexa" ":" "Sixth choice"
  )

  RESULT=$(bpReadStr "Enter string?")
  RESULT=$(bpReadStr "Enter string with default value?" "defval")
  RESULT=$(bpReadInt "Read integer value" 42)
  RESULT=$(bpReadInt "Read integer value with range" 42 22 50)
  RESULT=$(bpReadBoolDY "Are you sure?")
  RESULT=$(bpReadBoolDN "Are you sure?")
  bpSelectFromList "3" "Choose your alternative" "${slist[@]}"
}

asserts() { ##D Assert test
  bpHasCmd "apt"
  if bpIsCmd "apt"; then
    bpInfo "apt exists"
  fi
  bpAssertProgs "apt" "top" "donotexist" "someothercommand"
}

my_hook() {
  echo "My hook"
}

MY_HOOK="my_hook"
hooks() { ##D Test bpExecHook
  bpExecHook "MY_HOOK"
  bpExecHook "does_not_exist_hook"
}

filter() { ##D escape sequence filter test (bpFilterEscape)
  esctext="${E_UNDERLINE}Some${E_RESET} ${E_RED}red${E_RESET}, ${E_BOLD}bold${E_RESET} text colored ${E_BG_BLUE}blue.${E_RESET}"
  echo -e "Unfilterd:      $esctext"
  echo -e "bpFilterEscape: $(bpFilterEscape "$esctext")"

  bpOk "Some ${E_UNDERLINE}Underlines${E_RESET}"
  bpError "Some ${E_BLUE}Blue${E_RESET}"
  bpInfo "Some ${E_GREEN}GRENN${E_RESET}"
  bpError "Some ${E_RED}Red${E_RESET}"

  #attr=$(bpexample attr)
  #bpFilterEscape "$attr"

}

##- Argument
#xx() {

# OPTS=$(getopt --longoptions idebug -- "$@")
# echo $OPTS
# eval set --$OPTS

# while true; do
#   case "$1" in
#     --idebug)
#       set -o xtrace
#         ;;
#     --)
#         shift
#         break
#         ;;
#     esac
#     shift
# done
#}
#echo $@
#xx

args() { ##D Argument parsing with (getopts)
  bpInfo "Arguments#: $#"
  bpInfo "Arguments star: $*"
  bpInfo "Arguments at: $@"
  while getopts ':abc' opt; do
    case "${opt}" in
    a) echo "A" ;;
    b) echo "B" ;;
    c) echo "C" ;;
    esac
  done
}

argshift() { ##D Argument shifting
  # https://ss64.com/bash/shift.html
  # https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_09_07.html

  echo "${@}"
  shift 1
  echo "${@}"
}

##- Signals

xxx() {
  echo "$1"
}

waitx() { ##D Wait for signal

  #trap "kill $PID" INT TERM
  trap "xxx ppp" USR2
  bpPIDWrite
  pid=$$
  bpInfo "Sleeping...$pid"
  #sleep infinity

  quit=0
  while [ "$quit" -ne 1 ]; do
    #printf 'Do "kill -USR1 %d" to exit this loop after the sleep\n' "$$"
    sleep 0.5
  done

  bpInfo "Starting..."
  wait
}

pipedream() {
  echo "From function"
  while read -r data; do
    printf "%s" "$data"
  done

}

pipe2function() { ##D
  echo "From caller" | pipedream
}

##- Simmilar named command problem
COND=1

ne() { ##D Command
  echo "ne"
}
new() { ##D Command
  echo "new"
}
newc() { ##D Command C
  echo "newc"
}
newa() { ##C COND Command A
  echo "newa"
}
newb() { ##C COND Command B
  echo "newb"
}

##- New feature sugestions

listfiles() { ##D list files
  for file in ./*; do
    echo "$file"
    if [ -L "$file" ]; then
      echo "A"
    else
      echo "B"
    fi
  done
}

#
# $1 Number of iterations
# $2 Command to execute
#
bpRepeat() { ##I Repeat command n times
  local i max
  max=$1
  shift
  for ((i = 1; i <= max; i++)); do # --> C-like syntax
    eval "$@"
  done

}

repeat() { ##D Repeat function test
  bpRepeat 10 "ls ; sleep 1"
}

#
# $1 Text to set as title
#
bpTitle() { ##I Set terminal window title
  case "$TERM" in
  *term* | rxvt)
    echo -en "\e]0;$*\a"
    ;;
  *) ;;
  esac
}

title() { ##D bpTitle test
  bpTitle "Kalle"
  bpWait 10
}

#
# String contains
#
# $1 Substring to search
# $2 String to search in
#
bpInString() {

  if [[ "$1" = *"$2"* ]]; then
    echo 1
  else
    echo 0
  fi
}

inString() { ##D String contains test
  A="Hello world"

  if [ "$(bpInString HelloX "$A")" = "1" ]; then
    #  if  $( bpInString "Hello" "$A" ) ; then
    echo "A"
  else
    echo "B"
  fi

  bpInString "Hello" "$A"
  bpInString "Kalle" "$A"
}

bpGPIOSet() {
  local gpio="$1"
  local state="$2"

  if [ ! -e "/sys/class/gpio/gpio$gpio" ]; then
    echo "$gpio" >/sys/class/gpio/export
  fi

  echo "out" >>"/sys/class/gpio/gpio$gpio/direction"
  echo "$state" >>"/sys/class/gpio/gpio$gpio/value"
}

gpio() { ##D GPIO interface test on gpio4
  bpGPIOSet 4 1
  sleep 1
  bpGPIOSet 4 0
}

gpioblink() { ##D blink gpio4

  while true; do
    bpGPIOSet 4 1
    sleep 0.2
    bpGPIOSet 4 0
    sleep 0.2
  done
}

#---------------------------------------------------------------------
# Bashplate settings
#---------------------------------------------------------------------
bpInitSettings() {

  ##V Script version info
  BP_VERSION="1.00"

  ##V Usage info
  BP_USAGE="Usage: ${BP_SELF_NAME} command [option]"

  ##V Description text
  BP_DESC="Sandbox for testing new experimental bashplate features."

  ##V logfile (uncomment to use logfile)
  BP_LOGFILE=${BP_SELF_DIR}/${BP_SELF_NAME}.log

  ##V Lock file (uncomment to use lock file feature )
  #BP_LOCK_FILE=/tmp/${BP_SELF_NAME}.lock

  ##V PID file
  BP_PID_FILE=/tmp/${BP_SELF_NAME}_${USER}.pid

  ##V Logging options (uncomment to activate logging parameters)
  BP_LOG_OK=1
  BP_LOG_INFO=1
  BP_LOG_WARNING=1
  BP_LOG_ERROR=1
  BP_LOG_CRITICAL=1

  ##V Activate settings function (will create settings file when run)
  BP_CONF=1

}
#---------------------------------------------------------------------
# Bashplate Hooks
#---------------------------------------------------------------------

##V Default command (uncomment to use a default command )
DEFAULT_CMD_HOOK=help

##V Pre script hook, execute this function before every command
#PRE_SCRIPT_HOOK=

##V Post script hook, execute this function after every command
#POST_SCRIPT_HOOK=

##V Function to be executed before every other cmd except DEFAULT function
#PRE_CMD_HOOK=

##V Function to be executed after every other function except DEFAULT function
#POST_CMD_HOOK=

##V Function to be executed after information command
#POST_INFO_HOOK=

##V Function run before help command is executed
#PRE_HELP_HOOK=

##V Function run after help command is executed
#POST_HELP_HOOK=

# HOOK_PRE_SCRIPT
# HOOK_POST_SCRIPT
# HOOK_PRE_CMD
# HOOK_POST_CMD

#---------------------------------------------------------------------
# Signal traps
#---------------------------------------------------------------------

signalInt() {
  bpCleanUp
  exit "$BP_OK"
}

signalHup() {
  bpCleanUp
  exit "$BP_OK"
}

signalQuit() {
  echo "Quit"
  bpCleanUp
}

signalTerm() {
  echo "Term"
  bpCleanUp
}

signalErr() {
  echo
  echo
  bpError "Trace error Row: $2  Function: $1  ErrorCode: $3"
  echo
  bpCallStack "$*"
  bpExit 1
}

signalDbg() {
  echo "Debug Row: $2  Function: $1"
}

##C- IHELP Exit and cleanup

bpCallStack() { ##I Print out BASH call stack
  bpPrintLine "Call stack"
  echo
  local frame=0
  while caller "$frame" | sed -r -e "s/[0-9]*/${BP_C_VALUE}&${E_RESET}/"; do
    ((frame++))
  done
  echo "$*"
  bpPrintLine
}

bpCleanUp() {             ##I Cleanup function
  rm -f "${BP_LOCK_FILE}" # remove Lock file
  rm -f "${BP_PID_FILE}"  # remove PID file
  #  echo -e "${E_SHOW}"     # Turn on cursor if turned of
}

#
# $1 exit code, if not given exit code is 0=SUCCESS
#
bpExit() { ##I Function for safely exiting script
  bpCleanUp

  # execute postscript hook if existing
  bpExecHook "POST_SCRIPT_HOOK"

  # Check if argument is given
  if [ -z "$1" ]; then
    exit "$BP_OK"
  else
    exit "$1"
  fi
}

bpErrorExit() { ##I Safely exit script with a error
  bpError "${1}"
  bpCleanUp
  exit 1
}

#---------------------------------------------------------------------
# ANSI escape codes
#---------------------------------------------------------------------

# Check if terminal is 16 color only
if [[ "linux rxvt-16color" = *${TERM}* ]]; then

  # ANSI foreground colors codes
  #
  E_BLACK=$'\e[30m'        # Black
  E_RED=$'\e[31m'          # Red
  E_GREEN=$'\e[32m'        # Green
  E_YELLOW=$'\e[33m'       # Yellow
  E_BLUE=$'\e[34m'         # Blue
  E_MAGENTA=$'\e[35m'      # Magenta
  E_CYAN=$'\e[36m'         # Cyan
  E_GRAY=$'\e[37m'         # Gray
  E_DARKGRAY=$'\e[1;30m'   # Dark Gray
  E_BR_RED=$'\e[1;31m'     # Bright Red
  E_BR_GREEN=$'\e[1;32m'   # Bright Green
  E_BR_YELLOW=$'\e[1;33m'  # Bright Yellow
  E_BR_BLUE=$'\e[1;34m'    # Bright Blue
  E_BR_MAGENTA=$'\e[1;35m' # Bright Magenta
  E_BR_CYAN=$'\e[1;36m'    # Bright Cyan
  E_WHITE=$'\e[1;37m'      # White

  # ANSI background color codes
  #
  E_BG_BLACK=$'\e[40m'      # Black
  E_BG_RED=$'\e[41m'        # Red
  E_BG_GREEN=$'\e[42m'      # Green
  E_BG_YELLOW=$'\e[43m'     # Yellow
  E_BG_BLUE=$'\e[44m'       # Blue
  E_BG_MAGENTA=$'\e[45m'    # Magenta
  E_BG_CYAN=$'\e[46m'       # Cyan
  E_BG_GRAY=$'\e[47m'       # Gray
  E_BG_DARK_GRAY=$'\e[40m'  # Dark gray
  E_BG_BR_RED=$'\e[41m'     # Bright Red
  E_BG_BR_GREEN=$'\e[42m'   # Bright Green
  E_BG_BR_YELLOW=$'\e[43m'  # Bright Yellow
  E_BG_BR_BLUE=$'\e[44m'    # Bright Blue
  E_BG_BR_MAGENTA=$'\e[45m' # Bright Magenta
  E_BG_BR_CYAN=$'\e[46m'    # Bright Cyan
  E_BG_WHITE=$'\e[47m'      # White

else

  # ANSI foreground colors codes
  #
  E_BLACK=$'\e[38:5:0m'       # Black
  E_RED=$'\e[38:5:1m'         # Red
  E_GREEN=$'\e[38:5:2m'       # Green
  E_YELLOW=$'\e[38:5:3m'      # Yellow
  E_BLUE=$'\e[38:5:4m'        # Blue
  E_MAGENTA=$'\e[38:5:5m'     # Magenta
  E_CYAN=$'\e[38:5:6m'        # Cyan
  E_GRAY=$'\e[38:5:7m'        # Gray
  E_DARKGRAY=$'\e[38:5:8m'    # Dark Gray
  E_BR_RED=$'\e[38:5:9m'      # Bright Red
  E_BR_GREEN=$'\e[38:5:10m'   # Bright Green
  E_BR_YELLOW=$'\e[38:5:11m'  # Bright Yellow
  E_BR_BLUE=$'\e[38:5:12m'    # Bright Blue
  E_BR_MAGENTA=$'\e[38:5:13m' # Bright Magenta
  E_BR_CYAN=$'\e[38:5:14m'    # Bright Cyan
  E_WHITE=$'\e[38:5:15m'      # White

  # ANSI background color codes
  #
  E_BG_BLACK=$'\e[48;5;0m'       # Black
  E_BG_RED=$'\e[48;5;1m'         # Red
  E_BG_GREEN=$'\e[48;5;2m'       # Green
  E_BG_YELLOW=$'\e[48;5;3m'      # Yellow
  E_BG_BLUE=$'\e[48;5;4m'        # Blue
  E_BG_MAGENTA=$'\e[48;5;5m'     # Magenta
  E_BG_CYAN=$'\e[48;5;6m'        # Cyan
  E_BG_GRAY=$'\e[48;5;7m'        # Gray
  E_BG_DARK_GRAY=$'\e[48;5;8m'   # Dark gray
  E_BG_BR_RED=$'\e[48;5;9m'      # Bright Red
  E_BG_BR_GREEN=$'\e[48;5;10m'   # Bright Green
  E_BG_BR_YELLOW=$'\e[48;5;11m'  # Bright Yellow
  E_BG_BR_BLUE=$'\e[48;5;12m'    # Bright Blue
  E_BG_BR_MAGENTA=$'\e[48;5;13m' # Bright Magenta
  E_BG_BR_CYAN=$'\e[48;5;14m'    # Bright Cyan
  E_BG_WHITE=$'\e[48;5;15m'      # White
fi

# ANSI underline color codes
#
# Not in standard. implemented in Kitty, VTE, mintty, etc.
#
E_UL_BLACK=$'\e[58;5;0m'       # Black
E_UL_RED=$'\e[58;5;1m'         # Red
E_UL_GREEN=$'\e[58;5;2m'       # Green
E_UL_YELLOW=$'\e[58;5;3m'      # Yellow
E_UL_BLUE=$'\e[58;5;4m'        # Blue
E_UL_MAGENTA=$'\e[58;5;5m'     # Magenta
E_UL_CYAN=$'\e[58;5;6m'        # Cyan
E_UL_GRAY=$'\e[58;5;7m'        # Gray
E_UL_DARKGRAY=$'\e[58;5;8m'    # Dark Gray
E_UL_BR_RED=$'\e[58;5;9m'      # Bright Red
E_UL_BR_GREEN=$'\e[58;5;10m'   # Bright Green
E_UL_BR_YELLOW=$'\e[58;5;11m'  # Bright Yellow
E_UL_BR_BLUE=$'\e[58;5;12m'    # Bright Blue
E_UL_BR_MAGENTA=$'\e[58;5;13m' # Bright Magenta
E_UL_BR_CYAN=$'\e[58;5;14m'    # Bright Cyan
E_UL_WHITE=$'\e[58;5;15m'      # White

# ANSI Text attributes
E_RESET=$'\e[0m'              # Clear all attributes
E_BOLD=$'\e[1m'               # Bold text
E_DIM=$'\e[2m'                # Dim(low intensity) text
E_ITALIC=$'\e[3m'             # Italic text
E_UNDERLINE=$'\e[4m'          # Underlined text
E_UNDERLINE_DOUBLE=$'\e[4:2m' # Double underline (limited support)
E_UNDERLINE_CURLY=$'\e[4:3m'  # Curly underline (limited support)
E_UNDERLINE_DOT=$'\e[4:4m'    # Dotted underline (limited support)
E_UNDERLINE_DASH=$'\e[4:5m'   # Dashed underline (limited support)
E_BLINK=$'\e[5m'              # Blinking text
E_RAPID_BLINK=$'\e[6m'        # Rapid blink (Limited support)
E_REVERSE=$'\e[7m'            # Reverse color
E_CROSSED=$'\e[9m'            # Crossed over text
E_FRAKTUR=$'\e[20m'           # Gothic (limited support)
E_FRAMED=$'\e[51m'            # Framed (limited support)
E_OVERLINED=$'\e[53m'         # Overlined text
E_SUPERSCRIPT=$'\e[73m'       # Superscript text (limited support)
E_SUBSCRIPT=$'\e[74m'         # Subscript text (limited support)

# ANSI cursor operations
#
E_RETURN=$'\e[F'  # Move cursor to begining of line
E_UP=$'\e[A'      # Move cursor one line up
E_DOWN=$'\e[B'    # Move cursor one line down
E_FORWARD=$'\e[C' # Move cursor forward
E_BACK=$'\e[D'    # Move cursor backward
E_HIDE=$'\e[?25l' # Hide cursor
E_SHOW=$'\e[?25h' # Show cursor

# Default Bashplate colortheme
BP_C_OK="${E_BR_GREEN}"
BP_C_INFO="${E_BR_CYAN}"
BP_C_DEBUG="${E_BG_GREEN}${E_WHITE}"
BP_C_WARNING="${E_BR_YELLOW}"
BP_C_ERROR="${E_BR_RED}"
BP_C_CRITICAL="${E_BG_RED}${E_WHITE}"
BP_C_LINE="${E_DARKGRAY}"
BP_C_LINETEXT="${E_YELLOW}"
BP_C_DESCRIPTION="${E_CYAN}"
BP_C_KEY="${E_BR_MAGENTA}"

BP_C_FILENAME="${E_BR_CYAN}"
BP_C_PATH="${E_CYAN}"
BP_C_URL_SCHEME="${E_DARKGRAY}"
# BP_C_URL_USER=""
# BP_C_URL_HOST=""
BP_C_TIME="${E_BR_MAGENTA}"
BP_C_DATE="${E_MAGENTA}"

BP_C_QUERY=$'\e[38;5;194m'
BP_C_QUERY_DEF=$'\e[38;5;240m'
BP_C_EMPHASIS=$'\e[38;5;255m'
BP_C_DEEMPHASIS=$'\e[38;5;250m'

# Shellscript colorize colors
BP_C_RESERVED="${E_RED}"
BP_C_COMMENT="${E_CYAN}"
BP_C_STRING="${E_GREEN}"
BP_C_VAR="${E_BR_YELLOW}"

# Separator line character
BP_LINE_CHAR="-"

# Exit codes
#
BP_OK=0 # successful termination

# Formating
#
BP_KEY_LENGTH=24
BP_LEFT_MARGIN=3
BP_RIGHT_MARGIN=3

#---------------------------------------------------------------------
# Bashplate internal functions
#---------------------------------------------------------------------
# shellcheck disable=2155

##C- IHELP Printing functions

#
# $1 text to be printed
# $2 text color
# $3 line color
# $4 middle character
# $5 line character
#
bpPrintLineGeneric() { ##I Print text with adjusted line after with selectable colors
  local len1="${#1}"
  local len4="${#4}"

  echo -en "${2}${1}${4}${3}"
  l=$((BP_COLUMNS - len1 - len4))
  seq -s"${5}" "${l}" | tr -d '[:digit:]'
  echo -en "${E_RESET}"
}

#
# $1 text to be printed
# $2 text color
# $3 line color
#
bpTextLineC() { ##I Print text with adjusted line after with selectable colors
  bpPrintLineGeneric "$1" "$2" "$3" " " "-"
}

bpPrintLine() { ##I Print text with line
  if [ "${#1}" -eq 0 ]; then
    bpPrintLineGeneric "" "" "${BP_C_LINE}" "" "-"
  else
    bpPrintLineGeneric "$1" "${BP_C_LINETEXT}" "${BP_C_LINE}" " " "-"
  fi
}

#
# $1 key color
# $2 description color
# $3 key
# $4 description
# $5 key length override (optional)
#
bpPrintDescGeneric() { # Generic key/description printout function
  local KEY_COLOR="$1"
  local DESC_COLOR="$2"
  local KEY="$3"
  local DESC="$4"
  local KEY_LENGTH
  local LINES

  if [ -n "$5" ]; then
    KEY_LENGTH="$5"
  else
    KEY_LENGTH=${BP_KEY_LENGTH}
  fi

  if ((${#4} == 0)); then
    printf "${1}  %-${KEY_LENGTH}.${KEY_LENGTH}s${E_RESET} ${2}%s${E_RESET}\n" "$3" ""
  fi

  local len=${#}
  local a=$(("${BP_COLUMNS}" - "$KEY_LENGTH" - "$BP_RIGHT_MARGIN"))

  # Only fold if length of "value" longer than terminal width
  # This is a speed optimization since runing fold for each printout takes considrable time
  if ((${#DESC} > a)); then
    LINES=$(fold --width="${a}" <<<"$DESC")
  else
    LINES="$DESC"
  fi

  IFS=$'\n'
  local L1=0
  for line in ${LINES}; do
    if [ "${L1}" -eq 0 ]; then                # First line
      if ((${#KEY} > "$BP_KEY_LENGTH")); then # Oversized key
        printf "${KEY_COLOR}  %-${KEY_LENGTH}s${E_RESET}\n" "$KEY"
        printf "${KEY_COLOR}  %-${KEY_LENGTH}.${KEY_LENGTH}s${E_RESET} ${DESC_COLOR}%s${E_RESET}\n" "" "$line"
      else # Normal key
        printf "${KEY_COLOR}  %-${KEY_LENGTH}.${KEY_LENGTH}s${E_RESET} ${DESC_COLOR}%s${E_RESET}\n" "$KEY" "$line"
      fi
      L1=1
    else # Rest of the lines
      printf "${KEY_COLOR}  %-${KEY_LENGTH}.${KEY_LENGTH}s${E_RESET} ${DESC_COLOR}%s${E_RESET}\n" "" "$line"
    fi
  done
}

#
# $1 key
# $2 description
# $3 (optional) left alignment
#
bpPrintDesc() { ##I Print key description
  bpPrintDescGeneric "${BP_C_KEY}" "${BP_C_DESCRIPTION}" "$1" "$2" "$3"
}

bpPrintDescAlt() {
  bpPrintDescGeneric "${E_DARKGRAY}" "${BP_C_DESCRIPTION}" "$1" "$2"
}

#
# $1 variablename
# $2 alternative key text (optional)
# $3 alternative value text (optional)
#
bpPrintVar() { ##I Print variable value and description
  local VAR="$1"

  if [ -n "$2" ]; then
    KEY=${2}
  else
    KEY="${VAR}"
  fi

  if [ "${!VAR}" ]; then
    if [ -n "$3" ]; then
      VAL=${3}
    else
      VAL="${!VAR}"
    fi

    bpPrintDesc "${KEY}" "${VAL}"
  else
    bpPrintDesc "${KEY}" "${BP_C_ERROR}N/A"
  fi
}

#
# Colorize string containing filename
#
# $1 string with filename to colorize
# ret colorized string
#
#bpColorizeFile() { ##I Colorize string containing filename
#  echo "${BP_C_PATH}$(dirname "$1")/${BP_C_FILENAME}$(basename "$1")${E_RESET}"
#}
bpColorizeFile() { ##I Colorize string with filename
  if [ -n "$1" ]; then
    if [ -d "$1" ]; then
      echo "${BP_C_PATH}${1}${E_RESET}"
      return
    fi
    echo "${BP_C_PATH}$(dirname "$1")/${BP_C_FILENAME}$(basename "$1")${E_RESET}"
  fi
}

#
# $1 string with url to colorize
# ret colorized string
#
# todo: give username and port own color
#
bpColorizeUrl() { ##I Colorize string containing URL
  local URL=$(sed -r -e "s/^.*\/\///" <<<"$1")
  local SCHEME=$(sed -r -e "s/:\/.*//" <<<"$1")
  # USERNAME=$(sed -r -e "s/@.*//" <<<"$URL")
  # PORT=$(sed -r -e "s/^:[0-9]*/XXX/" <<<"$URL")
  # echo -e "Username: $USERNAME"
  # echo -e "Port: $PORT"

  #URL=$(echo -n "$1" | sed -r -e "s/^.*\/\///")
  #SCHEME=$(echo -n "$1" | sed -r -e "s/:\/.*//")

  echo -e -n "${BP_C_URL_SCHEME}${SCHEME}${E_RESET}://$(bpColorizeFile "${URL}")"
}

#
# $1 string to be filtered
#
bpFilterEscape() { ##I Filter escape characters from string
  # https://superuser.com/questions/380772/removing-ansi-color-codes-from-text-stream

  sed -e 's/\x1b\[[0-9;:]*[mGKHF]//g' <<<"$1"
}

##C- IHELP File operations

#
# $1 directory to change to
#
bpCd() { ##I Safe cd function (exits on fail)
  cd "$1" || bpExit "Failed to cd to [$1]"
}

#
# $1 Directory to be created
#
bpMkDir() { ##I Create a directory if it does not exist
  if [ ! -d "$1" ]; then
    if mkdir -p "$1"; then
      bpOk "Creating directory $(bpColorizeFile "${1}")."
      return 0
    else
      bpError "Failed to create directory $(bpColorizeFile "${1}")."
      return 1
    fi
  fi
}

#
# $1 target file/dir
# $2 link
#
bpLn() { ##I Create symbolic link
  if [ ! -L "$1" ]; then
    if ln -sf "${1}" "${2}"; then
      bpOk "Creating link $(bpColorizeFile "${2}")."
      return 0
    else
      bpError "Failed to create link $(bpColorizeFile "${2}")."
      return 1
    fi
  fi
}

#
# $1 file(s) to be copied
# $2 destination
#
bpCp() { ##I Copy file(s)
  if cp -rf "$@"; then
    bpOk "Copying $(bpColorizeFile "${1}") to $(bpColorizeFile "${2}")"
    return 0
  else
    bpError "Failed copying $(bpColorizeFile "${1}") to $(bpColorizeFile "${2}")"
    return 1
  fi
}

#
# $1 file(s) to be moved
# $2 destination
#
bpMv() { ##I Move file(s)
  if mv "$1" "$2"; then
    bpOk "Moving file $(bpColorizeFile "${1}") to $(bpColorizeFile "${2}")."
    return 0
  else
    bpError "Failed moving file $(bpColorizeFile "${1}") to $(bpColorizeFile "${2}")."
    return 1
  fi
}

#
# $1 file(s) to be removed
#
bpRm() { ##I Remove file(s)
  if rm -rf "${1}"; then
    bpOk "Removing file $(bpColorizeFile "${1}")."
    return 0
  else
    bpError "Failed removing file $(bpColorizeFile "${1}")."
    return 1
  fi
}

#
# $1 file to be backed up
#
bpBackup() { ##I Make backup of file
  local BF="${1}_$(date +"%Y%m%d")-$(date +"%H%M%S").bak"

  if cp -rf "$1" "${BF}"; then
    bpOk "Backing up file $(bpColorizeFile "$1") to $(bpColorizeFile "${BF}")."
    return 0
  else
    bpError "Failed backing up file $(bpColorizeFile "$1") to $(bpColorizeFile "${BF}")."
    return 1
  fi
}

##C- IHELP File editing

#
# $1 file
# $2 text to replace
# $3 new text
#
bpReplace() { ##I Replace all ocurances of text in file
  sed -i -e "s/${2}/${3}/g" "$1"
}

#
# $1 file
# $2 pattern matching line
# $3 new text
#
bpReplaceLine() { ##I Replace entire line matching pattern
  sed -i -e "0,/${2}/s/${2}.*/${3}/" "${1}"
}

#
# $1 file
# $2 line to append
#
bpAppendIfNoSuchLine() { ##I Append a line if it does not exist in file
  if [ "$BP_SUDO" == true ]; then
    sudo grep -q -F "$2" "$1" || echo -e "$2" | sudo tee -a "$1" >/dev/null
  else
    grep -q -F "$2" "$1" || echo -e "$2" >>"$1"
  fi
}

#
# $1 file
# $2 string
#
bpRemoveLineContaining() { ##I Remove line in file if it contains given string
  grep -v "$2" "$1" >"${1}_tmp"
  mv -f "${1}_tmp" "${1}"
}

#
# $1 file
# $2 string
# return true if existing
#
bpStrExist() { ##I Check if string exist in file
  if [ ! -f "$1" ]; then
    return 1
  fi

  if grep -q -F "$2" "$1"; then
    return 0
  else
    return 1
  fi
}

#
# $1 file to open in editor
# $2 override editor (optional)
#
bpEdit() { ##I Open file in editor set by BP_EDIT variable

  if [ -n "$2" ]; then
    bpRun "$2" "$1"
    return 0
  fi

  if [ -n "$BP_EDITOR" ]; then
    bpRun "${BP_EDITOR}" "${1}"
  else
    bpError "BP_EDITOR variable not set, can't open file ${1}"
  fi
}

#
# $1 file
# $2 start marker
# $3 end marker
#
bpGetSection() { ##I Get text from file between two markers
  grep -A 10000 -m 1 "$2" <"$1" | grep -B 10000 -m 1 "$3" | grep -v "$2" | grep -v "$3"
}

#
# $1 File to import
#
bpImport() { ## Import file into variable
  if [ -f "$1" ]; then
    cat "$1"
  fi
}

#
# $1 file
# $2 match
# $3 text to insert
#
bpInsert() { ##I Insert text into file
  local a=$(grep -A 10000 "$2" <"$1" | grep -v "$2")
  local b=$(grep -B 10000 "$2" <"$1" | grep -v "$2")

  echo "$b" "$3" "$a" >|"$1"
}

##C- IHELP Input

#
# $1  Question string
# $2  Default value
# return string read from cmdline/default if enter pressed
#
bpReadGeneric() { ##I Read from commandline
  local QUERY="$1"
  local DEFAULT="$2"

  read -er -i "$DEFAULT" -p "${BP_C_QUERY}${1}${E_RESET} > " RESULT
  if [ "${RESULT}" == "" ]; then
    RESULT="${2}"
  fi
  echo "${RESULT}"
}

#
# $1 query
# $2 answer
#
bpReadLog() { ## Log query, internal use only
  bpLogInfo "User input: $QUERY <- $RESULT"
}

#
# $1  Question string
# $2  Default value
# return string read from cmdline/default if enter pressed
#
bpReadStr() { ##I Read string from commandline
  local QUERY="$1"
  local DEFAULT="$2"
  local RESULT=$(bpReadGeneric "$QUERY" "$DEFAULT")

  bpReadLog "$QUERY" "$RESULT"
  echo "${RESULT}"
}

#
# $1  Question string
# $2  Default value
# $3  min value
# $4  max value
# return integer read from cmdline/default if enter pressed
#
bpReadInt() { ##I Read integer from commandline
  local QUERY="$1"
  local DEFAULT="$2"
  local MIN="$3"
  local MAX="$4"

  local RANGE=""
  if [ -n "$MIN" ] || [ -n "$MAX" ]; then
    RANGE=" ${BP_C_QUERY_DEF}[${E_RESET}$3-$4${BP_C_QUERY_DEF}]${E_RESET}"
  fi

  while true; do
    read -er -i "$DEFAULT" -p "${BP_C_QUERY}${1}${E_RESET}${RANGE} > " RESULT

    if [ "$RESULT" -eq "$RESULT" ] 2>/dev/null; then

      if [ -n "${RANGE}" ]; then
        #if [ -n "$MIN" ] && [ -n "$MAX" ]; then
        if [ $((RESULT)) -ge "$MIN" ] && [ $((RESULT)) -le "$MAX" ]; then
          break
        fi
      else
        break
      fi
    fi
  done
  bpReadLog "$QUERY" "$RESULT"
  echo "${RESULT}"
}

#
# $1 question text
# $2 default answer 0 = yes, 1 = no
# return 0 = Yes, 1=No
#
bpReadBool() { ##I Ask yes/no question generic
  local QUERY="$1"
  local DEFAULT="$2"
  while true; do

    if [ "$2" -eq 1 ]; then
      yn=$(bpReadGeneric "${BP_C_QUERY}${1}${E_RESET} ${BP_C_QUERY_DEF}[${BP_C_DEEMPHASIS}y${BP_C_QUERY_DEF}/${BP_C_EMPHASIS}N${BP_C_QUERY_DEF}]${E_RESET}")
    else
      yn=$(bpReadGeneric "${BP_C_QUERY}${1}${E_RESET} ${BP_C_QUERY_DEF}[${E_RESET}${BP_C_EMPHASIS}Y${BP_C_QUERY_DEF}/${BP_C_DEEMPHASIS}n${BP_C_QUERY_DEF}]${E_RESET}")
    fi

    case "$yn" in
    [Yy]*)
      bpReadLog "$QUERY" "Yes"
      return 0
      break
      ;;
    [Nn]*)
      bpReadLog "$QUERY" "No"
      return 1
      break
      ;;
    "")
      if [ "$2" -eq 0 ]; then
        bpReadLog "$QUERY" "Yes"
      else
        bpReadLog "$QUERY" "No"
      fi
      return "$2"
      break
      ;;
    *) echo "Please answer yes or no." ;;
    esac
  done
}

#
# $1 Question text
# return 0 = Yes, 1=No
#
bpReadBoolDY() { ##I Ask yes/no question default yes
  bpReadBool "$1" 0
  return $?
}

#
# $1 Question text
# return 0 = Yes, 1=No
#
bpReadBoolDN() { ##I Ask yes/no question default no
  bpReadBool "$1" 1
  return $?
}

bpPrintChoiceList() { # Print items in selection list
  echo
  local arr=("${@:2}")
  local len=${#arr[@]}
  local i=1
  while [ "$i" -lt "$len" ]; do
    key=${arr[$i]}
    ((i++))
    val=${arr[$i]}
    ((i++))
    desc=${arr[$i]}
    ((i++))

    if [ "$key" == "$1" ]; then
      default=">"
    else
      default=" "
    fi

    if [ "${desc}" == ":" ]; then
      printf "%1s ${BP_C_KEY}%-7s  ${BP_C_DESCRIPTION}%s${E_RESET}\n" "$default" "$key" "$val"
    else
      printf "%1s ${BP_C_KEY}%-7s  ${BP_C_DESCRIPTION}%s${E_RESET}\n" "$default" "$key" "$desc"
    fi
  done
}

#
# Select from list of choices
#
# $1 Default value
# $2 Question
# $* Array of choices
#
# Return: bpReturn
#
# Example choice list.
# list=(
#  "a" ":" "Choice A"
#  "b" ":" "Choice B"
#  "c" ":" "Choice C"
# )
bpSelectFromList() { ##I Select from list
  local QUERY="$2"
  while true; do
    bpPrintChoiceList "$1" "${@:2}"
    echo
    local x=$(bpReadGeneric "$2" "$1")

    local arr=("${@}")
    local len=${#arr[@]}
    local i=2
    while [ "$i" -lt "$len" ]; do
      key=${arr[$i]}
      ((i++))
      val=${arr[$i]}
      ((i++))
      ((i++))
      if [ "$key" == "$x" ]; then
        if [ "$val" == ":" ]; then
          bpReturn="${key}"
        else
          bpReturn="${val}"
        fi
        bpReadLog "$QUERY" " $bpReturn"
        return 0
      fi
    done
  done
}

##C- IHELP PID file management

bpPIDWrite() { ##I Write PID file to disk
  echo $$ >"${BP_PID_FILE}"
}

bpPIDRemove() { ##I Remove PID file
  rm -f "${BP_PID_FILE}"
}

bpPIDLoad() { ##I Load PID from file
  if [ -e "${BP_PID_FILE}" ]; then
    cat "${BP_PID_FILE}"
  fi
}

bpPIDExist() { ##I Check if PID file exist
  if [ -e "${BP_PID_FILE}" ]; then
    return 0
  else
    return 1
  fi
}

# Settings file ------------------------------------------------------

##C- BP_CONF Bashplate config file
##C- IHELP Bashplate config file

#
# $1 config file
# $2 key
# $3 value
# $4 description
#
bpAddSetting() { ##I Add setting to config file
  local FILE="$1"
  local KEY="$2"
  local VAL="$3"
  local DESC="$4"
  if ! bpStrExist "${FILE}" "${KEY}"; then
    {
      echo "# ${DESC}"
      echo "${KEY}=\"${VAL}\""
      echo
    } >>"${FILE}"

    bpOk "Added setting \"$KEY=$VAL\""
  fi
}

# Change setting in config file (key value pair)
#
# $1 config file
# $2 key
# $3 value
# $4 description
#
bpChangeSetting() { ##I Change setting in config file
  local FILE="$1"
  local KEY="$2"
  local VAL="$3"
  local DESC="$4"
  if ! bpStrExist "${FILE}" "${KEY}"; then
    bpAddSetting "$FILE" "$KEY" "$VAL" "$DESC"
  fi
  sed -i "s/^\(${KEY}\s*=\s*\).*\$/\1${VAL}/" "${FILE}"
  bpOk "Changing ${KEY} to ${VAL}"
}

#
# $1 key
# $2 config array
#
bpConfGetDesc() { ##I Get config desription
  local arr=("${@:1}")
  local len=${#arr[@]}
  bpReturn=""
  local i=1
  while [ "$i" -lt "$len" ]; do
    key=${arr[$i]}
    ((i++))
    def=${arr[$i]}
    ((i++))
    desc=${arr[$i]}
    ((i++))
    #echo "$key"
    if [ "$key" == "$1" ]; then
      echo "$desc"
      return 0
    fi
  done
  return 1
}

#
# $1 key
# $2 value
# $3 config array
#
bpConfChangeSetting() {
  local KEY="$1"
  local VAL="$2"
  local CONF=("${@:2}")
  local FILE=${CONF[1]}
  local DESC=$(bpConfGetDesc "$KEY" "${CONF[@]}")

  if ! bpConfInList "$KEY" "${CONF[@]}"; then
    bpError "\"$KEY\" is not a valid setting"
    return
  fi

  if ! bpStrExist "${FILE}" "${KEY}"; then
    bpAddSetting "${FILE}" "$KEY" "$VAL" "${DESC}"
    return "$BP_OK"
  fi

  bpChangeSetting "$FILE" "$KEY" "$VAL" "$DESC"
}

#
# $1 File
# $2 Headertext
# $3 config array
#
bpConfCreate() { ##I Create configuration file
  local FILE="$1"
  {
    echo "# "
    echo "# $2"
    echo "# "
    echo
  } >>"${FILE}"

  local arr=("${@:2}")
  local len=${#arr[@]}
  local i=1
  while [ "$i" -lt "$len" ]; do
    key=${arr[$i]}
    ((i++))
    default=${arr[$i]}
    ((i++))
    desc=${arr[$i]}
    ((i++))
    bpAddSetting "$FILE" "$key" "$default" "$desc"
  done
}

#
# $1 Config file
#
bpConfLoad() { ##I Load config file
  local FILE="$1"
  if [ -n "${FILE}" ]; then
    if [ ! -e "${FILE}" ]; then
      bpConfCreate "${@}"
    fi
    source "${FILE}"
  fi
}

#
# $1 key
# $2 config array
#
bpConfInList() { ##I Check if key exist in config file list
  local arr=("${@:1}")
  local len=${#arr[@]}
  bpReturn=""
  local i=3
  while [ "$i" -lt "$len" ]; do
    key=${arr[$i]}
    ((i++))
    def=${arr[$i]}
    ((i++))
    desc=${arr[$i]}
    ((i++))
    #echo "Key = $key  Default = $def  Desc = $desc"
    if [ "$key" == "$1" ]; then
      bpReturn="$key"
      return 0
    fi
  done
  return 1
}

bpConfPrint() { ##I Print settings in config list
  echo
  bpPrintDesc "Config file" "$(bpColorizeFile "$3")"
  echo
  local arr=("${@:4}")
  local i=1
  while [ "$i" -lt ${#arr[@]} ]; do
    KEY=${arr[$i]}
    ((i++))
    DEF=${arr[$i]}
    ((i++))
    DESC=${arr[$i]}
    ((i++))
    printf "%s%s\n" "${E_DARKGRAY}" "${DESC}"
    bpPrintVar "$KEY"
  done
}

bpset() { ##C BP_CONF Change setting in bp config file
  local PARAM="$2"
  if [ -z "$PARAM" ]; then
    bpConfPrint "" "" "${BP_CONFIG_LIST[@]}"
    return
  fi
  if bpConfInList "$PARAM" "${BP_CONFIG_LIST[@]}"; then
    bpChangeSetting "${BP_CONFIG_FILE}" "${bpReturn}" "\"${3}\""
    return
  fi
  bpError "\"$PARAM\" is not a valid setting"
}

##C- IHELP Bashrc path/module handling

bpLsPaths() { ##I List paths
  shopt -s nullglob dotglob
  for p in "${BP_CONFIG_PATHS}"/*; do
    echo "A: $(readlink "${p}")"
  done
}

#
# $1 directory to add to path
#
bpAddPath() { ##I Add dir to PATH variable
  local LPATH=""
  LPATH=$(echo "${1}" | sed -e 's/\//_/g')

  bpInfo "Adding PATH \"${LPATH}\""
  if [ ! -L "$1" ]; then
    bpLn "${1}" "${BP_CONFIG_PATHS}/${LPATH}"
  fi
}

bpRmPath() { ##I Remove path
  bpRm "${BP_CONFIG_PATHS}/${1}"
}

bpLsModules() { ##I List modules
  shopt -s nullglob dotglob
  for p in "${BP_CONFIG_MODULES}"/*; do
    readlink "${p}"
  done
}

bpAddModule() { ##I Add init script to
  local MODULE=""
  MODULE=$(realpath "${1}")
  if [ ! -L "$MODULE" ]; then
    rm -f "${BP_CONFIG_MODULES}/$(basename "${MODULE}")"
    bpLn "$MODULE" "${BP_CONFIG_MODULES}/."
  fi
}

bpRmModule() { ##I Remove module
  bpRm "${BP_CONFIG_MODULES}/${1}"
}

##-

# Logging ---------------------------------------------------------

##C- IHELP Log functions

#
# Function logging to file
#
# $1 String to log to file
#
bpLog() { ##I Log to file command
  # check for BP_LOGFILE variable
  if [ -n "$BP_LOGFILE" ]; then
    ts=$(date +"%Y-%m-%d %H:%M:%S")
    bpFilterEscape "$ts $1" >>"${BP_LOGFILE}"
  fi
}

bpLogOk() { ##I Log Ok message to file
  bpLog "[ Ok ] $1"
}

bpLogInfo() { ##I Log Info message to file
  bpLog "[Info] $1"
}

bpLogDebug() { ##I Log Info message to file
  bpLog "[Debg] $1"
}

bpLogWarning() { ##I Log Warning message to file
  bpLog "[Warn] $1"
}

bpLogError() { ##I Log Error message to file
  bpLog "[Erro] $1"
}

bpLogCritical() { ##I Log Critical message to file
  bpLog "[Crit] $1"
}

log() { ##C BP_LOGFILE View logfile
  if [ -n "$BP_LOGFILE" ]; then
    if [ -f "${BP_LOGFILE}" ]; then # Check that logfile exists
      D=$(sed -r -e "s|\[Info\]|\[\\${BP_C_INFO}Info\\${E_RESET}\]|" \
        -e "s|\[Warn\]|\[\\${BP_C_WARNING}Warn\\${E_RESET}\]|" \
        -e "s|\[Erro\]|\[\\${BP_C_ERROR}Erro\\${E_RESET}\]|" \
        -e "s|\[ Ok \]|\[\\${BP_C_OK} Ok \\${E_RESET}\]|" \
        -e "s/[-0-9]+/\\${BP_C_DATE}&\\${E_RESET}/1" \
        -e "s/[:0-9]+/\\${BP_C_TIME}&\\${E_RESET}/6" \
        -e "s|\[Crit\]|\[\\${E_BG_RED}\\${E_WHITE}Crit\\${E_RESET}\]|" <"${BP_LOGFILE}")
      echo -e "$D"
    fi
  else
    bpInfo "Logging is not activated"
    bpExit
  fi
}

mlog() { ##C BP_LOGFILE Monitor logfile
  if [ -n "$BP_LOGFILE" ]; then
    if [ -f "${BP_LOGFILE}" ]; then # Check that logfile exists
      tail -f "${BP_LOGFILE}" | sed -r -e "s|\[Info\]|\[\\${BP_C_INFO}Info\\${E_RESET}\]|" \
        -e "s|\[Warn\]|\[\\${BP_C_WARNING}Warn\\${E_RESET}\]|" \
        -e "s|\[Erro\]|\[\\${BP_C_ERROR}Erro\\${E_RESET}\]|" \
        -e "s|\[ Ok \]|\[\\${BP_C_OK} Ok \\${E_RESET}\]|" \
        -e "s/[-0-9]+/\\${E_GREEN}&\\${E_RESET}/1" \
        -e "s/[:0-9]+/\\${E_BR_GREEN}&\\${E_RESET}/6" \
        -e "s|\[Crit\]|\[\\${E_BG_RED}\\${E_WHITE}Crit\\${E_RESET}\]|"
    fi
  else
    bpInfo "Logging is not activated"
    bpExit
  fi
}

##C- IHELP Message

bpOk() { ##I Success message
  if [ -n "$BP_LOG_OK" ]; then
    bpLogOk "$1"
  fi
  echo -e "[${BP_C_OK}Ok${E_RESET}] $1"
}

bpInfo() { ##I Info message
  if [ -n "$BP_LOG_INFO" ]; then
    bpLogInfo "$1"
  fi
  echo -e "[${BP_C_INFO}Info${E_RESET}] $1"
}

bpDebug() { ##I Debug message
  if [ -z "$BP_DEBUG" ]; then
    return
  fi
  if [ -n "$BP_LOG_INFO" ]; then
    bpLogDebug "$1"
  fi

  echo -e "[${BP_C_DEBUG}Dbg${E_RESET}] $1"
}

bpWarning() { ##I Warning message
  if [ -n "$BP_LOG_WARNING" ]; then
    bpLogWarning "$1"
  fi
  echo -e "[${BP_C_WARNING}Warning${E_RESET}] $1"
}

bpError() { ##I Error message
  if [ -n "$BP_LOG_ERROR" ]; then
    bpLogError "$1"
  fi
  echo -e "[${BP_C_ERROR}Error${E_RESET}] $1"
}

bpCritical() { ##I Critical error message
  if [ -n "$BP_LOG_CRITICAL" ]; then
    bpLogCritical "$1"
  fi
  echo -e "[${BP_C_CRITICAL}Critical${E_RESET}] $1"
  bpExit
}

# Various  ---------------------------------------------------------

##C- IHELP Assert

bpAssertRoot() { ##I Assert that user is root
  if [ "$(whoami)" != root ]; then
    bpError "Must be root to use this command."
    bpExit "1"
  fi
}

bpAssertNoLockFile() { ##I Assert that lockfile is not present
  if [ -n "$BP_LOCK_FILE" ]; then
    if [ -f "$BP_LOCK_FILE" ]; then
      bpError "Script is already running. (${BP_LOCK_FILE})"
      exit "1" # do not use bpExit because lock file belongs to prexsisting process
    fi
    touch "$BP_LOCK_FILE"
  fi
}

#
# $1 string list of programs that are required
#
bpAssertProgs() { ##I Assert that required programs are available on the system
  local FILES=("$@")
  for file in "${FILES[@]}"; do
    if ! bpIsCmd "${file}"; then
      bpError "Required program \"$file\" not found."
      bpExit 1
    fi
  done
}

##C- IHELP Misc

#
# $1 command to check
#
bpIsCmd() { ##I Check whether a command exists in path and is executable
  if [ -x "$(command -v "${1}")" ]; then
    return 0
  else
    return 1
  fi
}

bpIsFunction() { ##I Check if and identifier is declared as a function
  if [ "$(type -t "$1")" == "function" ]; then
    return 0
  fi
  return 1
}

bpHasCmd() { ##I (deprecated)
  bpWarning "bpHasCmd is deprectad, use bpIsCmd instead!!!"
  bpIsCmd "${1}"
  return $?
}

#
# Filter out function from script file
#
# $1 file
# $2 function
#
bpGetFunction() {
  grep --no-filename -A 60 "$1" -e "${2}()" | grep -B 60 -m 1 -x "}"
}

#
# $1 command to execute
#
bpRun() { ##I Execute command
  local CMD="${1}"

  if ! bpIsCmd "${CMD}"; then
    if [ "$BP_SUDO" == true ]; then
      bpError "Could not execute \"sudo $CMD\", command does not exist!"
    else
      bpError "Could not execute \"$CMD\", command does not exist!"
    fi
    return 1
  fi

  if [ "$BP_SUDO" == true ]; then
    sudo "$@"
  else
    "$@"
  fi
  return $?
}

#
# $1 name of hook to execute
#
bpExecHook() {
  local HOOK=${!1}

  # execute hook if existing
  if bpIsFunction "${HOOK}"; then
    ${HOOK} "$@"
    return 0
  fi
  return 1
}

##C- IHELP Debug/Controll

icheck() { ##I Run shellcheck on script
  bpAssertProgs "shellcheck"
  shellcheck "$0"
}

irt() { ##I Remove tabs from script
  sed -i -e 's/\t/  /g' "${BP_SELF_DIR}/${BP_SELF}"
}

##C- IHELP Help & info

printCommand() {
  IFS=$' '
  read -r -a LINE <<<"$1"
  local DESC="${LINE[*]:3}"
  bpPrintDesc "${LINE[0]}" "${DESC}"
}

printCondCommand() {
  IFS=$' '
  read -r -a LINE <<<"$1"
  local DESC="${LINE[*]:4}"
  local COND=${LINE[3]}

  if [ -n "$IHELP" ] && [ "$COND" != "IHELP" ]; then
    return
  fi

  if [ -n "${!COND}" ]; then
    bpPrintDesc "${LINE[0]}" "${DESC}"
    return
  fi

  if [ "$2" -eq 1 ]; then
    bpPrintDescAlt "${LINE[0]}" "${DESC}"
  fi

}

printNamedLine() {
  IFS=$' '
  read -r -a LINE <<<"$1"
  bpPrintLine "${LINE[*]:1}"
}

printCondNamedLine() {
  IFS=$' '
  read -r -a LINE <<<"$1"
  local DESC=${LINE[*]:2}
  local COND=${LINE[1]}

  if [ -n "$IHELP" ] && [ "$COND" != "IHELP" ]; then
    return
  fi

  if [ -n "${!COND}" ]; then
    bpPrintLine "$DESC"
  fi
}

help() { ##D Print help information
  echo "$BP_USAGE"
  echo -e "$BP_DESC"
  echo

  BP_HELP=1

  if [ ! -e "${BP_CONFIG_DIR}" ] && [ -n "${BP_CONFIG}" ]; then
    BPINIT=1
  fi

  bpExecHook "PRE_HELP_HOOK"

  IFS=$'\n'
  local LINES
  LINES=$(grep -h '##' "$0" | grep -v -e 'grep' -e '##I' -e '##V' -e '\*##C' -e '\*##C-' -e '\"##' -e '##-//' -e 'LINE' -e 'printLine')
  LINES="${LINES//()/}"

  for LINE in ${LINES}; do
    case "$LINE" in
    *"##-"*) printNamedLine "$LINE" ;;
    *"##C-"*) printCondNamedLine "$LINE" ;;
    *"##CV"*) printCondCommand "$LINE" 1 ;;
    *"##C"*) printCondCommand "$LINE" 0 ;;
    *"##D"*) printCommand "$LINE" '##D' ;;
    *) ;;

    esac
  done

  bpExecHook "POST_HELP_HOOK"
}

#
# $1 command
#
ihelp() { ##I Print internal help information
  local CMD="$2"

  # Singe command documentation
  if [ "$CMD" != "" ]; then
    echo
    bpPrintLine "$CMD"
    echo
    echo "#"
    echo -n "# "
    grep --no-filename "$0" -e "${CMD}()" | sed -n -e 's/^.*##I //p'
    grep --no-filename -B 8 "$0" -e "${CMD}()" | grep "#" | grep -v "##"
    bpPrintLine
    bpExit
  fi

  IFS=$'\n'
  IHELP=1      # Force ihelp documentations
  BP_LOGFILE=1 # Force log documentation

  local LINES
  LINES=$(grep -h '##[C|I]' "$0" | grep -v -e 'grep' -e '\*"##[ A-Z]"\*' -e 'LINE' -e 'printNamedLine' -e 'awk' -e 'bpPrintDesc' -e 'name')
  LINES=$(echo -e "$LINES" | sed -s 's/()//g')

  for LINE in ${LINES}; do
    case "$LINE" in
    *"##C-"*) printCondNamedLine "$LINE" ;;
    *"##I"*) printCommand "$LINE" '##I' ;;
    *"##C"*) printCondCommand "$LINE" 0 ;;
    *) ;;

    esac
  done

  bpPrintLine "Bashplates comments"
  bpPrintDesc "##D Description" "Subcommand information comment (shown with help)"
  bpPrintDesc "##C COND Description" "Conditional subcommand comment (shown with help)"
  bpPrintDesc "##I Description" "Internal function comment (shown with ihelp)"
  bpPrintDesc "##- [Text]" "Separator line (shown with help)"
  bpPrintDesc "##C- COND [Text]" "Conditional separator line (shown with help)"
  bpPrintLine
}

iinfo() { ##I Show information about script
  bpPrintLine "Script information"
  bpPrintVar BP_SELF "Script" "$(bpColorizeFile "${BP_SELF_DIR}/${BP_SELF}")"
  bpPrintVar BP_VERSION "Script version"
  bpPrintVar BP_TEMPLATE_VERSION "Template version"
  bpPrintVar BP_CONFIG "Bashplate settings file" "$(bpColorizeFile "${BP_CONFIG}")"
  bpPrintVar BP_LOGFILE "Log file" "$(bpColorizeFile "${BP_LOGFILE}")"
  bpPrintVar BP_LOCK_FILE "Lock file" "$(bpColorizeFile "${BP_LOCK_FILE}")"
  bpPrintVar DEFAULT_CMD_HOOK "Default function"
  bpPrintDesc "PID" $$
  bpPrintVar BP_DATE "Date"
  bpPrintVar BP_TIME "Time"
  bpPrintVar TERM "Terminal"
  bpPrintVar BP_COLUMNS "Terminal columns"
  bpPrintVar BP_LINES "Terminal lines"

  if [ -n "${POST_INFO_HOOK}" ]; then
    bpPrintLine "App. information"
    bpExecHook "POST_INFO_HOOK"
  fi

  if [ -z "$BP_CONF" ]; then
    bpPrintLine
    return
  fi
  bpPrintLine "Bashplate config"
  local i=2
  while [ "$i" -lt ${#BP_CONFIG_LIST[@]} ]; do
    KEY=${BP_CONFIG_LIST[$i]}
    ((i++))
    ((i++))
    ((i++))
    bpPrintVar "$KEY"
  done

  bpPrintLine
}

iview() { ##I View example
  # Singe command documentation
  if [ "$2" == "" ]; then
    bpExit
  fi

  echo
  if bpIsCmd batcat; then # Use batcat, if available, to view function
    bpGetFunction "$0" "${2}" | batcat --language bash --decorations never
  else
    bpGetFunction "$0" "${2}" |
      sed -e "s/#.*/\\${BP_C_COMMENT}&\\${E_RESET}/" \
        -e "s/\<echo\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<if\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<then\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<else\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<fi\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<do\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<done\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<elif\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<case\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<esac\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<for\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<in\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<select\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<time\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<until\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<select\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<eval\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<break\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\<while\>/\\${BP_C_RESERVED}&\\${E_RESET}/" \
        -e "s/\".*\"/\\${BP_C_STRING}&\\${E_RESET}/" \
        -e "s/\([^=]*\)=/${BP_C_VAR}\1\\${E_RESET}=/"
  fi
  bpPrintLine
  bpExit
}

ivars() { ##I Print internal variables
  local LINES
  bpPrintLine "Script variables"
  echo
  IFS=$'\n'
  LINES=$(grep -v -e 'LINES' -e 'LINE' "$0" | grep -A 1 '##V') # | sed "s/--//" )
  for line in ${LINES}; do
    if [ "$line" == "--" ]; then
      echo
    else
      LINE=$(echo "${line}" | sed -u -e "s/##V[ ]/${BP_C_DESCRIPTION}/i" -e "s/^.*=/${BP_C_KEY}&${E_RESET}/i" -e "s/=/${E_RESET}=/")
      echo -e "$LINE"
      echo -en "$E_RESET"
    fi
  done
  echo
}

ied() { ##I Open this file with default editor
  bpEdit "$0" "$2"
}

#
# $1 File to diff with, if not given diff with bashplate template
#
idiff() { ##I Run diff with file or bashplate template

  if [ -z "$BP_DIFF" ]; then
    bpError "Diff program not declared (BP_DIFF)"
    return
  fi

  if [ -z "$2" ]; then
    if [ -n "${BP_PATH}" ]; then
      bpRun "${BP_DIFF}" "${BP_SELF_DIR}/${BP_SELF}" "${BP_PATH}/templates/bashplate"
      return
    fi
  fi
  bpRun "${BP_DIFF}" "${BP_SELF_DIR}/${BP_SELF}" "$2"
}

version() { ##D Print version information
  echo "$BP_VERSION"
}

# Runs a function in this file as a command
bpParseCommand() {
  local CMD="$1"
  local CL
  local CV

  # check for a default command
  if (("$BP_ARGUMENTS" == 0)); then
    if ! bpExecHook "DEFAULT_CMD_HOOK" "$@"; then
      bpErrorExit "No command given"
    fi
    bpExit
  fi

  # Check if subcommand is declared as internal function
  if ! bpIsFunction "$CMD"; then
    bpErrorExit "Command \"$CMD\" not found"
  fi

  # execute pre command hook if existing
  bpExecHook "PRE_CMD_HOOK"

  # Check if command is conditional
  # CL=$(grep -E "${command}().*##C" "$0")
  CL=$(grep "${CMD}().*##C" "$0")
  if [[ "$CL" = *"##C"* ]]; then

    # Check if condition is true and then execute else printout error message
    read -r -a ARR <<<"$CL"
    CV="${ARR[3]}"
    if [ -n "$CV" ]; then
      if [ -n "${!CV}" ]; then
        # execute command
        "${CMD}" "$@"
      else
        bpError "Command \"$CMD\" not available right now."
      fi
    else
      bpError "Command \"$CMD\" is conditional, but is missing conditional variable"
    fi
  else
    # command is not conditional, execute
    "${CMD}" "$@"
  fi

  # execute post command hook  if existing
  bpExecHook "POST_CMD_HOOK"

  bpExit
}

#---------------------------------------------------------------------
# Initiate internal variables
#---------------------------------------------------------------------

##V Bashplate version
BP_TEMPLATE_VERSION="1.40beta2"

##V Directory where script is located
BP_SELF_DIR="${0%/*}"

##V Name of script
BP_SELF_NAME=$(basename "$0")

##V Name of script (to be repurposed)
BP_SELF=$(basename "$0")

##V Number of arguments given to script
BP_ARGUMENTS=$#

##V Current date
BP_DATE=$(date +"%Y-%m-%d")

##V Current time
BP_TIME=$(date +"%H:%M:%S")

##V Number of columns in terminal
BP_COLUMNS=$(tput cols)

##V Number of lines in terminal
BP_LINES=$(tput lines)

##V Settings directory
BP_CONFIG_DIR=~/.config/bashplates

##V Settings file
BP_CONFIG_FILE=${BP_CONFIG_DIR}/bashplates.conf

##V System Path's
BP_CONFIG_PATHS="${BP_CONFIG_DIR}/path"

##V Links to modules
BP_CONFIG_MODULES="${BP_CONFIG_DIR}/modules"

BP_SUDO=false

# Initiate bashplate settings
bpInitSettings

# Initiate user settings
bpUserSettings

#---------------------------------------------------------------------
# Setup signal traps
#---------------------------------------------------------------------

trap signalQuit SIGQUIT
trap signalInt SIGINT
trap signalHup SIGHUP
trap signalTerm SIGTERM
trap 'signalErr ${FUNCNAME} ${LINENO} $?' ERR

#trap  'signalDbg ${FUNCNAME} ${LINENO}' DEBUG

#---------------------------------------------------------------------
# Load settings and execute script handler
#---------------------------------------------------------------------

BP_CONFIG_LIST=(
  "${BP_CONFIG_FILE}"
  "Bashplates common settings"
  "BP_NAME" "John Doe" "Users name"
  "BP_EMAIL" "john.doe@foo.bar" "Users email"
  "BP_ORG" "ACME" "Organisation"
  "BP_HOME" "www.foo.bar" "Home"
  "BP_LICENSE" "MIT" "Default license"
  "BP_EDITOR" "vi" "Default editor"
  "BP_DIFF" "meld" "Default diff program"
  "BP_GITSERVER" "github.com" "Default git server"
  "BP_GITUSER" "" "Default git user"
  "BP_GITPROTO" "http" "Default git protocol"
)

# Load configuration file settings
bpConfLoad "${BP_CONFIG_LIST[@]}"

# execute prescript hook if existing
#bpExecHook "PRE_SCRIPT_HOOK"

# Run command parser
bpParseCommand "$@"

# Exit cleanly
bpExit

##C- BP_HELP
